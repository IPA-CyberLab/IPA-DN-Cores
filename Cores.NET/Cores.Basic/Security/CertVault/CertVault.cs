// IPA Cores.NET
// 
// Copyright (c) 2018- IPA CyberLab.
// Copyright (c) 2003-2018 Daiyuu Nobori.
// Copyright (c) 2013-2018 SoftEther VPN Project, University of Tsukuba, Japan.
// All Rights Reserved.
// 
// License: The Apache License, Version 2.0
// https://www.apache.org/licenses/LICENSE-2.0
// 
// THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// THIS SOFTWARE IS DEVELOPED IN JAPAN, AND DISTRIBUTED FROM JAPAN, UNDER
// JAPANESE LAWS. YOU MUST AGREE IN ADVANCE TO USE, COPY, MODIFY, MERGE, PUBLISH,
// DISTRIBUTE, SUBLICENSE, AND/OR SELL COPIES OF THIS SOFTWARE, THAT ANY
// JURIDICAL DISPUTES WHICH ARE CONCERNED TO THIS SOFTWARE OR ITS CONTENTS,
// AGAINST US (IPA CYBERLAB, DAIYUU NOBORI, SOFTETHER VPN PROJECT OR OTHER
// SUPPLIERS), OR ANY JURIDICAL DISPUTES AGAINST US WHICH ARE CAUSED BY ANY KIND
// OF USING, COPYING, MODIFYING, MERGING, PUBLISHING, DISTRIBUTING, SUBLICENSING,
// AND/OR SELLING COPIES OF THIS SOFTWARE SHALL BE REGARDED AS BE CONSTRUED AND
// CONTROLLED BY JAPANESE LAWS, AND YOU MUST FURTHER CONSENT TO EXCLUSIVE
// JURISDICTION AND VENUE IN THE COURTS SITTING IN TOKYO, JAPAN. YOU MUST WAIVE
// ALL DEFENSES OF LACK OF PERSONAL JURISDICTION AND FORUM NON CONVENIENS.
// PROCESS MAY BE SERVED ON EITHER PARTY IN THE MANNER AUTHORIZED BY APPLICABLE
// LAW OR COURT RULE.

#if CORES_BASIC_JSON
#if CORES_BASIC_SECURITY

using System;
using System.Threading;
using System.Threading.Tasks;
using System.Text;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Net;

using IPA.Cores.Basic;
using IPA.Cores.ClientApi.Acme;
using IPA.Cores.Helper.Basic;
using static IPA.Cores.Globals.Basic;
using System.Security.Cryptography.X509Certificates;

namespace IPA.Cores.Basic;

public static partial class CoresConfig
{
    public static partial class CertVaultSettings
    {
        public static readonly Copenhagen<bool> DefaultUseAcme = true;
        public static readonly Copenhagen<bool> AcmeEnableFqdnIpCheck = true;
        public static readonly Copenhagen<bool> DefaultNonAcmeEnableAutoGenerateSubjectNameCert = true;
        public static readonly Copenhagen<bool> DefaultUseCertServer = false;

        public static readonly Copenhagen<int> DefaultReloadInterval = 60 * 1000;

        public static readonly Copenhagen<int> DefaultMaxAcmeCerts = 3;

        public static readonly Copenhagen<int> AcmeRenewSuppressIntervalAfterLastError = 8 * 60 * 60 * 1000;

        public static readonly Copenhagen<int> UpdateIntervalForAcmeQueueCheck = 222;

        public static readonly Copenhagen<int> MaxAcmeQueueLen = 64;

        public static readonly Copenhagen<int> DnsTimeout = 5 * 1000;
        public static readonly Copenhagen<int> DnsTryCount = 3;
        public static readonly Copenhagen<int> DnsTryInterval = 250;

        public static readonly Copenhagen<int> CertificateSelectorCacheLifetime = 1 * 1000;

        public static readonly Copenhagen<string> DefaultAcmeContactEmail = "coreslib.acme.default+changeme.__RAND__@gmail.com";

        public static readonly Copenhagen<int> MaxAutoGenerateCerts = 100;

        public static readonly Copenhagen<string> DefaultCertServerUrl = "http://ssl-cert-server.websocket.jp/wildcard_cert_files/websocket.jp/latest/";
        public static readonly Copenhagen<string> DefaultCertServerBasicAuthUsername = "user123";
        public static readonly Copenhagen<string> DefaultCertServerBasicAuthPassword = "pass123";

        public static readonly Copenhagen<int> CertServer_Interval_Normal_Msecs = 1 * 60 * 60 * 1000;
        public static readonly Copenhagen<int> CertServer_Interval_Retry_Initial_Msecs = 15 * 1000;
        public static readonly Copenhagen<int> CertServer_Interval_Retry_Max_Msecs = 5 * 60 * 1000;

        public static readonly Copenhagen<string> AcmeDefaultPreferredChainsStr = "ISRG Root X1;(STAGING) Pretend Pear X1";
    }
}

[Flags]
public enum CertVaultCertType
{
    DefaultCert = 0,
    Acme = 50,
    CertServer = 65,
    AutoGenerated = 75,
    Static = 100,
}

public class CertVaultCertificate
{
    public CertVault Vault { get; }

    public DirectoryPath? DirName { get; }
    public FileSystem? FileSystem => DirName?.FileSystem;

    public CertificateStore? Store { get; }
    public CertVaultCertType CertType { get; }
    public DateTimeOffset NotBefore => this.Store?.PrimaryContainer?.CertificateList[0]?.CertData?.NotBefore ?? Util.ZeroDateTimeOffsetValue;
    public DateTimeOffset NotAfter => this.Store?.PrimaryContainer?.CertificateList[0]?.CertData?.NotAfter ?? Util.ZeroDateTimeOffsetValue;

    public CertVaultCertificate(CertVault vault, CertificateStore store, CertVaultCertType certType)
    {
        if (certType != CertVaultCertType.DefaultCert) throw new ArgumentException("certType != CertVaultCertType.Default");

        this.Vault = vault;
        this.Store = store;
        this.CertType = certType;
    }

    public CertVaultCertificate(CertVault vault, DirectoryPath dirName, CertVaultCertType certType)
    {
        this.Vault = vault;

        if (certType.EqualsAny(CertVaultCertType.Acme, CertVaultCertType.Static, CertVaultCertType.AutoGenerated, CertVaultCertType.CertServer) == false)
        {
            throw new ArgumentOutOfRangeException("certType");
        }

        try
        {
            dirName.CreateDirectory();
        }
        catch { }

        CertificateStore? store = null;

        this.CertType = certType;
        this.DirName = dirName;

        if (certType == CertVaultCertType.Static || certType == CertVaultCertType.AutoGenerated || CertType == CertVaultCertType.CertServer)
        {
            // Static / auto generated cert
            var files = DirName.EnumDirectory().Where(x => x.IsDirectory == false);

            string? p12file = files.Where(x => x.Name._IsExtensionMatch(Consts.Extensions.Filter_Pkcs12s)).SingleOrDefault()?.FullPath;

            string? certfile = files.Where(x => x.Name._IsExtensionMatch(Consts.Extensions.Filter_Certificates)).SingleOrDefault()?.FullPath;
            string? keyfile = files.Where(x => x.Name._IsExtensionMatch(Consts.Extensions.Filter_Keys)).SingleOrDefault()?.FullPath;

            string? passwordfile = files.Where(x => x.Name._IsSamei(Consts.FileNames.CertVault_Password)).SingleOrDefault()?.FullPath;
            string? password = null;

            if (passwordfile != null)
            {
                password = FileSystem!.ReadStringFromFile(passwordfile, oneLine: true);

                if (password._IsEmpty()) password = null;
            }

            if (p12file != null)
            {
                store = new CertificateStore(FileSystem!.ReadDataFromFile(p12file).Span, password);
            }
            else if (certfile != null && keyfile != null)
            {
                store = new CertificateStore(FileSystem!.ReadDataFromFile(certfile).Span, FileSystem.ReadDataFromFile(keyfile).Span, password);
            }
            else
            {
                store = null;
            }
        }
        else
        {
            // ACME cert
            FilePath fileName = DirName.Combine(DirName.GetThisDirectoryName() + Consts.Extensions.Certificate_Acme);

            if (fileName.IsFileExists())
            {
                store = new CertificateStore(fileName.ReadDataFromFile().Span, this.Vault.AcmeCertKey!);
            }
            else
            {
                store = null;
            }
        }

        Certificate? test = store?.PrimaryContainer.CertificateList[0];

        if (test != null && store != null)
        {
            if (test.PublicKey.Equals(store.PrimaryContainer.PrivateKey.PublicKey) == false)
            {
                Con.WriteDebug($"CertVault: The public key certificate in the directory '{dirName}' doesn't match to the private key.");
                store = null;
            }
        }

        this.Store = store;
    }
}

public class CertVaultCertServerUrl
{
    public string Url = "";
    public string BasicAuthUsername = "";
    public string BasicAuthPassword = "";
    public bool UseAsDefaultCert = false;
}

public class CertVaultSettings : INormalizable, ICloneable
{
    const string AcmeDefaultUrl = AcmeClientOptions.DefaultEntryPointUrl;

    public int ReloadIntervalMsecs;
    public int MaxAcmeCerts;

    public bool UseAcme;
    public bool NonAcmeEnableAutoGenerateSubjectNameCert;

    public string? AcmeContactEmail;
    public string? AcmeServiceDirectoryUrl;
    public string[]? AcmeAllowedFqdnList;
    public bool AcmeEnableFqdnIpCheck;

    public string AcmePreferredChainsListStr = "";

    public string[]? AutoGenerateNonAcmeSubjectNameCertFqdnList;

    public bool CertServerUse;
    public CertVaultCertServerUrl[] CertServerUrlList = new List<CertVaultCertServerUrl>().ToArray();

    public CertVaultSettings()
    {
    }

    public CertVaultSettings(EnsureSpecial defaultSetting)
    {
        this.UseAcme = CoresConfig.CertVaultSettings.DefaultUseAcme;
        this.CertServerUse = CoresConfig.CertVaultSettings.DefaultUseCertServer;
        this.AcmeServiceDirectoryUrl = AcmeDefaultUrl;
        this.ReloadIntervalMsecs = CoresConfig.CertVaultSettings.DefaultReloadInterval;
        this.AcmeContactEmail = GenDefaultContactEmail();
        this.AcmeEnableFqdnIpCheck = CoresConfig.CertVaultSettings.AcmeEnableFqdnIpCheck;
        this.NonAcmeEnableAutoGenerateSubjectNameCert = CoresConfig.CertVaultSettings.DefaultNonAcmeEnableAutoGenerateSubjectNameCert;
        this.MaxAcmeCerts = CoresConfig.CertVaultSettings.DefaultMaxAcmeCerts;

        Normalize();
    }

    static string GenDefaultContactEmail()
    {
        string str = CoresConfig.CertVaultSettings.DefaultAcmeContactEmail;
        str = str.Replace("__RAND__", Secure.RandSInt31().ToString());
        return str;
    }

    public object Clone() => this.MemberwiseClone();

    public void Normalize()
    {
        if (Str.CheckMailAddress(this.AcmeContactEmail) == false) this.AcmeContactEmail = GenDefaultContactEmail();
        if (this.AcmeServiceDirectoryUrl._IsEmpty()) this.AcmeServiceDirectoryUrl = AcmeDefaultUrl;
        this.ReloadIntervalMsecs = Math.Max(this.ReloadIntervalMsecs, 1000);
        if (AcmeAllowedFqdnList == null) AcmeAllowedFqdnList = new string[1] { "*" };
        if (AutoGenerateNonAcmeSubjectNameCertFqdnList == null) AutoGenerateNonAcmeSubjectNameCertFqdnList = new string[0] { };
        if (this.MaxAcmeCerts <= 0) this.MaxAcmeCerts = CoresConfig.CertVaultSettings.DefaultMaxAcmeCerts;

        if (this.CertServerUrlList == null || this.CertServerUrlList.Length == 0)
        {
            this.CertServerUrlList = new CertVaultCertServerUrl[1]
            {
                    new CertVaultCertServerUrl
                    {
                        Url = CoresConfig.CertVaultSettings.DefaultCertServerUrl,
                        BasicAuthUsername = CoresConfig.CertVaultSettings.DefaultCertServerBasicAuthUsername,
                        BasicAuthPassword = CoresConfig.CertVaultSettings.DefaultCertServerBasicAuthPassword,
                    }
            };
        }

        if (this.AcmePreferredChainsListStr._IsEmpty())
        {
            this.AcmePreferredChainsListStr = CoresConfig.CertVaultSettings.AcmeDefaultPreferredChainsStr;
        }
    }
}

public class CertVault : AsyncServiceWithMainLoop
{
    public DirectoryPath BaseDir { get; }
    public DirectoryPath StaticDir { get; }
    public DirectoryPath AutoGeneratedDir { get; }
    public DirectoryPath AutoGeneratedDir2 { get; }
    public DirectoryPath CertServerFetchedDir { get; }
    public DirectoryPath AcmeDir { get; }

    public FilePath SettingsFilePath { get; }
    public FilePath AcmeAccountKeyFilePath { get; }
    public PrivKey? AcmeAccountKey { get; private set; }

    public FilePath AcmeCertKeyFilePath { get; }
    public PrivKey? AcmeCertKey { get; private set; }

    public bool IsGlobalCertVault { get; }

    IReadOnlyList<CertVaultCertificate> InternalCertList = null!;

    readonly CriticalSection LockObj = new CriticalSection<CertVault>();

    volatile bool AcmeQueueUpdatedFlag = false;

    readonly CriticalSection AcmeQueueLockObj = new CriticalSection<CertVault>();

    List<string> AcmeQueue = new List<string>();

    CertVaultSettings Settings = null!;

    readonly CertVaultSettings DefaultSettings;

    readonly CertificateStore? DefaultCertificate;

    CertificateStore AutoGeneratingRootCA;
    CertificateStore AutoGeneratingRootCA2;

    public TcpIpSystem TcpIp { get; }

    readonly SyncCache<HashSet<string>> AcmeExpiresUpdateFailedList = new SyncCache<HashSet<string>>(CoresConfig.CertVaultSettings.AcmeRenewSuppressIntervalAfterLastError,
        CacheFlags.IgnoreUpdateError, () => new HashSet<string>(StrComparer.IgnoreCaseComparer));

    readonly SyncCache<string, CertificateStore> CertificateSelectorCache;

    readonly SyncCache<string, CertificateStore> CertificateSelectorCache_NoAcme;

    public CertVault(DirectoryPath baseDir, CertVaultSettings? defaultSettings = null, CertificateStore? defaultCertificate = null, TcpIpSystem? tcpIp = null, bool isGlobalVault = false)
    {
        try
        {
            Util.PutGitIgnoreFileOnDirectory(baseDir, flags: FileFlags.AutoCreateDirectory);

            this.AutoGeneratingRootCA = DevTools.CoresDebugCACert.PkiCertificateStore;

            this.AutoGeneratingRootCA2 = DevTools.CoresDebugCACert.PkiCertificateStore;

            this.DefaultCertificate = defaultCertificate;

            this.TcpIp = tcpIp ?? LocalNet;

            this.IsGlobalCertVault = isGlobalVault;

            if (defaultSettings == null) defaultSettings = new CertVaultSettings(EnsureSpecial.Yes);

            this.DefaultSettings = (CertVaultSettings)defaultSettings.Clone();

            this.BaseDir = baseDir;

            this.StaticDir = this.BaseDir.GetSubDirectory("StaticCerts");

            this.AcmeDir = this.BaseDir.GetSubDirectory("AcmeCerts");

            this.AutoGeneratedDir = this.BaseDir.GetSubDirectory("AutoGeneratedCerts");

            this.AutoGeneratedDir2 = this.BaseDir.GetSubDirectory("AutoGeneratedCerts2");

            this.CertServerFetchedDir = this.BaseDir.GetSubDirectory("CertServerCerts");

            this.SettingsFilePath = this.BaseDir.Combine(Consts.FileNames.CertVault_Settings);

            this.AcmeAccountKeyFilePath = this.AcmeDir.Combine(Consts.FileNames.CertVault_AcmeAccountKey);
            this.AcmeCertKeyFilePath = this.AcmeDir.Combine(Consts.FileNames.CertVault_AcmeCertKey);

            this.CertificateSelectorCache = new SyncCache<string, CertificateStore>(CoresConfig.CertVaultSettings.CertificateSelectorCacheLifetime, CacheFlags.IgnoreUpdateError, hostname => this.SelectBestFitCertificate(hostname, out _, false));
            this.CertificateSelectorCache_NoAcme = new SyncCache<string, CertificateStore>(CoresConfig.CertVaultSettings.CertificateSelectorCacheLifetime, CacheFlags.IgnoreUpdateError, hostname => this.SelectBestFitCertificate(hostname, out _, true));

            Reload();

            this.StartMainLoop(MainLoopAsync);
        }
        catch (Exception ex)
        {
            this._DisposeSafe();
            ex._Debug();
            throw;
        }
    }

    public void Reload()
    {
        lock (LockObj)
        {
            try
            {
                InternalReload();
            }
            catch (Exception ex)
            {
                ex._Debug();
            }
        }
    }

    bool IsAcmeCertUpdated = false;

    public async Task MainLoopAsync(CancellationToken cancel)
    {
        while (cancel.IsCancellationRequested == false)
        {
            try
            {
                Reload();

                if (this.Settings.UseAcme)
                {
                    IsAcmeCertUpdated = false;

                    // Process newly requested ACME certs
                    try
                    {
                        if (this.InternalCertList.Where(x => x.CertType == CertVaultCertType.Acme).Count() < this.Settings.MaxAcmeCerts)
                        {
                            await ProcessEnqueuedAcmeHostnameAsync(cancel);
                        }
                    }
                    catch (Exception ex)
                    {
                        ex._Debug();
                    }

                    if (IsAcmeCertUpdated)
                    {
                        // ACME certificate is added. Reload
                        Reload();
                        IsAcmeCertUpdated = false;
                    }

                    // Process expiring or expires ACME certs
                    try
                    {
                        await ProcessExpiringOrExpiredAcmeCertsAsync(cancel);
                    }
                    catch (Exception ex)
                    {
                        ex._Debug();
                    }

                    if (IsAcmeCertUpdated)
                    {
                        // ACME certificate is added. Reload
                        Reload();
                        IsAcmeCertUpdated = false;
                    }
                }

                if (this.Settings.CertServerUse)
                {
                    try
                    {
                        int updatedCerts = await ProcessCertServerUrlsAsync(cancel);

                        if (updatedCerts >= 1)
                        {
                            Reload();
                        }
                    }
                    catch (Exception ex)
                    {
                        ex._Debug();
                    }
                }
            }
            catch (Exception ex)
            {
                ex._Debug();
            }

            await TaskUtil.AwaitWithPollAsync(Util.GenRandInterval(this.Settings.ReloadIntervalMsecs), CoresConfig.CertVaultSettings.UpdateIntervalForAcmeQueueCheck, () => this.AcmeQueueUpdatedFlag, cancel);
            this.AcmeQueueUpdatedFlag = false;
        }
    }

    async Task<int> ProcessCertServerUrlsAsync(CancellationToken cancel)
    {
        int updatedCerts = 0;

        foreach (CertVaultCertServerUrl url in this.Settings.CertServerUrlList)
        {
            await Task.Yield();

            cancel.ThrowIfCancellationRequested();

            if (url.Url._IsFilled())
            {
                string safeUrlStr = url.Url._MakeVerySafeAsciiOnlyNonSpaceString(true).ToLowerInvariant();

                var dir = this.CertServerFetchedDir.GetSubDirectory(safeUrlStr);

                try
                {
                    if (await ProcessCertServerOneUrlAsync(cancel, dir, url))
                    {
                        updatedCerts++;
                    }
                }
                catch (Exception ex)
                {
                    ex._Debug();
                }
            }
        }

        return updatedCerts;
    }

    public class LastTryInfo
    {
        public int TryCount = 0;
        public DateTimeOffset NextTryOnOk = Util.ZeroDateTimeOffsetValue;
        public DateTimeOffset NextTryOnError = Util.ZeroDateTimeOffsetValue;
    }

    async Task<bool> ProcessCertServerOneUrlAsync(CancellationToken cancel, DirectoryPath dir, CertVaultCertServerUrl url)
    {
        FilePath certFile = dir.Combine("cert.cer");
        FilePath keyFile = dir.Combine("cert.key");
        FilePath nextTryFile = dir.Combine("nexttry.txt");
        bool updated = false;

        bool isLocalCertOk = false;

        CertificateStore? localStore = null;
        Certificate? localCert = null;
        PrivKey? localKey = null;

        try
        {
            if (await certFile.IsFileExistsAsync(cancel) &&
                await keyFile.IsFileExistsAsync(cancel))
            {
                // 保存されている証明書ファイルと鍵ファイルを検査する
                var certData = await certFile.ReadDataFromFileAsync(cancel: cancel);
                var keyData = await keyFile.ReadDataFromFileAsync(cancel: cancel);

                localStore = new CertificateStore(certData.Span, keyData.Span);
                localCert = localStore.PrimaryCertificate;
                localKey = localStore.PrimaryPrivateKey;

                if (DtOffsetNow >= localCert.NotBefore && DtOffsetNow < localCert.NotAfter)
                {
                    isLocalCertOk = true;
                }
            }
        }
        catch (Exception ex)
        {
            ex._Debug();
        }


        LastTryInfo? info = await nextTryFile.ReadJsonFromFileAsync<LastTryInfo>(cancel: cancel, nullIfError: true);
        if (info == null) info = new LastTryInfo();

        if (isLocalCertOk)
        {
            if (info.NextTryOnOk > DtOffsetNow)
            {
                return false;
            }
        }
        else
        {
            if (info.NextTryOnError > DtOffsetNow)
            {
                return false;
            }
        }

        // 証明書のダウンロードを試行する
        await using var http = new WebApi(new WebApiOptions(new WebApiSettings { AllowAutoRedirect = true, SslAcceptAnyCerts = true, Timeout = 15 * 1000 }, doNotUseTcpStack: true));
        if (url.BasicAuthUsername._IsFilled() && url.BasicAuthPassword._IsFilled())
        {
            http.SetBasicAuthHeader(url.BasicAuthUsername, url.BasicAuthPassword);
        }

        try
        {
            // 証明書をダウンロードし、パースを試行
            var newCertBody = (await http.SimpleQueryAsync(WebMethods.GET, url.Url._CombineUrl("cert.cer").ToString())).Data;
            var newKeyBody = (await http.SimpleQueryAsync(WebMethods.GET, url.Url._CombineUrl("cert.key").ToString())).Data;
            var newCertStore = new CertificateStore(newCertBody, newKeyBody);
            var newCert = newCertStore.PrimaryCertificate;
            var newKey = newCertStore.PrimaryPrivateKey;

            // ダウンロードされた証明書の有効期限が切れていないかどうか検査
            if (DtOffsetNow >= newCert.NotBefore && DtOffsetNow < newCert.NotAfter)
            {
                isLocalCertOk = true;

                // ローカルの証明書・秘密鍵と全く同一か?
                if (localCert != null && localCert.Equals(newCert) &&
                    localKey != null && localKey.Equals(newKey))
                {
                    // 全く同一
                }
                else
                {
                    // 新しいファイルを入手したのでローカルディスクに保存する
                    await certFile.WriteDataToFileAsync(newCertBody, FileFlags.AutoCreateDirectory, cancel: cancel);
                    await keyFile.WriteDataToFileAsync(newKeyBody, FileFlags.AutoCreateDirectory, cancel: cancel);
                    await certFile.Concat(Consts.Extensions.Text).WriteStringToFileAsync(newCertStore.ExportCertInfo(), FileFlags.AutoCreateDirectory);

                    if (url.UseAsDefaultCert)
                    {
                        FilePath defaultCertPath = this.StaticDir.Combine(Consts.FileNames.CertVault_DefaultCert);

                        try
                        {
                            await defaultCertPath.WriteDataToFileAsync(newCertStore.ExportPkcs12(), FileFlags.AutoCreateDirectory, cancel: cancel);
                            await defaultCertPath.Concat(Consts.Extensions.Text).WriteStringToFileAsync(newCertStore.ExportCertInfo(), FileFlags.AutoCreateDirectory);
                        }
                        catch (Exception ex)
                        {
                            ex._Debug();
                        }
                    }

                    $"CertVault-CertServer: Fetched a new certificate from URL '{url.Url}': '{newCert}'"._Debug();

                    updated = true;
                }
            }
            else
            {
                // 証明書の有効期限が切れているものがダウンロードされた
                throw new CoresLibException($"Downloaded cert from '{url.Url}' is expired. Now = {DtOffsetNow}, NotBefore = {newCert.NotBefore}, NotAfter = {newCert.NotAfter}");
            }
        }
        catch (Exception ex)
        {
            ex._Debug();
            $"CertVault-CertServer: Fetch a new certificate from URL '{url.Url}' failed. {ex.Message}"._Error();
            isLocalCertOk = false;
        }

        info.NextTryOnOk = DtOffsetNow.AddMilliseconds(Util.GenRandInterval(CoresConfig.CertVaultSettings.CertServer_Interval_Normal_Msecs));
        info.NextTryOnError = DtOffsetNow.AddMilliseconds(Util.GenRandIntervalWithRetry(CoresConfig.CertVaultSettings.CertServer_Interval_Retry_Initial_Msecs, info.TryCount, CoresConfig.CertVaultSettings.CertServer_Interval_Retry_Max_Msecs));

        if (isLocalCertOk)
        {
            info.TryCount = 0;
            $"CertVault-CertServer: We are going to try update '{url.Url}' after '{info.NextTryOnOk}'"._Debug();
        }
        else
        {
            info.TryCount++;
            $"CertVault-CertServer: We are going to retry soon '{url.Url}' after '{info.NextTryOnError}'"._Error();
        }

        //$"info.NextTryOnOk = {info.NextTryOnOk}, info.NextTryOnError = {info.NextTryOnError}, now {DtOffsetNow}"._Debug();
        await nextTryFile.WriteJsonToFileAsync(info, flags: FileFlags.AutoCreateDirectory);

        return updated;
    }

    async Task ProcessExpiringOrExpiredAcmeCertsAsync(CancellationToken cancel)
    {
        IReadOnlyList<CertVaultCertificate> list = this.InternalCertList;

        AcmeClient? client = null;
        AcmeAccount? account = null;

        try
        {
            foreach (CertVaultCertificate cert in list)
            {
                if (cert.CertType == CertVaultCertType.Acme)
                {
                    if (cert.Store != null)
                    {
                        string certHostName = cert.DirName!.GetThisDirectoryName();

                        if (AcmeExpiresUpdateFailedList.Get()!.Contains(certHostName) == false)
                        {
                            try
                            {
                                var certData = cert.Store.PrimaryContainer.CertificateList[0].CertData;

                                if (IsCertificateDateTimeToUpdate(certData.NotBefore, certData.NotAfter))
                                {
                                    if (account == null)
                                    {
                                        client = new AcmeClient(new AcmeClientOptions(this.Settings.AcmeServiceDirectoryUrl!, this.TcpIp));
                                        account = await client.LoginAccountAsync(this.AcmeAccountKey!, ("mailto:" + this.Settings.AcmeContactEmail)._SingleArray(), cancel);
                                    }

                                    try
                                    {
                                        await ProcessAcmeFqdnAsync(account, certHostName, cancel, this.Settings.AcmePreferredChainsListStr);
                                    }
                                    catch (Exception ex)
                                    {
                                        AcmeExpiresUpdateFailedList.Get()!.Add(certHostName);
                                        ex._Debug();
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                ex._Debug();
                            }
                        }
                    }
                }
            }
        }
        finally
        {
            if (client != null)
            {
                client._DisposeSafe();
            }
        }
    }

    bool CheckFqdnAllowedForAcme(string hostname)
    {
        try
        {
            var hosts = this.Settings.AcmeAllowedFqdnList;

            if (hosts != null)
            {
                foreach (string host in hosts)
                {
                    CertificateHostName hn = new CertificateHostName(host);

                    if (hn.IsMatchForHost(hostname)) return true;
                }
            }
        }
        catch { }

        return false;
    }

    bool CheckFqdnAllowedForAutoGenerateNonAcmeSubjectNameCertFqdnList(string hostname)
    {
        try
        {
            var hosts = this.Settings.AutoGenerateNonAcmeSubjectNameCertFqdnList;

            if (hosts != null)
            {
                foreach (string host in hosts)
                {
                    if (hostname._WildcardMatch(host, true))
                    {
                        return true;
                    }
                }
            }
        }
        catch { }

        return false;
    }

    async Task ProcessEnqueuedAcmeHostnameAsync(CancellationToken cancel)
    {
        List<string> queue;

        lock (AcmeQueueLockObj)
        {
            // キューに投入された FQDN で、かつ、Acme で処理されるべき一覧を取得する
            queue = AcmeQueue.Where(fqdn => CheckFqdnAllowedForAcme(fqdn)).ToList();
            AcmeQueue = new List<string>();
        }

        if (queue.Count == 0)
        {
            // キューがない
            return;
        }

        using (AcmeClient client = new AcmeClient(new AcmeClientOptions(this.Settings.AcmeServiceDirectoryUrl!, this.TcpIp)))
        {
            AcmeAccount account = await client.LoginAccountAsync(this.AcmeAccountKey!, ("mailto:" + this.Settings.AcmeContactEmail)._SingleArray(), cancel);

            foreach (string fqdn in queue)
            {
                if (CheckFqdnAllowedForAcme(fqdn))
                {
                    if (this.Settings.AcmeEnableFqdnIpCheck == false || (await CheckFqdnHasIpAddressOfThisLocalHostAsync(fqdn, cancel)))
                    {
                        await ProcessAcmeFqdnAsync(account, fqdn, cancel, this.Settings.AcmePreferredChainsListStr);
                    }
                }
            }
        }
    }

    // 指定された FQDN に DNS 正引きを行ない、このホストが有している可能性があるグローバル IP アドレスと一致するものがあるかどうか確認する
    async Task<bool> CheckFqdnHasIpAddressOfThisLocalHostAsync(string fqdn, CancellationToken cancel)
    {
        cancel.ThrowIfCancellationRequested();

        // DNS クエリを出してみる
        DnsResponse dnsResults = await TaskUtil.RetryAsync((c) => this.TcpIp.QueryDnsAsync(new DnsGetIpQueryParam(fqdn, DnsQueryOptions.Default, CoresConfig.CertVaultSettings.DnsTimeout), c),
            retryInterval: CoresConfig.CertVaultSettings.DnsTryInterval, tryCount: CoresConfig.CertVaultSettings.DnsTryCount);

        //Con.WriteLine(dnsResults.IPAddressList.Select(x => x.ToString())._Combine(","));

        if (dnsResults.IPAddressList.Where(ip => ip._GetIPAddressType().Bit(IPAddressType.Loopback)).Any())
        {
            // 応答された DNS 応答の IP アドレスが 127.0.0.1 または ::1 の場合は、true を返すものとする。
            // (Liunx ホストで、hostname と全く一致する場合はこうなるため)
            return true;
        }

        if (dnsResults.IPAddressList.Where(ip => ip._GetIPAddressType().Bit(IPAddressType.GlobalIp) == false).Any())
        {
            // 応答された DNS 応答の IP アドレスに 1 つでも非グローバル IP アドレスが含まれている場合は、false を返すものとする。
            return false;
        }

        // このホストが有している可能性があるグローバル IP アドレスの一覧の取得
        HashSet<IPAddress> globalIpList = await this.TcpIp.GetLocalHostPossibleIpAddressListAsync(cancel);

        foreach (IPAddress ip in dnsResults.IPAddressList)
        {
            if (globalIpList.Contains(ip))
            {
                // 一致するものがあった
                return true;
            }
        }

        // 一致するものがなかった
        return false;
    }

    bool IsCertificateDateTimeToUpdate(DateTime notBefore, DateTime notAfter)
    {
        DateTime now = DateTime.UtcNow;

        DateTime middle = new DateTime((notBefore.Ticks + notAfter.Ticks) / 2);

        return (middle < now);
    }

    async Task ProcessAcmeFqdnAsync(AcmeAccount account, string fqdn, CancellationToken cancel, string preferredChains)
    {
        cancel.ThrowIfCancellationRequested();

        DirectoryPath dir = this.AcmeDir.GetSubDirectory(fqdn);

        FilePath crtFileName = dir.Combine(dir.GetThisDirectoryName() + Consts.Extensions.Certificate_Acme);

        Certificate? currentCert = null;
        if (crtFileName.IsFileExists(cancel))
        {
            try
            {
                currentCert = CertificateUtil.ImportChainedCertificates(crtFileName.ReadDataFromFile().Span).First();
            }
            catch (Exception ex)
            {
                ex._Debug();
            }
        }

        if (currentCert == null || IsCertificateDateTimeToUpdate(currentCert.CertData.NotBefore, currentCert.CertData.NotAfter))
        {
            //Con.WriteLine($"fqdn = {fqdn}, currentCert = {currentCert}, crtFileName = {crtFileName}");

            await AcmeIssueAsync(account, fqdn, crtFileName, cancel, preferredChains);
        }
    }

    async Task AcmeIssueAsync(AcmeAccount account, string fqdn, FilePath crtFileName, CancellationToken cancel, string preferredChains)
    {
        cancel.ThrowIfCancellationRequested();

        AcmeOrder order = await account.NewOrderAsync(fqdn, cancel);

        if (this.IsGlobalCertVault)
        {
            GlobalCertVault.SetAcmeAccountForChallengeResponse(account);
        }

        CertificateStore store = await order.FinalizeAsync(this.AcmeCertKey!, cancel, preferredChains);

        IsAcmeCertUpdated = true;

        store.ExportChainedPem(out ReadOnlyMemory<byte> certData, out _);

        crtFileName.WriteDataToFile(certData, additionalFlags: FileFlags.AutoCreateDirectory);

        crtFileName.Concat(Consts.Extensions.Text).WriteStringToFile(store.ExportCertInfo(), FileFlags.AutoCreateDirectory);
    }

    void InternalReload()
    {
        List<CertVaultCertificate> list = new List<CertVaultCertificate>();

        // Create directories
        try { this.BaseDir.CreateDirectory(); } catch { }
        try { this.StaticDir.CreateDirectory(); } catch { }

        Util.PutGitIgnoreFileOnDirectory(this.BaseDir, flags: FileFlags.AutoCreateDirectory);

        // Load settings
        CertVaultSettings tmpSettings = this.SettingsFilePath.ReadAndParseDataFile(ReadParseFlags.Both,
            data =>
            {
                var ret = data._GetString_UTF8()._JsonToObject<CertVaultSettings>();
                ret!.Normalize();
                return ret;
            },
            () =>
            {
                return this.DefaultSettings._ObjectToJson()._GetBytes_UTF8(true);
            },
            t => t._ObjectToJson()._GetBytes_UTF8(true));

        this.Settings = tmpSettings;

        if (this.Settings.NonAcmeEnableAutoGenerateSubjectNameCert && this.Settings.UseAcme == false)
        {
            try { this.AutoGeneratedDir.CreateDirectory(); } catch { }
        }

        if (this.Settings.CertServerUse && this.Settings.CertServerUrlList.Length >= 1)
        {
            try { this.CertServerFetchedDir.CreateDirectory(); } catch { }
        }

        if (this.Settings.AutoGenerateNonAcmeSubjectNameCertFqdnList?.Any() ?? false)
        {
            try { this.AutoGeneratedDir2.CreateDirectory(); } catch { }
        }

        if (this.Settings.UseAcme)
        {
            try { this.AcmeDir.CreateDirectory(); } catch { }

            // Create an ACME account key if not exists
            this.AcmeAccountKey = this.AcmeAccountKeyFilePath.ReadAndParseDataFile(ReadParseFlags.ForceInitOnParseError,
                data => new PrivKey(data.Span),
                () =>
                {
                    PkiUtil.GenerateEcdsaKeyPair(256, out PrivKey key, out _);
                    return key.Export();
                });

            // Create an ACME certificate key if not exists
            this.AcmeCertKey = this.AcmeCertKeyFilePath.ReadAndParseDataFile(ReadParseFlags.ForceInitOnParseError,
                data => new PrivKey(data.Span),
                () =>
                {
                    PkiUtil.GenerateRsaKeyPair(2048, out PrivKey key, out _);
                    return key.Export();
                });
        }

        // Initialize the auto-generating root CA
        if (this.Settings.NonAcmeEnableAutoGenerateSubjectNameCert && this.Settings.UseAcme == false)
        {
            FilePath rootCaPath = this.AutoGeneratedDir.Combine(Consts.FileNames.CertVault_AutoGeneratingCert);

            CertificateStore newCa = DevTools.CoresDebugCACert.PkiCertificateStore;

            if (rootCaPath.IsFileExists())
            {
                try
                {
                    CertificateStore caTmp = new CertificateStore(rootCaPath.ReadDataFromFile().Span);
                    newCa = caTmp;
                }
                catch { }
            }

            this.AutoGeneratingRootCA = newCa;
        }

        // Initialize the AutoGenerateNonAcmeSubjectNameCertFqdnList
        if (this.Settings.AutoGenerateNonAcmeSubjectNameCertFqdnList?.Any() ?? false)
        {
            FilePath rootCaPath = this.AutoGeneratedDir2.Combine(Consts.FileNames.CertVault_AutoGeneratingCert);

            CertificateStore newCa = DevTools.CoresDebugCACert.PkiCertificateStore;

            if (rootCaPath.IsFileExists())
            {
                try
                {
                    CertificateStore caTmp = new CertificateStore(rootCaPath.ReadDataFromFile().Span);
                    newCa = caTmp;
                }
                catch { }
            }

            this.AutoGeneratingRootCA2 = newCa;
        }

        // Initialize the DefaultCert
        FilePath defaultCertPath = this.StaticDir.Combine(Consts.FileNames.CertVault_DefaultCert);

        CertificateStore? defaultCert = null;

        if (this.DefaultCertificate != null)
        {
            defaultCert = this.DefaultCertificate;
        }
        else
        {
            defaultCert = defaultCertPath.ReadAndParseDataFile(ReadParseFlags.ForceInitOnParseError,
                data => new CertificateStore(data.Span),
                () =>
                {
                    if (this.DefaultCertificate != null)
                    {
                        return this.DefaultCertificate.ExportPkcs12();
                    }
                    else
                    {
                        PkiUtil.GenerateRsaKeyPair(2048, out PrivKey key, out _);
                        Certificate cert = new Certificate(key, new CertificateOptions(PkiAlgorithm.RSA, cn: Consts.Strings.DefaultCertCN + "_" + Env.MachineName, c: "US", expires: Util.MaxDateTimeOffsetValue));
                        CertificateStore store = new CertificateStore(cert, key);
                        defaultCertPath.Concat(Consts.Extensions.Text).WriteStringToFile(store.ExportCertInfo(), FileFlags.AutoCreateDirectory);
                        return store.ExportPkcs12();
                    }
                });
        }

        CertVaultCertificate defaultVaultCert = new CertVaultCertificate(this, defaultCert, CertVaultCertType.DefaultCert);
        list.Add(defaultVaultCert);

        // Enumerate StaticCerts
        ReloadCertsDir(list, this.StaticDir, CertVaultCertType.Static);

        // Enumerate Auto generated certs
        if (this.Settings.NonAcmeEnableAutoGenerateSubjectNameCert && this.Settings.UseAcme == false)
        {
            ReloadCertsDir(list, this.AutoGeneratedDir, CertVaultCertType.AutoGenerated);
        }
        if (this.Settings.AutoGenerateNonAcmeSubjectNameCertFqdnList?.Any() ?? false)
        {
            ReloadCertsDir(list, this.AutoGeneratedDir2, CertVaultCertType.AutoGenerated);
        }

        // Enumerate ACME Certs
        if (this.Settings.UseAcme)
        {
            ReloadCertsDir(list, this.AcmeDir, CertVaultCertType.Acme);
        }

        // Enumerate CertServer Certs
        if (this.Settings.CertServerUse)
        {
            ReloadCertsDir(list, this.CertServerFetchedDir, CertVaultCertType.CertServer);
        }

        this.InternalCertList = list;
    }

    void ReloadCertsDir(List<CertVaultCertificate> list, DirectoryPath dirName, CertVaultCertType type)
    {
        try
        {
            // Enumerate subdir
            var subdirs = dirName.GetDirectories();

            foreach (DirectoryPath subdir in subdirs)
            {
                ReloadCertsSubDir(list, subdir, type);
            }
        }
        catch (Exception ex)
        {
            ex._Debug();
        }
    }

    void ReloadCertsSubDir(List<CertVaultCertificate> list, DirectoryPath dirName, CertVaultCertType type)
    {
        try
        {
            CertVaultCertificate cert = new CertVaultCertificate(this, dirName, type);

            if (cert.Store != null)
            {
                if (type != CertVaultCertType.Acme || cert.NotAfter >= DateTime.UtcNow)
                {
                    list.Add(cert);
                }
            }
        }
        catch (Exception ex)
        {
            ex._Debug();
        }
    }

    class MatchResult
    {
        public CertVaultCertificate VaultCert { get; }
        public CertificateHostnameType MatchType { get; }

        public MatchResult(CertVaultCertificate vaultCert, CertificateHostnameType matchType)
        {
            VaultCert = vaultCert;
            MatchType = matchType;
        }
    }

    public CertificateStore SelectBestFitCertificate(string hostname, out CertificateHostnameType matchType, bool disableAcme = false)
    {
        hostname = hostname._NonNullTrim();

        hostname = Str.NormalizeFqdn(hostname);

        IReadOnlyList<CertVaultCertificate> list = InternalCertList;

        List<MatchResult> candidates = new List<MatchResult>();

        foreach (CertVaultCertificate cert in list)
        {
            if (cert.Store != null)
            {
                var pc = cert.Store.PrimaryContainer;
                if (pc.CertificateList.Count >= 1)
                {
                    var cert2 = pc.CertificateList[0];
                    if (cert2.IsMatchForHost(hostname, out CertificateHostnameType mt) || cert.CertType == CertVaultCertType.DefaultCert)
                    {
                        if (cert.CertType == CertVaultCertType.DefaultCert) mt = CertificateHostnameType.DefaultCert;

                        MatchResult r = new MatchResult(
                            matchType: mt,
                            vaultCert: cert
                            );

                        candidates.Add(r);
                    }
                }
            }
        }

        // MatchType が大きい順にソートする。同種の場合は、発行日が新しい順準にソートする。
        var sorted = candidates.OrderByDescending(x => x.MatchType).ThenByDescending(x => x.VaultCert.NotBefore);

        MatchResult selected = sorted.First();

        matchType = selected.MatchType;

        if (this.Settings.AutoGenerateNonAcmeSubjectNameCertFqdnList?.Any() ?? false)
        {
            // AutoGenerateNonAcmeSubjectNameCertFqdnList で指定されているホスト名であるかどうか
            if (hostname._IsEmpty() == false && matchType == CertificateHostnameType.DefaultCert)
            {
                if (CheckFqdnAllowedForAutoGenerateNonAcmeSubjectNameCertFqdnList(hostname) && PathParser.Windows.IsSafeFileName(hostname))
                {
                    if (this.AutoGeneratedDir2.EnumDirectory(flags: EnumDirectoryFlags.NoGetPhysicalSize).Where(x => x.IsDirectory).Count() >= CoresConfig.CertVaultSettings.MaxAutoGenerateCerts)
                    {
                        // すでに作成数上限に達している
                    }
                    else
                    {
                        bool forceRewrite = false;

                        L_NEW_CREATE:
                        FilePath path = this.AutoGeneratedDir2.Combine(hostname, hostname + Consts.Extensions.Pkcs12);

                        if (forceRewrite || path.IsFileExists() == false)
                        {
                            // 新規作成
                            PkiUtil.GenerateRsaKeyPair(2048, out PrivKey newKey, out _);

                            Certificate newCert = new Certificate(newKey, this.AutoGeneratingRootCA2, new CertificateOptions(PkiAlgorithm.RSA, cn: hostname.Trim(), c: "US"));
                            CertificateStore newCertStore = new CertificateStore(newCert, newKey);

                            path.WriteDataToFile(newCertStore.ExportPkcs12(), FileFlags.AutoCreateDirectory);
                            path.Concat(Consts.Extensions.Text).WriteStringToFile(newCertStore.ExportCertInfo(), FileFlags.AutoCreateDirectory);

                            // リロード
                            this.AcmeQueueUpdatedFlag = true;

                            return newCertStore;
                        }
                        else
                        {
                            try
                            {
                                // すでに存在しているファイルを返す
                                CertificateStore certStore = new CertificateStore(path.ReadDataFromFile().Span);

                                return certStore;
                            }
                            catch
                            {
                                // 読み込みに失敗した場合は再作成する
                                forceRewrite = true;
                                goto L_NEW_CREATE;
                            }
                        }
                    }
                }
            }
        }

        if (hostname.Length <= Consts.MaxLens.MaxAutoCertGeneratingFqdnLen)
        {
            if (this.Settings.UseAcme && disableAcme == false)
            {
                // ACME による証明書作成
                if (hostname._IsEmpty() == false && matchType == CertificateHostnameType.DefaultCert && hostname.Split('.').Length >= 2 && Str.CheckFqdn(hostname))
                {
                    // Add the request hostname to the ACME queue
                    if (AcmeQueue.Count < CoresConfig.CertVaultSettings.MaxAcmeQueueLen)
                    {
                        if (list.Where(x => x.CertType == CertVaultCertType.Acme).Count() < this.Settings.MaxAcmeCerts)
                        {
                            lock (this.AcmeQueueLockObj)
                            {
                                if (AcmeQueue.Contains(hostname) == false)
                                {
                                    AcmeQueue.Add(hostname);

                                    this.AcmeQueueUpdatedFlag = true;
                                }
                            }
                        }
                    }
                }
            }

            if (this.Settings.UseAcme == false && this.Settings.NonAcmeEnableAutoGenerateSubjectNameCert)
            {
                // 内部 CA による自動証明書作成
                if (hostname._IsEmpty() == false && matchType == CertificateHostnameType.DefaultCert)
                {
                    if (PathParser.Windows.IsSafeFileName(hostname))
                    {
                        if (this.AutoGeneratedDir.EnumDirectory(flags: EnumDirectoryFlags.NoGetPhysicalSize).Where(x => x.IsDirectory).Count() >= CoresConfig.CertVaultSettings.MaxAutoGenerateCerts)
                        {
                            // すでに作成数上限に達している
                        }
                        else
                        {
                            bool forceRewrite = false;

                            L_NEW_CREATE:
                            FilePath path = this.AutoGeneratedDir.Combine(hostname, hostname + Consts.Extensions.Pkcs12);

                            if (forceRewrite || path.IsFileExists() == false)
                            {
                                // 新規作成
                                PkiUtil.GenerateRsaKeyPair(2048, out PrivKey newKey, out _);

                                Certificate newCert = new Certificate(newKey, this.AutoGeneratingRootCA, new CertificateOptions(PkiAlgorithm.RSA, cn: hostname.Trim(), c: "US"));
                                CertificateStore newCertStore = new CertificateStore(newCert, newKey);

                                path.WriteDataToFile(newCertStore.ExportPkcs12(), FileFlags.AutoCreateDirectory);
                                path.Concat(Consts.Extensions.Text).WriteStringToFile(newCertStore.ExportCertInfo(), FileFlags.AutoCreateDirectory);

                                // リロード
                                this.AcmeQueueUpdatedFlag = true;

                                return newCertStore;
                            }
                            else
                            {
                                try
                                {
                                    // すでに存在しているファイルを返す
                                    CertificateStore certStore = new CertificateStore(path.ReadDataFromFile().Span);

                                    return certStore;
                                }
                                catch
                                {
                                    // 読み込みに失敗した場合は再作成する
                                    forceRewrite = true;
                                    goto L_NEW_CREATE;
                                }
                            }
                        }
                    }
                }
            }
        }

        return selected.VaultCert.Store!;
    }

    public CertificateStore CertificateStoreSelector(string sniHostname, bool disableAcme)
    {
        if (disableAcme == false)
        {
            return CertificateSelectorCache[sniHostname]!;
        }
        else
        {
            return CertificateSelectorCache_NoAcme[sniHostname]!;
        }
    }

    readonly SyncCache<string, PalX509Certificate> X509CertificateCache = new SyncCache<string, PalX509Certificate>(CoresConfig.CertVaultSettings.CertificateSelectorCacheLifetime);

    public PalX509Certificate X509CertificateSelector(string sniHostname, bool disableAcme, EnsureOk thisReturnOnlySingleCertificate)
    {
        sniHostname = sniHostname._NonNullTrim();

        CertificateStore store = CertificateStoreSelector(sniHostname, disableAcme);

        string sha1 = store.DigestSHA1Str!;

        PalX509Certificate? ret = X509CertificateCache[sha1];
        if (ret == null)
        {
            ret = store.GetX509Certificate();
            X509CertificateCache[sha1] = ret;
        }
        return ret;
    }

    public X509Certificate2 X509CertificateSelectorForHttpsServerNoAcme(object? param, string sniHostname)
    {
        return (X509Certificate2)X509CertificateSelector(sniHostname, true, EnsureOk.Ok).NativeCertificate;
    }

    protected override Task CancelImplAsync(Exception? ex)
    {
        return base.CancelImplAsync(ex);
    }

    protected override async Task CleanupImplAsync(Exception? ex)
    {
        try
        {
            if (MainLoopToWaitComplete != null)
                await this.MainLoopToWaitComplete;
        }
        finally
        {
            await base.CleanupImplAsync(ex);
        }
    }
}

public static class GlobalCertVault
{
    public static readonly StaticModule Module = new StaticModule(InitModule, FreeModule);

    static CertificateStore? DefaultCertificate = null;

    static Singleton<CertVault> Singleton = null!;

    public static DirectoryPath BaseDir { get; private set; } = null!;

    static AcmeAccount? AcmeAccountForChallengeResponse = null;

    static void InitModule()
    {
        BaseDir = Path.Combine(Env.AppLocalDir, "Config", "CertVault");

        DefaultCertificate = null;

        Singleton = new Singleton<CertVault>(() =>
        {
            try
            {
                BaseDir.CreateDirectory();
            }
            catch { }

            CertVault vault = new CertVault(BaseDir, isGlobalVault: true, defaultCertificate: DefaultCertificate);

            return vault;
        });
    }

    public static CertVault GetGlobalCertVault() => Singleton;

    public static void SetAcmeAccountForChallengeResponse(AcmeAccount account)
    {
        AcmeAccountForChallengeResponse = account;
    }

    public static void SetDefaultCertificate(CertificateStore cert)
    {
        DefaultCertificate = cert;
    }

    public static AcmeAccount? GetAcmeAccountForChallengeResponse() => AcmeAccountForChallengeResponse;

    static void FreeModule()
    {
        Singleton._DisposeSafe();
        Singleton = null!;

        BaseDir = null!;
        AcmeAccountForChallengeResponse = null;
        DefaultCertificate = null;
    }
}

#endif  // CORES_BASIC_JSON
#endif  // CORES_BASIC_SECURITY;

