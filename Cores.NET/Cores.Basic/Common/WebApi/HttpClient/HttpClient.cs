// IPA Cores.NET
// 
// Copyright (c) 2018-2019 IPA CyberLab.
// Copyright (c) 2003-2018 Daiyuu Nobori.
// Copyright (c) 2013-2018 SoftEther VPN Project, University of Tsukuba, Japan.
// All Rights Reserved.
// 
// License: The Apache License, Version 2.0
// https://www.apache.org/licenses/LICENSE-2.0
// 
// THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// THIS SOFTWARE IS DEVELOPED IN JAPAN, AND DISTRIBUTED FROM JAPAN, UNDER
// JAPANESE LAWS. YOU MUST AGREE IN ADVANCE TO USE, COPY, MODIFY, MERGE, PUBLISH,
// DISTRIBUTE, SUBLICENSE, AND/OR SELL COPIES OF THIS SOFTWARE, THAT ANY
// JURIDICAL DISPUTES WHICH ARE CONCERNED TO THIS SOFTWARE OR ITS CONTENTS,
// AGAINST US (IPA CYBERLAB, DAIYUU NOBORI, SOFTETHER VPN PROJECT OR OTHER
// SUPPLIERS), OR ANY JURIDICAL DISPUTES AGAINST US WHICH ARE CAUSED BY ANY KIND
// OF USING, COPYING, MODIFYING, MERGING, PUBLISHING, DISTRIBUTING, SUBLICENSING,
// AND/OR SELLING COPIES OF THIS SOFTWARE SHALL BE REGARDED AS BE CONSTRUED AND
// CONTROLLED BY JAPANESE LAWS, AND YOU MUST FURTHER CONSENT TO EXCLUSIVE
// JURISDICTION AND VENUE IN THE COURTS SITTING IN TOKYO, JAPAN. YOU MUST WAIVE
// ALL DEFENSES OF LACK OF PERSONAL JURISDICTION AND FORUM NON CONVENIENS.
// PROCESS MAY BE SERVED ON EITHER PARTY IN THE MANNER AUTHORIZED BY APPLICABLE
// LAW OR COURT RULE.

using System;
using System.Collections.Generic;
using System.Net.Security;
using System.Threading;
using System.Threading.Tasks;
using System.Net;
using System.Collections.Concurrent;
using System.IO;
using System.IO.Compression;
using System.Text;
using System.Security.Authentication;
using System.Net.Sockets;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Globalization;
using System.Collections;
using System.Collections.ObjectModel;
using System.Runtime.CompilerServices;
using System.Buffers;
using System.Buffers.Text;
using System.Security.Authentication.ExtendedProtection;

using IPA.Cores.Basic;
using IPA.Cores.Helper.Basic;
using static IPA.Cores.Globals.Basic;

#pragma warning disable CS0219
#pragma warning disable CS0162

// Some parts of this program are from Microsoft CoreCLR - https://github.com/dotnet/coreclr
// 
// The MIT License (MIT)
// 
// Copyright (c) .NET Foundation and Contributors
// 
// All rights reserved.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

namespace IPA.Cores.Basic.HttpClientCore
{
    /// <summary>
    ///         Authorization、ProxyAuthorization、Www-authenticate、およびプロキシ認証ヘッダーの値での認証情報を表します。
    ///       </summary>
    // Token: 0x0200011E RID: 286
    class AuthenticationHeaderValue : ICloneable
    {
        /// <summary>
        ///         承認のために使用するスキームを取得します。
        ///       </summary>
        /// <returns>
        ///         承認のために使用するスキーム。
        ///       </returns>
        // Token: 0x1700014C RID: 332
        // (get) Token: 0x060006D5 RID: 1749 RVA: 0x00052FF0 File Offset: 0x00032FF0
        public string Scheme
        {
            get
            {
                return this._scheme;
            }
        }

        /// <summary>
        ///         要求されているリソースのユーザー エージェントの認証情報を含む資格情報を取得します。
        ///       </summary>
        /// <returns>
        ///         認証情報を含む資格情報。
        ///       </returns>
        // Token: 0x1700014D RID: 333
        // (get) Token: 0x060006D6 RID: 1750 RVA: 0x00052FF8 File Offset: 0x00032FF8
        public string Parameter
        {
            get
            {
                return this._parameter;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="scheme">
        ///           承認を使用するスキームです。
        ///         </param>
        // Token: 0x060006D7 RID: 1751 RVA: 0x00053000 File Offset: 0x00033000
        public AuthenticationHeaderValue(string scheme) : this(scheme, null)
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="scheme">
        ///           承認を使用するスキームです。
        ///         </param>
        /// <param name="parameter">
        ///           要求されているリソースのユーザー エージェントの認証情報を含む資格情報。
        ///         </param>
        // Token: 0x060006D8 RID: 1752 RVA: 0x0005300A File Offset: 0x0003300A
        public AuthenticationHeaderValue(string scheme, string parameter)
        {
            HeaderUtilities.CheckValidToken(scheme, "scheme");
            this._scheme = scheme;
            this._parameter = parameter;
        }

        // Token: 0x060006D9 RID: 1753 RVA: 0x0005302B File Offset: 0x0003302B
        private AuthenticationHeaderValue(AuthenticationHeaderValue source)
        {
            this._scheme = source._scheme;
            this._parameter = source._parameter;
        }

        // Token: 0x060006DA RID: 1754 RVA: 0x00035094 File Offset: 0x00015094
        private AuthenticationHeaderValue()
        {
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x060006DB RID: 1755 RVA: 0x0005304B File Offset: 0x0003304B
        public override string ToString()
        {
            if (string.IsNullOrEmpty(this._parameter))
            {
                return this._scheme;
            }
            return this._scheme + " " + this._parameter;
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060006DC RID: 1756 RVA: 0x00053078 File Offset: 0x00033078
        public override bool Equals(object obj)
        {
            AuthenticationHeaderValue authenticationHeaderValue = obj as AuthenticationHeaderValue;
            if (authenticationHeaderValue == null)
            {
                return false;
            }
            if (string.IsNullOrEmpty(this._parameter) && string.IsNullOrEmpty(authenticationHeaderValue._parameter))
            {
                return string.Equals(this._scheme, authenticationHeaderValue._scheme, StringComparison.OrdinalIgnoreCase);
            }
            return string.Equals(this._scheme, authenticationHeaderValue._scheme, StringComparison.OrdinalIgnoreCase) && string.Equals(this._parameter, authenticationHeaderValue._parameter, StringComparison.Ordinal);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x060006DD RID: 1757 RVA: 0x000530E8 File Offset: 0x000330E8
        public override int GetHashCode()
        {
            int num = StringComparer.OrdinalIgnoreCase.GetHashCode(this._scheme);
            if (!string.IsNullOrEmpty(this._parameter))
            {
                num ^= this._parameter.GetHashCode();
            }
            return num;
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           認証ヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> インスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は有効な認証ヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x060006DE RID: 1758 RVA: 0x00053124 File Offset: 0x00033124
        public static AuthenticationHeaderValue Parse(string input)
        {
            int num = 0;
            return (AuthenticationHeaderValue)GenericHeaderParser.SingleValueAuthenticationParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060006DF RID: 1759 RVA: 0x00053148 File Offset: 0x00033148
        public static bool TryParse(string input, out AuthenticationHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.SingleValueAuthenticationParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (AuthenticationHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x060006E0 RID: 1760 RVA: 0x00053178 File Offset: 0x00033178
        internal static int GetAuthenticationLength(string input, int startIndex, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            int tokenLength = HttpRuleParser.GetTokenLength(input, startIndex);
            if (tokenLength == 0)
            {
                return 0;
            }
            AuthenticationHeaderValue authenticationHeaderValue = new AuthenticationHeaderValue();
            string text = null;
            switch (tokenLength)
            {
                case 4:
                    text = "NTLM";
                    break;
                case 5:
                    text = "Basic";
                    break;
                case 6:
                    text = "Digest";
                    break;
                case 9:
                    text = "Negotiate";
                    break;
            }
            authenticationHeaderValue._scheme = ((text != null && string.CompareOrdinal(input, startIndex, text, 0, tokenLength) == 0) ? text : (authenticationHeaderValue._scheme = input.Substring(startIndex, tokenLength)));
            int num = startIndex + tokenLength;
            int whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, num);
            num += whitespaceLength;
            if (num == input.Length || input[num] == ',')
            {
                parsedValue = authenticationHeaderValue;
                return num - startIndex;
            }
            if (whitespaceLength == 0)
            {
                return 0;
            }
            int num2 = num;
            int num3 = num;
            if (!AuthenticationHeaderValue.TrySkipFirstBlob(input, ref num, ref num3))
            {
                return 0;
            }
            if (num < input.Length && !AuthenticationHeaderValue.TryGetParametersEndIndex(input, ref num, ref num3))
            {
                return 0;
            }
            authenticationHeaderValue._parameter = input.Substring(num2, num3 - num2 + 1);
            parsedValue = authenticationHeaderValue;
            return num - startIndex;
        }

        // Token: 0x060006E1 RID: 1761 RVA: 0x00053294 File Offset: 0x00033294
        private static bool TrySkipFirstBlob(string input, ref int current, ref int parameterEndIndex)
        {
            while (current < input.Length && input[current] != ',')
            {
                if (input[current] == '"')
                {
                    int num = 0;
                    if (HttpRuleParser.GetQuotedStringLength(input, current, out num) != HttpParseResult.Parsed)
                    {
                        return false;
                    }
                    current += num;
                    parameterEndIndex = current - 1;
                }
                else
                {
                    int whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
                    if (whitespaceLength == 0)
                    {
                        parameterEndIndex = current;
                        current++;
                    }
                    else
                    {
                        current += whitespaceLength;
                    }
                }
            }
            return true;
        }

        // Token: 0x060006E2 RID: 1762 RVA: 0x00053304 File Offset: 0x00033304
        private static bool TryGetParametersEndIndex(string input, ref int parseEndIndex, ref int parameterEndIndex)
        {
            int num = parseEndIndex;
            for (; ; )
            {
                num++;
                bool flag = false;
                num = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(input, num, true, out flag);
                if (num == input.Length)
                {
                    break;
                }
                int tokenLength = HttpRuleParser.GetTokenLength(input, num);
                if (tokenLength == 0)
                {
                    return false;
                }
                num += tokenLength;
                num += HttpRuleParser.GetWhitespaceLength(input, num);
                if (num == input.Length || input[num] != '=')
                {
                    return true;
                }
                num++;
                num += HttpRuleParser.GetWhitespaceLength(input, num);
                int valueLength = NameValueHeaderValue.GetValueLength(input, num);
                if (valueLength == 0)
                {
                    return false;
                }
                num += valueLength;
                parameterEndIndex = num - 1;
                num += HttpRuleParser.GetWhitespaceLength(input, num);
                parseEndIndex = num;
                if (num >= input.Length || input[num] != ',')
                {
                    return true;
                }
            }
            return true;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x060006E3 RID: 1763 RVA: 0x000533AA File Offset: 0x000333AA
        object ICloneable.Clone()
        {
            return new AuthenticationHeaderValue(this);
        }

        // Token: 0x0400056A RID: 1386
        private string _scheme;

        // Token: 0x0400056B RID: 1387
        private string _parameter;
    }

    // Token: 0x0200011F RID: 287
    internal abstract class BaseHeaderParser : HttpHeaderParser
    {
        // Token: 0x060006E4 RID: 1764 RVA: 0x000533B2 File Offset: 0x000333B2
        protected BaseHeaderParser(bool supportsMultipleValues) : base(supportsMultipleValues)
        {
        }

        // Token: 0x060006E5 RID: 1765
        protected abstract int GetParsedValueLength(string value, int startIndex, object storeValue, out object parsedValue);

        // Token: 0x060006E6 RID: 1766 RVA: 0x000533BC File Offset: 0x000333BC
        public sealed override bool TryParseValue(string value, object storeValue, ref int index, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(value) || index == value.Length)
            {
                return base.SupportsMultipleValues;
            }
            bool flag = false;
            int num = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(value, index, base.SupportsMultipleValues, out flag);
            if (flag && !base.SupportsMultipleValues)
            {
                return false;
            }
            if (num == value.Length)
            {
                if (base.SupportsMultipleValues)
                {
                    index = num;
                }
                return base.SupportsMultipleValues;
            }
            object obj = null;
            int parsedValueLength = this.GetParsedValueLength(value, num, storeValue, out obj);
            if (parsedValueLength == 0)
            {
                return false;
            }
            num += parsedValueLength;
            num = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(value, num, base.SupportsMultipleValues, out flag);
            if ((flag && !base.SupportsMultipleValues) || (!flag && num < value.Length))
            {
                return false;
            }
            index = num;
            parsedValue = obj;
            return true;
        }
    }

    // Token: 0x02000120 RID: 288
    internal class ByteArrayHeaderParser : HttpHeaderParser
    {
        // Token: 0x060006E7 RID: 1767 RVA: 0x00053469 File Offset: 0x00033469
        private ByteArrayHeaderParser() : base(false)
        {
        }

        // Token: 0x060006E8 RID: 1768 RVA: 0x00053472 File Offset: 0x00033472
        public override string ToString(object value)
        {
            return Convert.ToBase64String((byte[])value);
        }

        // Token: 0x060006E9 RID: 1769 RVA: 0x00053480 File Offset: 0x00033480
        public override bool TryParseValue(string value, object storeValue, ref int index, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(value) || index == value.Length)
            {
                return false;
            }
            string text = value;
            if (index > 0)
            {
                text = value.Substring(index);
            }
            try
            {
                parsedValue = Convert.FromBase64String(text);
                index = value.Length;
                return true;
            }
            catch (FormatException ex)
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(this, SR.Format(SR.net_http_parser_invalid_base64_string, text, ex.Message), "TryParseValue");
                }
            }
            return false;
        }

        // Token: 0x0400056C RID: 1388
        internal static readonly ByteArrayHeaderParser Parser = new ByteArrayHeaderParser();
    }

    // Token: 0x02000121 RID: 289
    internal class CacheControlHeaderParser : BaseHeaderParser
    {
        // Token: 0x060006EB RID: 1771 RVA: 0x00053510 File Offset: 0x00033510
        private CacheControlHeaderParser() : base(true)
        {
        }

        // Token: 0x060006EC RID: 1772 RVA: 0x0005351C File Offset: 0x0003351C
        protected override int GetParsedValueLength(string value, int startIndex, object storeValue, out object parsedValue)
        {
            CacheControlHeaderValue cacheControlHeaderValue = storeValue as CacheControlHeaderValue;
            int cacheControlLength = CacheControlHeaderValue.GetCacheControlLength(value, startIndex, cacheControlHeaderValue, out cacheControlHeaderValue);
            parsedValue = cacheControlHeaderValue;
            return cacheControlLength;
        }

        // Token: 0x0400056D RID: 1389
        internal static readonly CacheControlHeaderParser Parser = new CacheControlHeaderParser();
    }

    /// <summary>
    ///         Cache-Control ヘッダーの値を表します。
    ///       </summary>
    // Token: 0x02000122 RID: 290
    class CacheControlHeaderValue : ICloneable
    {
        /// <summary>
        ///         HTTP クライアントがキャッシュされた応答を許容できるかどうか。
        ///       </summary>
        /// <returns>
        ///         HTTP クライアントがキャッシュされた応答を許容できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x1700014E RID: 334
        // (get) Token: 0x060006EE RID: 1774 RVA: 0x0005354C File Offset: 0x0003354C
        // (set) Token: 0x060006EF RID: 1775 RVA: 0x00053554 File Offset: 0x00033554
        public bool NoCache
        {
            get
            {
                return this._noCache;
            }
            set
            {
                this._noCache = value;
            }
        }

        /// <summary>
        ///         HTTP 応答のキャッシュ コントロール ヘッダー フィールドにある "no-cache" ディレクティブ内の fieldnames のコレクション。
        ///       </summary>
        /// <returns>
        ///         fieldnames のコレクション。
        ///       </returns>
        // Token: 0x1700014F RID: 335
        // (get) Token: 0x060006F0 RID: 1776 RVA: 0x0005355D File Offset: 0x0003355D
        public ICollection<string> NoCacheHeaders
        {
            get
            {
                if (this._noCacheHeaders == null)
                {
                    this._noCacheHeaders = new ObjectCollection<string>(CacheControlHeaderValue.s_checkIsValidToken);
                }
                return this._noCacheHeaders;
            }
        }

        /// <summary>
        ///         キャッシュが、HTTP 要求メッセージまたは任意の応答のいずれかの一部を格納してはいけないかどうか。
        ///       </summary>
        /// <returns>
        ///         キャッシュが、HTTP 要求メッセージまたは任意の応答のいずれかの一部を格納してはいけない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x17000150 RID: 336
        // (get) Token: 0x060006F1 RID: 1777 RVA: 0x0005357D File Offset: 0x0003357D
        // (set) Token: 0x060006F2 RID: 1778 RVA: 0x00053585 File Offset: 0x00033585
        public bool NoStore
        {
            get
            {
                return this._noStore;
            }
            set
            {
                this._noStore = value;
            }
        }

        /// <summary>
        ///         HTTP クライアントが応答を許容できる最大有効期間 (秒単位で指定)。
        ///       </summary>
        /// <returns>
        ///         時間 (秒単位)。
        ///       </returns>
        // Token: 0x17000151 RID: 337
        // (get) Token: 0x060006F3 RID: 1779 RVA: 0x0005358E File Offset: 0x0003358E
        // (set) Token: 0x060006F4 RID: 1780 RVA: 0x00053596 File Offset: 0x00033596
        public TimeSpan? MaxAge
        {
            get
            {
                return this._maxAge;
            }
            set
            {
                this._maxAge = value;
            }
        }

        /// <summary>
        ///         秒で指定した、キャッシュ制御ヘッダーまたは共有キャッシュの Expires ヘッダーにある「最長期間」ディレクティブをオーバーライドする HTTP 応答での共有の最長時間。
        ///       </summary>
        /// <returns>
        ///         時間 (秒単位)。
        ///       </returns>
        // Token: 0x17000152 RID: 338
        // (get) Token: 0x060006F5 RID: 1781 RVA: 0x0005359F File Offset: 0x0003359F
        // (set) Token: 0x060006F6 RID: 1782 RVA: 0x000535A7 File Offset: 0x000335A7
        public TimeSpan? SharedMaxAge
        {
            get
            {
                return this._sharedMaxAge;
            }
            set
            {
                this._sharedMaxAge = value;
            }
        }

        /// <summary>
        ///         HTTP クライアントが有効期限を超えた応答を許容するかどうか。
        ///       </summary>
        /// <returns>
        ///         HTTP クライアントが有効期限を超えた応答を許容する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x17000153 RID: 339
        // (get) Token: 0x060006F7 RID: 1783 RVA: 0x000535B0 File Offset: 0x000335B0
        // (set) Token: 0x060006F8 RID: 1784 RVA: 0x000535B8 File Offset: 0x000335B8
        public bool MaxStale
        {
            get
            {
                return this._maxStale;
            }
            set
            {
                this._maxStale = value;
            }
        }

        /// <summary>
        ///         最大時間 (秒単位)、HTTP クライアントは有効期限を超えた応答を許容できます。
        ///       </summary>
        /// <returns>
        ///         時間 (秒単位)。
        ///       </returns>
        // Token: 0x17000154 RID: 340
        // (get) Token: 0x060006F9 RID: 1785 RVA: 0x000535C1 File Offset: 0x000335C1
        // (set) Token: 0x060006FA RID: 1786 RVA: 0x000535C9 File Offset: 0x000335C9
        public TimeSpan? MaxStaleLimit
        {
            get
            {
                return this._maxStaleLimit;
            }
            set
            {
                this._maxStaleLimit = value;
            }
        }

        /// <summary>
        ///         HTTP クライアントが応答を許容する更新の有効期間 (秒単位で指定)。
        ///       </summary>
        /// <returns>
        ///         時間 (秒単位)。
        ///       </returns>
        // Token: 0x17000155 RID: 341
        // (get) Token: 0x060006FB RID: 1787 RVA: 0x000535D2 File Offset: 0x000335D2
        // (set) Token: 0x060006FC RID: 1788 RVA: 0x000535DA File Offset: 0x000335DA
        public TimeSpan? MinFresh
        {
            get
            {
                return this._minFresh;
            }
            set
            {
                this._minFresh = value;
            }
        }

        /// <summary>
        ///         キャッシュまたはプロキシがエンティティ本体の側面を変更する必要はありません。
        ///       </summary>
        /// <returns>
        ///         キャッシュまたはプロキシがエンティティ本体の側面を変更する必要がない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x17000156 RID: 342
        // (get) Token: 0x060006FD RID: 1789 RVA: 0x000535E3 File Offset: 0x000335E3
        // (set) Token: 0x060006FE RID: 1790 RVA: 0x000535EB File Offset: 0x000335EB
        public bool NoTransform
        {
            get
            {
                return this._noTransform;
            }
            set
            {
                this._noTransform = value;
            }
        }

        /// <summary>
        ///         キャッシュの応答に、HTTP 応答の他の制約と一致するキャッシュ エントリを使用するか、504 (ゲートウェイ タイムアウト) 状態を使用するかどうか。
        ///       </summary>
        /// <returns>
        ///         キャッシュの応答に、HTTP 応答の他の制約と一致するキャッシュ エントリを使用するか、504 (ゲートウェイ タイムアウト) 状態を使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x17000157 RID: 343
        // (get) Token: 0x060006FF RID: 1791 RVA: 0x000535F4 File Offset: 0x000335F4
        // (set) Token: 0x06000700 RID: 1792 RVA: 0x000535FC File Offset: 0x000335FC
        public bool OnlyIfCached
        {
            get
            {
                return this._onlyIfCached;
            }
            set
            {
                this._onlyIfCached = value;
            }
        }

        /// <summary>
        ///         HTTP 応答が、通常はキャッシュできない、または非共有キャッシュにのみキャッシュ可能であっても、任意のキャッシュによってキャッシュされる可能性があるかどうか。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答が、通常はキャッシュできない、または非共有キャッシュにのみキャッシュ可能であっても、任意のキャッシュによってキャッシュされる可能性がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x17000158 RID: 344
        // (get) Token: 0x06000701 RID: 1793 RVA: 0x00053605 File Offset: 0x00033605
        // (set) Token: 0x06000702 RID: 1794 RVA: 0x0005360D File Offset: 0x0003360D
        public bool Public
        {
            get
            {
                return this._publicField;
            }
            set
            {
                this._publicField = value;
            }
        }

        /// <summary>
        ///         HTTP 応答メッセージのすべてまたは一部が単一ユーザーに向けたものであって共有キャッシュでキャッシュされるべきでないかどうか。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答メッセージのすべてまたは一部が単一ユーザーに向けたものであって共有キャッシュでキャッシュされるべきでない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x17000159 RID: 345
        // (get) Token: 0x06000703 RID: 1795 RVA: 0x00053616 File Offset: 0x00033616
        // (set) Token: 0x06000704 RID: 1796 RVA: 0x0005361E File Offset: 0x0003361E
        public bool Private
        {
            get
            {
                return this._privateField;
            }
            set
            {
                this._privateField = value;
            }
        }

        /// <summary>
        ///         HTTP 応答のキャッシュ コントロール ヘッダー フィールドにある "private" ディレクティブ内のコレクション fieldnames。
        ///       </summary>
        /// <returns>
        ///         fieldnames のコレクション。
        ///       </returns>
        // Token: 0x1700015A RID: 346
        // (get) Token: 0x06000705 RID: 1797 RVA: 0x00053627 File Offset: 0x00033627
        public ICollection<string> PrivateHeaders
        {
            get
            {
                if (this._privateHeaders == null)
                {
                    this._privateHeaders = new ObjectCollection<string>(CacheControlHeaderValue.s_checkIsValidToken);
                }
                return this._privateHeaders;
            }
        }

        /// <summary>
        ///         キャッシュ エントリが古くなったとき、元のサーバーで以降の使用においてキャッシュ エントリの再検証が必要かどうか。
        ///       </summary>
        /// <returns>
        ///         キャッシュ エントリが古くなったとき、元のサーバーで以降の使用においてキャッシュ エントリの再検証が必要な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x1700015B RID: 347
        // (get) Token: 0x06000706 RID: 1798 RVA: 0x00053647 File Offset: 0x00033647
        // (set) Token: 0x06000707 RID: 1799 RVA: 0x0005364F File Offset: 0x0003364F
        public bool MustRevalidate
        {
            get
            {
                return this._mustRevalidate;
            }
            set
            {
                this._mustRevalidate = value;
            }
        }

        /// <summary>
        ///         共有のユーザー エージェントのキャッシュでキャッシュ エントリが古くなったとき、元のサーバーで以降の使用においてキャッシュ エントリの再検証が必要かどうか。
        ///       </summary>
        /// <returns>
        ///         共有のユーザー エージェントのキャッシュでキャッシュ エントリが古くなったとき、元のサーバーで以降の使用においてキャッシュ エントリの再検証が必要な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x1700015C RID: 348
        // (get) Token: 0x06000708 RID: 1800 RVA: 0x00053658 File Offset: 0x00033658
        // (set) Token: 0x06000709 RID: 1801 RVA: 0x00053660 File Offset: 0x00033660
        public bool ProxyRevalidate
        {
            get
            {
                return this._proxyRevalidate;
            }
            set
            {
                this._proxyRevalidate = value;
            }
        }

        /// <summary>
        ///         それぞれにオプションで割り当てられた値を持つキャッシュ拡張トークン。
        ///       </summary>
        /// <returns>
        ///         それぞれにオプションで割り当てられた値を持つキャッシュ拡張トークンのコレクション。
        ///       </returns>
        // Token: 0x1700015D RID: 349
        // (get) Token: 0x0600070A RID: 1802 RVA: 0x00053669 File Offset: 0x00033669
        public ICollection<NameValueHeaderValue> Extensions
        {
            get
            {
                if (this._extensions == null)
                {
                    this._extensions = new ObjectCollection<NameValueHeaderValue>();
                }
                return this._extensions;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.CacheControlHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        // Token: 0x0600070B RID: 1803 RVA: 0x00035094 File Offset: 0x00015094
        public CacheControlHeaderValue()
        {
        }

        // Token: 0x0600070C RID: 1804 RVA: 0x00053684 File Offset: 0x00033684
        private CacheControlHeaderValue(CacheControlHeaderValue source)
        {
            this._noCache = source._noCache;
            this._noStore = source._noStore;
            this._maxAge = source._maxAge;
            this._sharedMaxAge = source._sharedMaxAge;
            this._maxStale = source._maxStale;
            this._maxStaleLimit = source._maxStaleLimit;
            this._minFresh = source._minFresh;
            this._noTransform = source._noTransform;
            this._onlyIfCached = source._onlyIfCached;
            this._publicField = source._publicField;
            this._privateField = source._privateField;
            this._mustRevalidate = source._mustRevalidate;
            this._proxyRevalidate = source._proxyRevalidate;
            if (source._noCacheHeaders != null)
            {
                foreach (string item in source._noCacheHeaders)
                {
                    this.NoCacheHeaders.Add(item);
                }
            }
            if (source._privateHeaders != null)
            {
                foreach (string item2 in source._privateHeaders)
                {
                    this.PrivateHeaders.Add(item2);
                }
            }
            if (source._extensions != null)
            {
                foreach (NameValueHeaderValue nameValueHeaderValue in source._extensions)
                {
                    this.Extensions.Add((NameValueHeaderValue)((ICloneable)nameValueHeaderValue).Clone());
                }
            }
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.CacheControlHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x0600070D RID: 1805 RVA: 0x00053834 File Offset: 0x00033834
        public override string ToString()
        {
            StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
            CacheControlHeaderValue.AppendValueIfRequired(stringBuilder, this._noStore, "no-store");
            CacheControlHeaderValue.AppendValueIfRequired(stringBuilder, this._noTransform, "no-transform");
            CacheControlHeaderValue.AppendValueIfRequired(stringBuilder, this._onlyIfCached, "only-if-cached");
            CacheControlHeaderValue.AppendValueIfRequired(stringBuilder, this._publicField, "public");
            CacheControlHeaderValue.AppendValueIfRequired(stringBuilder, this._mustRevalidate, "must-revalidate");
            CacheControlHeaderValue.AppendValueIfRequired(stringBuilder, this._proxyRevalidate, "proxy-revalidate");
            if (this._noCache)
            {
                CacheControlHeaderValue.AppendValueWithSeparatorIfRequired(stringBuilder, "no-cache");
                if (this._noCacheHeaders != null && this._noCacheHeaders.Count > 0)
                {
                    stringBuilder.Append("=\"");
                    CacheControlHeaderValue.AppendValues(stringBuilder, this._noCacheHeaders);
                    stringBuilder.Append('"');
                }
            }
            if (this._maxAge != null)
            {
                CacheControlHeaderValue.AppendValueWithSeparatorIfRequired(stringBuilder, "max-age");
                stringBuilder.Append('=');
                stringBuilder.Append(((int)this._maxAge.Value.TotalSeconds).ToString(NumberFormatInfo.InvariantInfo));
            }
            if (this._sharedMaxAge != null)
            {
                CacheControlHeaderValue.AppendValueWithSeparatorIfRequired(stringBuilder, "s-maxage");
                stringBuilder.Append('=');
                stringBuilder.Append(((int)this._sharedMaxAge.Value.TotalSeconds).ToString(NumberFormatInfo.InvariantInfo));
            }
            if (this._maxStale)
            {
                CacheControlHeaderValue.AppendValueWithSeparatorIfRequired(stringBuilder, "max-stale");
                if (this._maxStaleLimit != null)
                {
                    stringBuilder.Append('=');
                    stringBuilder.Append(((int)this._maxStaleLimit.Value.TotalSeconds).ToString(NumberFormatInfo.InvariantInfo));
                }
            }
            if (this._minFresh != null)
            {
                CacheControlHeaderValue.AppendValueWithSeparatorIfRequired(stringBuilder, "min-fresh");
                stringBuilder.Append('=');
                stringBuilder.Append(((int)this._minFresh.Value.TotalSeconds).ToString(NumberFormatInfo.InvariantInfo));
            }
            if (this._privateField)
            {
                CacheControlHeaderValue.AppendValueWithSeparatorIfRequired(stringBuilder, "private");
                if (this._privateHeaders != null && this._privateHeaders.Count > 0)
                {
                    stringBuilder.Append("=\"");
                    CacheControlHeaderValue.AppendValues(stringBuilder, this._privateHeaders);
                    stringBuilder.Append('"');
                }
            }
            NameValueHeaderValue.ToString(this._extensions, ',', false, stringBuilder);
            return StringBuilderCache.GetStringAndRelease(stringBuilder);
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.CacheControlHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x0600070E RID: 1806 RVA: 0x00053A84 File Offset: 0x00033A84
        public override bool Equals(object obj)
        {
            CacheControlHeaderValue cacheControlHeaderValue = obj as CacheControlHeaderValue;
            return cacheControlHeaderValue != null && (this._noCache == cacheControlHeaderValue._noCache && this._noStore == cacheControlHeaderValue._noStore) && !(this._maxAge != cacheControlHeaderValue._maxAge) && (!(this._sharedMaxAge != cacheControlHeaderValue._sharedMaxAge) && this._maxStale == cacheControlHeaderValue._maxStale) && !(this._maxStaleLimit != cacheControlHeaderValue._maxStaleLimit) && !(this._minFresh != cacheControlHeaderValue._minFresh) && this._noTransform == cacheControlHeaderValue._noTransform && this._onlyIfCached == cacheControlHeaderValue._onlyIfCached && this._publicField == cacheControlHeaderValue._publicField && this._privateField == cacheControlHeaderValue._privateField && this._mustRevalidate == cacheControlHeaderValue._mustRevalidate && this._proxyRevalidate == cacheControlHeaderValue._proxyRevalidate && HeaderUtilities.AreEqualCollections<string>(this._noCacheHeaders, cacheControlHeaderValue._noCacheHeaders, StringComparer.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections<string>(this._privateHeaders, cacheControlHeaderValue._privateHeaders, StringComparer.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections<NameValueHeaderValue>(this._extensions, cacheControlHeaderValue._extensions);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.CacheControlHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x0600070F RID: 1807 RVA: 0x00053C84 File Offset: 0x00033C84
        public override int GetHashCode()
        {
            int num = this._noCache.GetHashCode() ^ this._noStore.GetHashCode() << 1 ^ this._maxStale.GetHashCode() << 2 ^ this._noTransform.GetHashCode() << 3 ^ this._onlyIfCached.GetHashCode() << 4 ^ this._publicField.GetHashCode() << 5 ^ this._privateField.GetHashCode() << 6 ^ this._mustRevalidate.GetHashCode() << 7 ^ this._proxyRevalidate.GetHashCode() << 8;
            num = (num ^ ((this._maxAge != null) ? (this._maxAge.Value.GetHashCode() ^ 1) : 0) ^ ((this._sharedMaxAge != null) ? (this._sharedMaxAge.Value.GetHashCode() ^ 2) : 0) ^ ((this._maxStaleLimit != null) ? (this._maxStaleLimit.Value.GetHashCode() ^ 4) : 0) ^ ((this._minFresh != null) ? (this._minFresh.Value.GetHashCode() ^ 8) : 0));
            if (this._noCacheHeaders != null && this._noCacheHeaders.Count > 0)
            {
                foreach (string obj in this._noCacheHeaders)
                {
                    num ^= StringComparer.OrdinalIgnoreCase.GetHashCode(obj);
                }
            }
            if (this._privateHeaders != null && this._privateHeaders.Count > 0)
            {
                foreach (string obj2 in this._privateHeaders)
                {
                    num ^= StringComparer.OrdinalIgnoreCase.GetHashCode(obj2);
                }
            }
            if (this._extensions != null && this._extensions.Count > 0)
            {
                foreach (NameValueHeaderValue nameValueHeaderValue in this._extensions)
                {
                    num ^= nameValueHeaderValue.GetHashCode();
                }
            }
            return num;
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.CacheControlHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           Cache-Control ヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.CacheControlHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は、有効な Cache-Control ヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x06000710 RID: 1808 RVA: 0x00053EE4 File Offset: 0x00033EE4
        public static CacheControlHeaderValue Parse(string input)
        {
            int num = 0;
            return (CacheControlHeaderValue)CacheControlHeaderParser.Parser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.CacheControlHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.CacheControlHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.CacheControlHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000711 RID: 1809 RVA: 0x00053F08 File Offset: 0x00033F08
        public static bool TryParse(string input, out CacheControlHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (CacheControlHeaderParser.Parser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (CacheControlHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x06000712 RID: 1810 RVA: 0x00053F38 File Offset: 0x00033F38
        internal static int GetCacheControlLength(string input, int startIndex, CacheControlHeaderValue storeValue, out CacheControlHeaderValue parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            int i = startIndex;
            object obj = null;
            List<NameValueHeaderValue> list = new List<NameValueHeaderValue>();
            while (i < input.Length)
            {
                if (!CacheControlHeaderValue.s_nameValueListParser.TryParseValue(input, null, ref i, out obj))
                {
                    return 0;
                }
                list.Add(obj as NameValueHeaderValue);
            }
            CacheControlHeaderValue cacheControlHeaderValue = storeValue;
            if (cacheControlHeaderValue == null)
            {
                cacheControlHeaderValue = new CacheControlHeaderValue();
            }
            if (!CacheControlHeaderValue.TrySetCacheControlValues(cacheControlHeaderValue, list))
            {
                return 0;
            }
            if (storeValue == null)
            {
                parsedValue = cacheControlHeaderValue;
            }
            return input.Length - startIndex;
        }

        internal static uint ComputeStringHash(string s)
        {
            uint num = 0;
            if (s != null)
            {
                num = 2166136261u;
                for (int i = 0; i < s.Length; i++)
                {
                    num = ((uint)s[i] ^ num) * 16777619u;
                }
            }
            return num;
        }

        // Token: 0x06000713 RID: 1811 RVA: 0x00053FB4 File Offset: 0x00033FB4
        private static bool TrySetCacheControlValues(CacheControlHeaderValue cc, List<NameValueHeaderValue> nameValueList)
        {
            foreach (NameValueHeaderValue nameValueHeaderValue in nameValueList)
            {
                bool flag = true;
                string text = nameValueHeaderValue.Name.ToLowerInvariant();
                uint num = ComputeStringHash(text);
                if (num <= 1922561311u)
                {
                    if (num <= 719568158u)
                    {
                        if (num != 129047354u)
                        {
                            if (num != 412259456u)
                            {
                                if (num != 719568158u)
                                {
                                    goto IL_2C4;
                                }
                                if (!(text == "no-store"))
                                {
                                    goto IL_2C4;
                                }
                                flag = CacheControlHeaderValue.TrySetTokenOnlyValue(nameValueHeaderValue, ref cc._noStore);
                            }
                            else
                            {
                                if (!(text == "s-maxage"))
                                {
                                    goto IL_2C4;
                                }
                                flag = CacheControlHeaderValue.TrySetTimeSpan(nameValueHeaderValue, ref cc._sharedMaxAge);
                            }
                        }
                        else
                        {
                            if (!(text == "min-fresh"))
                            {
                                goto IL_2C4;
                            }
                            flag = CacheControlHeaderValue.TrySetTimeSpan(nameValueHeaderValue, ref cc._minFresh);
                        }
                    }
                    else if (num != 962188105u)
                    {
                        if (num != 1657474316u)
                        {
                            if (num != 1922561311u)
                            {
                                goto IL_2C4;
                            }
                            if (!(text == "max-age"))
                            {
                                goto IL_2C4;
                            }
                            flag = CacheControlHeaderValue.TrySetTimeSpan(nameValueHeaderValue, ref cc._maxAge);
                        }
                        else
                        {
                            if (!(text == "private"))
                            {
                                goto IL_2C4;
                            }
                            flag = CacheControlHeaderValue.TrySetOptionalTokenList(nameValueHeaderValue, ref cc._privateField, ref cc._privateHeaders);
                        }
                    }
                    else
                    {
                        if (!(text == "max-stale"))
                        {
                            goto IL_2C4;
                        }
                        flag = (nameValueHeaderValue.Value == null || CacheControlHeaderValue.TrySetTimeSpan(nameValueHeaderValue, ref cc._maxStaleLimit));
                        if (flag)
                        {
                            cc._maxStale = true;
                        }
                    }
                }
                else if (num <= 2802093227u)
                {
                    if (num != 2033558065u)
                    {
                        if (num != 2154495528u)
                        {
                            if (num != 2802093227u)
                            {
                                goto IL_2C4;
                            }
                            if (!(text == "no-transform"))
                            {
                                goto IL_2C4;
                            }
                            flag = CacheControlHeaderValue.TrySetTokenOnlyValue(nameValueHeaderValue, ref cc._noTransform);
                        }
                        else
                        {
                            if (!(text == "must-revalidate"))
                            {
                                goto IL_2C4;
                            }
                            flag = CacheControlHeaderValue.TrySetTokenOnlyValue(nameValueHeaderValue, ref cc._mustRevalidate);
                        }
                    }
                    else
                    {
                        if (!(text == "proxy-revalidate"))
                        {
                            goto IL_2C4;
                        }
                        flag = CacheControlHeaderValue.TrySetTokenOnlyValue(nameValueHeaderValue, ref cc._proxyRevalidate);
                    }
                }
                else if (num != 2866772502u)
                {
                    if (num != 3432027008u)
                    {
                        if (num != 3443516981u)
                        {
                            goto IL_2C4;
                        }
                        if (!(text == "no-cache"))
                        {
                            goto IL_2C4;
                        }
                        flag = CacheControlHeaderValue.TrySetOptionalTokenList(nameValueHeaderValue, ref cc._noCache, ref cc._noCacheHeaders);
                    }
                    else
                    {
                        if (!(text == "public"))
                        {
                            goto IL_2C4;
                        }
                        flag = CacheControlHeaderValue.TrySetTokenOnlyValue(nameValueHeaderValue, ref cc._publicField);
                    }
                }
                else
                {
                    if (!(text == "only-if-cached"))
                    {
                        goto IL_2C4;
                    }
                    flag = CacheControlHeaderValue.TrySetTokenOnlyValue(nameValueHeaderValue, ref cc._onlyIfCached);
                }
                IL_2D0:
                if (!flag)
                {
                    return false;
                }
                continue;
                IL_2C4:
                cc.Extensions.Add(nameValueHeaderValue);
                goto IL_2D0;
            }
            return true;
        }

        // Token: 0x06000714 RID: 1812 RVA: 0x000542D8 File Offset: 0x000342D8
        private static bool TrySetTokenOnlyValue(NameValueHeaderValue nameValue, ref bool boolField)
        {
            if (nameValue.Value != null)
            {
                return false;
            }
            boolField = true;
            return true;
        }

        // Token: 0x06000715 RID: 1813 RVA: 0x000542E8 File Offset: 0x000342E8
        private static bool TrySetOptionalTokenList(NameValueHeaderValue nameValue, ref bool boolField, ref ObjectCollection<string> destination)
        {
            if (nameValue.Value == null)
            {
                boolField = true;
                return true;
            }
            string value = nameValue.Value;
            if (value.Length < 3 || value[0] != '"' || value[value.Length - 1] != '"')
            {
                return false;
            }
            int i = 1;
            int num = value.Length - 1;
            bool flag = false;
            int num2 = (destination == null) ? 0 : destination.Count;
            while (i < num)
            {
                i = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(value, i, true, out flag);
                if (i == num)
                {
                    break;
                }
                int tokenLength = HttpRuleParser.GetTokenLength(value, i);
                if (tokenLength == 0)
                {
                    return false;
                }
                if (destination == null)
                {
                    destination = new ObjectCollection<string>(CacheControlHeaderValue.s_checkIsValidToken);
                }
                destination.Add(value.Substring(i, tokenLength));
                i += tokenLength;
            }
            if (destination != null && destination.Count > num2)
            {
                boolField = true;
                return true;
            }
            return false;
        }

        // Token: 0x06000716 RID: 1814 RVA: 0x000543AC File Offset: 0x000343AC
        private static bool TrySetTimeSpan(NameValueHeaderValue nameValue, ref TimeSpan? timeSpan)
        {
            if (nameValue.Value == null)
            {
                return false;
            }
            int seconds;
            if (!HeaderUtilities.TryParseInt32(nameValue.Value, out seconds))
            {
                return false;
            }
            timeSpan = new TimeSpan?(new TimeSpan(0, 0, seconds));
            return true;
        }

        // Token: 0x06000717 RID: 1815 RVA: 0x000543E8 File Offset: 0x000343E8
        private static void AppendValueIfRequired(StringBuilder sb, bool appendValue, string value)
        {
            if (appendValue)
            {
                CacheControlHeaderValue.AppendValueWithSeparatorIfRequired(sb, value);
            }
        }

        // Token: 0x06000718 RID: 1816 RVA: 0x000543F4 File Offset: 0x000343F4
        private static void AppendValueWithSeparatorIfRequired(StringBuilder sb, string value)
        {
            if (sb.Length > 0)
            {
                sb.Append(", ");
            }
            sb.Append(value);
        }

        // Token: 0x06000719 RID: 1817 RVA: 0x00054414 File Offset: 0x00034414
        private static void AppendValues(StringBuilder sb, ObjectCollection<string> values)
        {
            bool flag = true;
            foreach (string value in values)
            {
                if (flag)
                {
                    flag = false;
                }
                else
                {
                    sb.Append(", ");
                }
                sb.Append(value);
            }
        }

        // Token: 0x0600071A RID: 1818 RVA: 0x00054478 File Offset: 0x00034478
        private static void CheckIsValidToken(string item)
        {
            HeaderUtilities.CheckValidToken(item, "item");
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.CacheControlHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x0600071B RID: 1819 RVA: 0x00054485 File Offset: 0x00034485
        object ICloneable.Clone()
        {
            return new CacheControlHeaderValue(this);
        }

        // Token: 0x0400056E RID: 1390
        private static readonly HttpHeaderParser s_nameValueListParser = GenericHeaderParser.MultipleValueNameValueParser;

        // Token: 0x0400056F RID: 1391
        private static readonly Action<string> s_checkIsValidToken = new Action<string>(CacheControlHeaderValue.CheckIsValidToken);

        // Token: 0x04000570 RID: 1392
        private bool _noCache;

        // Token: 0x04000571 RID: 1393
        private ObjectCollection<string> _noCacheHeaders;

        // Token: 0x04000572 RID: 1394
        private bool _noStore;

        // Token: 0x04000573 RID: 1395
        private TimeSpan? _maxAge;

        // Token: 0x04000574 RID: 1396
        private TimeSpan? _sharedMaxAge;

        // Token: 0x04000575 RID: 1397
        private bool _maxStale;

        // Token: 0x04000576 RID: 1398
        private TimeSpan? _maxStaleLimit;

        // Token: 0x04000577 RID: 1399
        private TimeSpan? _minFresh;

        // Token: 0x04000578 RID: 1400
        private bool _noTransform;

        // Token: 0x04000579 RID: 1401
        private bool _onlyIfCached;

        // Token: 0x0400057A RID: 1402
        private bool _publicField;

        // Token: 0x0400057B RID: 1403
        private bool _privateField;

        // Token: 0x0400057C RID: 1404
        private ObjectCollection<string> _privateHeaders;

        // Token: 0x0400057D RID: 1405
        private bool _mustRevalidate;

        // Token: 0x0400057E RID: 1406
        private bool _proxyRevalidate;

        // Token: 0x0400057F RID: 1407
        private ObjectCollection<NameValueHeaderValue> _extensions;
    }


    /// <summary>
    ///         Content-Disposition ヘッダーの値を表します。
    ///       </summary>
    // Token: 0x02000123 RID: 291
    class ContentDispositionHeaderValue : ICloneable
    {
        /// <summary>
        ///         コンテンツのボディ部の配置タイプです。
        ///       </summary>
        /// <returns>
        ///         配置タイプ。
        ///       </returns>
        // Token: 0x1700015E RID: 350
        // (get) Token: 0x0600071D RID: 1821 RVA: 0x000544AA File Offset: 0x000344AA
        // (set) Token: 0x0600071E RID: 1822 RVA: 0x000544B2 File Offset: 0x000344B2
        public string DispositionType
        {
            get
            {
                return this._dispositionType;
            }
            set
            {
                ContentDispositionHeaderValue.CheckDispositionTypeFormat(value, "value");
                this._dispositionType = value;
            }
        }

        /// <summary>
        ///         パラメーターのセットには、Content-Disposition ヘッダーが含まれています。
        ///       </summary>
        /// <returns>
        ///         パラメーターのコレクション。
        ///       </returns>
        // Token: 0x1700015F RID: 351
        // (get) Token: 0x0600071F RID: 1823 RVA: 0x000544C6 File Offset: 0x000344C6
        public ICollection<NameValueHeaderValue> Parameters
        {
            get
            {
                if (this._parameters == null)
                {
                    this._parameters = new ObjectCollection<NameValueHeaderValue>();
                }
                return this._parameters;
            }
        }

        /// <summary>
        ///         コンテンツのボディ部の名前です。
        ///       </summary>
        /// <returns>
        ///         コンテンツのボディ部の名前。
        ///       </returns>
        // Token: 0x17000160 RID: 352
        // (get) Token: 0x06000720 RID: 1824 RVA: 0x000544E1 File Offset: 0x000344E1
        // (set) Token: 0x06000721 RID: 1825 RVA: 0x000544EE File Offset: 0x000344EE
        public string Name
        {
            get
            {
                return this.GetName("name");
            }
            set
            {
                this.SetName("name", value);
            }
        }

        /// <summary>
        ///         メッセージ ペイロード (エンティティがデタッチされ別のファイルに格納されている場合に使用する) を格納するためのファイル名を作成する方法に関する提案。
        ///       </summary>
        /// <returns>
        ///         推奨ファイル名。
        ///       </returns>
        // Token: 0x17000161 RID: 353
        // (get) Token: 0x06000722 RID: 1826 RVA: 0x000544FC File Offset: 0x000344FC
        // (set) Token: 0x06000723 RID: 1827 RVA: 0x00054509 File Offset: 0x00034509
        public string FileName
        {
            get
            {
                return this.GetName("filename");
            }
            set
            {
                this.SetName("filename", value);
            }
        }

        /// <summary>
        ///         メッセージ ペイロード (エンティティがデタッチされ別のファイルに格納されている場合に使用する) を格納するためのファイル名を作成する方法に関する提案。
        ///       </summary>
        /// <returns>
        ///         推奨ファイル名は filename* 形式。
        ///       </returns>
        // Token: 0x17000162 RID: 354
        // (get) Token: 0x06000724 RID: 1828 RVA: 0x00054517 File Offset: 0x00034517
        // (set) Token: 0x06000725 RID: 1829 RVA: 0x00054524 File Offset: 0x00034524
        public string FileNameStar
        {
            get
            {
                return this.GetName("filename*");
            }
            set
            {
                this.SetName("filename*", value);
            }
        }

        /// <summary>
        ///         ファイルが作成された日付。
        ///       </summary>
        /// <returns>
        ///         ファイルの作成日。
        ///       </returns>
        // Token: 0x17000163 RID: 355
        // (get) Token: 0x06000726 RID: 1830 RVA: 0x00054532 File Offset: 0x00034532
        // (set) Token: 0x06000727 RID: 1831 RVA: 0x0005453F File Offset: 0x0003453F
        public DateTimeOffset? CreationDate
        {
            get
            {
                return this.GetDate("creation-date");
            }
            set
            {
                this.SetDate("creation-date", value);
            }
        }

        /// <summary>
        ///         ファイルの最終更新日。
        ///       </summary>
        /// <returns>
        ///         ファイルの変更日。
        ///       </returns>
        // Token: 0x17000164 RID: 356
        // (get) Token: 0x06000728 RID: 1832 RVA: 0x0005454D File Offset: 0x0003454D
        // (set) Token: 0x06000729 RID: 1833 RVA: 0x0005455A File Offset: 0x0003455A
        public DateTimeOffset? ModificationDate
        {
            get
            {
                return this.GetDate("modification-date");
            }
            set
            {
                this.SetDate("modification-date", value);
            }
        }

        /// <summary>
        ///         ファイルが最後に読み取られた日付。
        ///       </summary>
        /// <returns>
        ///         最後の読み取り日。
        ///       </returns>
        // Token: 0x17000165 RID: 357
        // (get) Token: 0x0600072A RID: 1834 RVA: 0x00054568 File Offset: 0x00034568
        // (set) Token: 0x0600072B RID: 1835 RVA: 0x00054575 File Offset: 0x00034575
        public DateTimeOffset? ReadDate
        {
            get
            {
                return this.GetDate("read-date");
            }
            set
            {
                this.SetDate("read-date", value);
            }
        }

        /// <summary>
        ///         ファイルのおおよそのサイズ (バイト単位)。
        ///       </summary>
        /// <returns>
        ///         おおよそのサイズ (バイト単位)。
        ///       </returns>
        // Token: 0x17000166 RID: 358
        // (get) Token: 0x0600072C RID: 1836 RVA: 0x00054584 File Offset: 0x00034584
        // (set) Token: 0x0600072D RID: 1837 RVA: 0x000545CC File Offset: 0x000345CC
        public long? Size
        {
            get
            {
                NameValueHeaderValue nameValueHeaderValue = NameValueHeaderValue.Find(this._parameters, "size");
                if (nameValueHeaderValue != null)
                {
                    string value = nameValueHeaderValue.Value;
                    ulong value2;
                    if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out value2))
                    {
                        return new long?((long)value2);
                    }
                }
                return null;
            }
            set
            {
                NameValueHeaderValue nameValueHeaderValue = NameValueHeaderValue.Find(this._parameters, "size");
                if (value == null)
                {
                    if (nameValueHeaderValue != null)
                    {
                        this._parameters.Remove(nameValueHeaderValue);
                        return;
                    }
                }
                else
                {
                    if (value < 0L)
                    {
                        throw new ArgumentOutOfRangeException("value");
                    }
                    if (nameValueHeaderValue != null)
                    {
                        nameValueHeaderValue.Value = value.Value.ToString(CultureInfo.InvariantCulture);
                        return;
                    }
                    string value2 = value.Value.ToString(CultureInfo.InvariantCulture);
                    this.Parameters.Add(new NameValueHeaderValue("size", value2));
                }
            }
        }

        // Token: 0x0600072E RID: 1838 RVA: 0x00035094 File Offset: 0x00015094
        internal ContentDispositionHeaderValue()
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="source">
        ///           <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" />
        ///         </param>
        // Token: 0x0600072F RID: 1839 RVA: 0x00054674 File Offset: 0x00034674
        protected ContentDispositionHeaderValue(ContentDispositionHeaderValue source)
        {
            this._dispositionType = source._dispositionType;
            if (source._parameters != null)
            {
                foreach (NameValueHeaderValue nameValueHeaderValue in source._parameters)
                {
                    this.Parameters.Add((NameValueHeaderValue)((ICloneable)nameValueHeaderValue).Clone());
                }
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="dispositionType">
        ///           含む文字列、 <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" />です。
        ///         </param>
        // Token: 0x06000730 RID: 1840 RVA: 0x000546F0 File Offset: 0x000346F0
        public ContentDispositionHeaderValue(string dispositionType)
        {
            ContentDispositionHeaderValue.CheckDispositionTypeFormat(dispositionType, "dispositionType");
            this._dispositionType = dispositionType;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x06000731 RID: 1841 RVA: 0x0005470C File Offset: 0x0003470C
        public override string ToString()
        {
            StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
            stringBuilder.Append(this._dispositionType);
            NameValueHeaderValue.ToString(this._parameters, ';', true, stringBuilder);
            return StringBuilderCache.GetStringAndRelease(stringBuilder);
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000732 RID: 1842 RVA: 0x00054744 File Offset: 0x00034744
        public override bool Equals(object obj)
        {
            ContentDispositionHeaderValue contentDispositionHeaderValue = obj as ContentDispositionHeaderValue;
            return contentDispositionHeaderValue != null && string.Equals(this._dispositionType, contentDispositionHeaderValue._dispositionType, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections<NameValueHeaderValue>(this._parameters, contentDispositionHeaderValue._parameters);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x06000733 RID: 1843 RVA: 0x00054784 File Offset: 0x00034784
        public override int GetHashCode()
        {
            return StringComparer.OrdinalIgnoreCase.GetHashCode(this._dispositionType) ^ NameValueHeaderValue.GetHashCode(this._parameters);
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x06000734 RID: 1844 RVA: 0x000547A2 File Offset: 0x000347A2
        object ICloneable.Clone()
        {
            return new ContentDispositionHeaderValue(this);
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           コンテンツの破棄ヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" /> インスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は有効なコンテンツの破棄ヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x06000735 RID: 1845 RVA: 0x000547AC File Offset: 0x000347AC
        public static ContentDispositionHeaderValue Parse(string input)
        {
            int num = 0;
            return (ContentDispositionHeaderValue)GenericHeaderParser.ContentDispositionParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.ContentDispositionHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000736 RID: 1846 RVA: 0x000547D0 File Offset: 0x000347D0
        public static bool TryParse(string input, out ContentDispositionHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.ContentDispositionParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (ContentDispositionHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x06000737 RID: 1847 RVA: 0x00054800 File Offset: 0x00034800
        internal static int GetDispositionTypeLength(string input, int startIndex, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            string dispositionType = null;
            int dispositionTypeExpressionLength = ContentDispositionHeaderValue.GetDispositionTypeExpressionLength(input, startIndex, out dispositionType);
            if (dispositionTypeExpressionLength == 0)
            {
                return 0;
            }
            int num = startIndex + dispositionTypeExpressionLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            ContentDispositionHeaderValue contentDispositionHeaderValue = new ContentDispositionHeaderValue();
            contentDispositionHeaderValue._dispositionType = dispositionType;
            if (num >= input.Length || input[num] != ';')
            {
                parsedValue = contentDispositionHeaderValue;
                return num - startIndex;
            }
            num++;
            int nameValueListLength = NameValueHeaderValue.GetNameValueListLength(input, num, ';', (ObjectCollection<NameValueHeaderValue>)contentDispositionHeaderValue.Parameters);
            if (nameValueListLength == 0)
            {
                return 0;
            }
            parsedValue = contentDispositionHeaderValue;
            return num + nameValueListLength - startIndex;
        }

        // Token: 0x06000738 RID: 1848 RVA: 0x00054894 File Offset: 0x00034894
        private static int GetDispositionTypeExpressionLength(string input, int startIndex, out string dispositionType)
        {
            dispositionType = null;
            int tokenLength = HttpRuleParser.GetTokenLength(input, startIndex);
            if (tokenLength == 0)
            {
                return 0;
            }
            dispositionType = input.Substring(startIndex, tokenLength);
            return tokenLength;
        }

        // Token: 0x06000739 RID: 1849 RVA: 0x000548BC File Offset: 0x000348BC
        private static void CheckDispositionTypeFormat(string dispositionType, string parameterName)
        {
            if (string.IsNullOrEmpty(dispositionType))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, parameterName);
            }
            string text;
            int dispositionTypeExpressionLength = ContentDispositionHeaderValue.GetDispositionTypeExpressionLength(dispositionType, 0, out text);
            if (dispositionTypeExpressionLength == 0 || text.Length != dispositionType.Length)
            {
                throw new FormatException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, dispositionType));
            }
        }

        // Token: 0x0600073A RID: 1850 RVA: 0x00054910 File Offset: 0x00034910
        private DateTimeOffset? GetDate(string parameter)
        {
            NameValueHeaderValue nameValueHeaderValue = NameValueHeaderValue.Find(this._parameters, parameter);
            if (nameValueHeaderValue != null)
            {
                string text = nameValueHeaderValue.Value;
                if (this.IsQuoted(text))
                {
                    text = text.Substring(1, text.Length - 2);
                }
                DateTimeOffset value;
                if (HttpRuleParser.TryStringToDate(text, out value))
                {
                    return new DateTimeOffset?(value);
                }
            }
            return null;
        }

        // Token: 0x0600073B RID: 1851 RVA: 0x00054968 File Offset: 0x00034968
        private void SetDate(string parameter, DateTimeOffset? date)
        {
            NameValueHeaderValue nameValueHeaderValue = NameValueHeaderValue.Find(this._parameters, parameter);
            if (date == null)
            {
                if (nameValueHeaderValue != null)
                {
                    this._parameters.Remove(nameValueHeaderValue);
                    return;
                }
            }
            else
            {
                string value = "\"" + HttpRuleParser.DateToString(date.Value) + "\"";
                if (nameValueHeaderValue != null)
                {
                    nameValueHeaderValue.Value = value;
                    return;
                }
                this.Parameters.Add(new NameValueHeaderValue(parameter, value));
            }
        }

        // Token: 0x0600073C RID: 1852 RVA: 0x000549D8 File Offset: 0x000349D8
        private string GetName(string parameter)
        {
            NameValueHeaderValue nameValueHeaderValue = NameValueHeaderValue.Find(this._parameters, parameter);
            if (nameValueHeaderValue == null)
            {
                return null;
            }
            if (parameter.EndsWith("*", StringComparison.Ordinal))
            {
                string result;
                if (this.TryDecode5987(nameValueHeaderValue.Value, out result))
                {
                    return result;
                }
                return null;
            }
            else
            {
                string result;
                if (this.TryDecodeMime(nameValueHeaderValue.Value, out result))
                {
                    return result;
                }
                return nameValueHeaderValue.Value;
            }
        }

        // Token: 0x0600073D RID: 1853 RVA: 0x00054A34 File Offset: 0x00034A34
        private void SetName(string parameter, string value)
        {
            NameValueHeaderValue nameValueHeaderValue = NameValueHeaderValue.Find(this._parameters, parameter);
            if (string.IsNullOrEmpty(value))
            {
                if (nameValueHeaderValue != null)
                {
                    this._parameters.Remove(nameValueHeaderValue);
                    return;
                }
            }
            else
            {
                string value2 = string.Empty;
                if (parameter.EndsWith("*", StringComparison.Ordinal))
                {
                    value2 = HeaderUtilities.Encode5987(value);
                }
                else
                {
                    value2 = this.EncodeAndQuoteMime(value);
                }
                if (nameValueHeaderValue != null)
                {
                    nameValueHeaderValue.Value = value2;
                    return;
                }
                this.Parameters.Add(new NameValueHeaderValue(parameter, value2));
            }
        }

        // Token: 0x0600073E RID: 1854 RVA: 0x00054AAC File Offset: 0x00034AAC
        private string EncodeAndQuoteMime(string input)
        {
            string text = input;
            bool flag = false;
            if (this.IsQuoted(text))
            {
                text = text.Substring(1, text.Length - 2);
                flag = true;
            }
            if (text.IndexOf("\"", 0, StringComparison.Ordinal) >= 0)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, input));
            }
            if (this.RequiresEncoding(text))
            {
                flag = true;
                text = this.EncodeMime(text);
            }
            else if (!flag && HttpRuleParser.GetTokenLength(text, 0) != text.Length)
            {
                flag = true;
            }
            if (flag)
            {
                text = "\"" + text + "\"";
            }
            return text;
        }

        // Token: 0x0600073F RID: 1855 RVA: 0x00054B3C File Offset: 0x00034B3C
        private bool IsQuoted(string value)
        {
            return value.Length > 1 && value.StartsWith("\"", StringComparison.Ordinal) && value.EndsWith("\"", StringComparison.Ordinal);
        }

        // Token: 0x06000740 RID: 1856 RVA: 0x00054B64 File Offset: 0x00034B64
        private bool RequiresEncoding(string input)
        {
            foreach (char c in input)
            {
                if (c > '\u007f')
                {
                    return true;
                }
            }
            return false;
        }

        // Token: 0x06000741 RID: 1857 RVA: 0x00054B94 File Offset: 0x00034B94
        private string EncodeMime(string input)
        {
            byte[] bytes = Encoding.UTF8.GetBytes(input);
            string str = Convert.ToBase64String(bytes);
            return "=?utf-8?B?" + str + "?=";
        }

        // Token: 0x06000742 RID: 1858 RVA: 0x00054BC4 File Offset: 0x00034BC4
        private bool TryDecodeMime(string input, out string output)
        {
            output = null;
            if (!this.IsQuoted(input) || input.Length < 10)
            {
                return false;
            }
            string[] array = input.Split('?', StringSplitOptions.None);
            if (array.Length != 5 || array[0] != "\"=" || array[4] != "=\"" || array[2].ToLowerInvariant() != "b")
            {
                return false;
            }
            try
            {
                Encoding encoding = Encoding.GetEncoding(array[1]);
                byte[] array2 = Convert.FromBase64String(array[3]);
                output = encoding.GetString(array2, 0, array2.Length);
                return true;
            }
            catch (ArgumentException)
            {
            }
            catch (FormatException)
            {
            }
            return false;
        }

        // Token: 0x06000743 RID: 1859 RVA: 0x00054C7C File Offset: 0x00034C7C
        private bool TryDecode5987(string input, out string output)
        {
            output = null;
            int num = input.IndexOf('\'');
            if (num == -1)
            {
                return false;
            }
            int num2 = input.LastIndexOf('\'');
            if (num == num2 || input.IndexOf('\'', num + 1) != num2)
            {
                return false;
            }
            string name = input.Substring(0, num);
            string text = input.Substring(num2 + 1, input.Length - (num2 + 1));
            StringBuilder stringBuilder = new StringBuilder();
            try
            {
                Encoding encoding = Encoding.GetEncoding(name);
                byte[] array = new byte[text.Length];
                int num3 = 0;
                for (int i = 0; i < text.Length; i++)
                {
                    if (Uri.IsHexEncoding(text, i))
                    {
                        array[num3++] = (byte)Uri.HexUnescape(text, ref i);
                        i--;
                    }
                    else
                    {
                        if (num3 > 0)
                        {
                            stringBuilder.Append(encoding.GetString(array, 0, num3));
                            num3 = 0;
                        }
                        stringBuilder.Append(text[i]);
                    }
                }
                if (num3 > 0)
                {
                    stringBuilder.Append(encoding.GetString(array, 0, num3));
                }
            }
            catch (ArgumentException)
            {
                return false;
            }
            output = stringBuilder.ToString();
            return true;
        }

        // Token: 0x04000580 RID: 1408
        private ObjectCollection<NameValueHeaderValue> _parameters;

        // Token: 0x04000581 RID: 1409
        private string _dispositionType;
    }


    /// <summary>
    ///         Content-Range ヘッダーの値を表します。
    ///       </summary>
    // Token: 0x02000124 RID: 292
    class ContentRangeHeaderValue : ICloneable
    {
        /// <summary>
        ///         使用されている範囲単位。
        ///       </summary>
        /// <returns>
        ///         範囲単位を格納している <see cref="T:System.String" />。
        ///       </returns>
        // Token: 0x17000167 RID: 359
        // (get) Token: 0x06000744 RID: 1860 RVA: 0x00054D98 File Offset: 0x00034D98
        // (set) Token: 0x06000745 RID: 1861 RVA: 0x00054DA0 File Offset: 0x00034DA0
        public string Unit
        {
            get
            {
                return this._unit;
            }
            set
            {
                HeaderUtilities.CheckValidToken(value, "value");
                this._unit = value;
            }
        }

        /// <summary>
        ///         データの送信を開始する位置を取得します。
        ///       </summary>
        /// <returns>
        ///         データの送信を開始する位置 (バイト単位)。
        ///       </returns>
        // Token: 0x17000168 RID: 360
        // (get) Token: 0x06000746 RID: 1862 RVA: 0x00054DB4 File Offset: 0x00034DB4
        public long? From
        {
            get
            {
                return this._from;
            }
        }

        /// <summary>
        ///         データの送信を終了する位置を取得します。
        ///       </summary>
        /// <returns>
        ///         データの送信を終了する位置。
        ///       </returns>
        // Token: 0x17000169 RID: 361
        // (get) Token: 0x06000747 RID: 1863 RVA: 0x00054DBC File Offset: 0x00034DBC
        public long? To
        {
            get
            {
                return this._to;
            }
        }

        /// <summary>
        ///         エンティティ ボディ全体の長さを取得します。
        ///       </summary>
        /// <returns>
        ///         エンティティ ボディ全体の長さ。
        ///       </returns>
        // Token: 0x1700016A RID: 362
        // (get) Token: 0x06000748 RID: 1864 RVA: 0x00054DC4 File Offset: 0x00034DC4
        public long? Length
        {
            get
            {
                return this._length;
            }
        }

        /// <summary>
        ///         Content-Range ヘッダーが指定された長さであるかどうかを取得します。
        ///       </summary>
        /// <returns>
        ///         Content-Range が指定された長さである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x1700016B RID: 363
        // (get) Token: 0x06000749 RID: 1865 RVA: 0x00054DCC File Offset: 0x00034DCC
        public bool HasLength
        {
            get
            {
                return this._length != null;
            }
        }

        /// <summary>
        ///         Content-Range が指定された範囲であるかどうかを取得します。
        ///       </summary>
        /// <returns>
        ///         Content-Range が指定された範囲である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x1700016C RID: 364
        // (get) Token: 0x0600074A RID: 1866 RVA: 0x00054DD9 File Offset: 0x00034DD9
        public bool HasRange
        {
            get
            {
                return this._from != null;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="from">
        ///           データの送信を開始する位置のバイト位置。
        ///         </param>
        /// <param name="to">
        ///           データの送信を停止する位置のバイト位置。
        ///         </param>
        /// <param name="length">
        ///           先頭または (バイト単位) の範囲の終了点。
        ///         </param>
        // Token: 0x0600074B RID: 1867 RVA: 0x00054DE8 File Offset: 0x00034DE8
        public ContentRangeHeaderValue(long from, long to, long length)
        {
            if (length < 0L)
            {
                throw new ArgumentOutOfRangeException("length");
            }
            if (to < 0L || to > length)
            {
                throw new ArgumentOutOfRangeException("to");
            }
            if (from < 0L || from > to)
            {
                throw new ArgumentOutOfRangeException("from");
            }
            this._from = new long?(from);
            this._to = new long?(to);
            this._length = new long?(length);
            this._unit = "bytes";
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="length">
        ///           先頭または (バイト単位) の範囲の終了点。
        ///         </param>
        // Token: 0x0600074C RID: 1868 RVA: 0x00054E62 File Offset: 0x00034E62
        public ContentRangeHeaderValue(long length)
        {
            if (length < 0L)
            {
                throw new ArgumentOutOfRangeException("length");
            }
            this._length = new long?(length);
            this._unit = "bytes";
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="from">
        ///           データの送信を開始する位置のバイト位置。
        ///         </param>
        /// <param name="to">
        ///           データの送信を停止する位置のバイト位置。
        ///         </param>
        // Token: 0x0600074D RID: 1869 RVA: 0x00054E94 File Offset: 0x00034E94
        public ContentRangeHeaderValue(long from, long to)
        {
            if (to < 0L)
            {
                throw new ArgumentOutOfRangeException("to");
            }
            if (from < 0L || from > to)
            {
                throw new ArgumentOutOfRangeException("from");
            }
            this._from = new long?(from);
            this._to = new long?(to);
            this._unit = "bytes";
        }

        // Token: 0x0600074E RID: 1870 RVA: 0x00035094 File Offset: 0x00015094
        private ContentRangeHeaderValue()
        {
        }

        // Token: 0x0600074F RID: 1871 RVA: 0x00054EEE File Offset: 0x00034EEE
        private ContentRangeHeaderValue(ContentRangeHeaderValue source)
        {
            this._from = source._from;
            this._to = source._to;
            this._length = source._length;
            this._unit = source._unit;
        }

        /// <summary>
        ///         指定したオブジェクトが、現在の <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000750 RID: 1872 RVA: 0x00054F28 File Offset: 0x00034F28
        public override bool Equals(object obj)
        {
            ContentRangeHeaderValue contentRangeHeaderValue = obj as ContentRangeHeaderValue;
            return contentRangeHeaderValue != null && (this._from == contentRangeHeaderValue._from && this._to == contentRangeHeaderValue._to && this._length == contentRangeHeaderValue._length) && string.Equals(this._unit, contentRangeHeaderValue._unit, StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x06000751 RID: 1873 RVA: 0x00054FF0 File Offset: 0x00034FF0
        public override int GetHashCode()
        {
            int num = StringComparer.OrdinalIgnoreCase.GetHashCode(this._unit);
            if (this.HasRange)
            {
                num = (num ^ this._from.GetHashCode() ^ this._to.GetHashCode());
            }
            if (this.HasLength)
            {
                num ^= this._length.GetHashCode();
            }
            return num;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x06000752 RID: 1874 RVA: 0x0005505C File Offset: 0x0003505C
        public override string ToString()
        {
            StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
            stringBuilder.Append(this._unit);
            stringBuilder.Append(' ');
            if (this.HasRange)
            {
                stringBuilder.Append(this._from.Value.ToString(NumberFormatInfo.InvariantInfo));
                stringBuilder.Append('-');
                stringBuilder.Append(this._to.Value.ToString(NumberFormatInfo.InvariantInfo));
            }
            else
            {
                stringBuilder.Append('*');
            }
            stringBuilder.Append('/');
            if (this.HasLength)
            {
                stringBuilder.Append(this._length.Value.ToString(NumberFormatInfo.InvariantInfo));
            }
            else
            {
                stringBuilder.Append('*');
            }
            return StringBuilderCache.GetStringAndRelease(stringBuilder);
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           コンテンツ範囲のヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> インスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は有効なコンテンツ範囲のヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x06000753 RID: 1875 RVA: 0x00055124 File Offset: 0x00035124
        public static ContentRangeHeaderValue Parse(string input)
        {
            int num = 0;
            return (ContentRangeHeaderValue)GenericHeaderParser.ContentRangeParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000754 RID: 1876 RVA: 0x00055148 File Offset: 0x00035148
        public static bool TryParse(string input, out ContentRangeHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.ContentRangeParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (ContentRangeHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x06000755 RID: 1877 RVA: 0x00055178 File Offset: 0x00035178
        internal static int GetContentRangeLength(string input, int startIndex, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            int tokenLength = HttpRuleParser.GetTokenLength(input, startIndex);
            if (tokenLength == 0)
            {
                return 0;
            }
            string unit = input.Substring(startIndex, tokenLength);
            int num = startIndex + tokenLength;
            int whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, num);
            if (whitespaceLength == 0)
            {
                return 0;
            }
            num += whitespaceLength;
            if (num == input.Length)
            {
                return 0;
            }
            int fromStartIndex = num;
            int fromLength = 0;
            int toStartIndex = 0;
            int toLength = 0;
            if (!ContentRangeHeaderValue.TryGetRangeLength(input, ref num, out fromLength, out toStartIndex, out toLength))
            {
                return 0;
            }
            if (num == input.Length || input[num] != '/')
            {
                return 0;
            }
            num++;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            if (num == input.Length)
            {
                return 0;
            }
            int lengthStartIndex = num;
            int lengthLength = 0;
            if (!ContentRangeHeaderValue.TryGetLengthLength(input, ref num, out lengthLength))
            {
                return 0;
            }
            if (!ContentRangeHeaderValue.TryCreateContentRange(input, unit, fromStartIndex, fromLength, toStartIndex, toLength, lengthStartIndex, lengthLength, out parsedValue))
            {
                return 0;
            }
            return num - startIndex;
        }

        // Token: 0x06000756 RID: 1878 RVA: 0x00055250 File Offset: 0x00035250
        private static bool TryGetLengthLength(string input, ref int current, out int lengthLength)
        {
            lengthLength = 0;
            if (input[current] == '*')
            {
                current++;
            }
            else
            {
                lengthLength = HttpRuleParser.GetNumberLength(input, current, false);
                if (lengthLength == 0 || lengthLength > 19)
                {
                    return false;
                }
                current += lengthLength;
            }
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            return true;
        }

        // Token: 0x06000757 RID: 1879 RVA: 0x000552A0 File Offset: 0x000352A0
        private static bool TryGetRangeLength(string input, ref int current, out int fromLength, out int toStartIndex, out int toLength)
        {
            fromLength = 0;
            toStartIndex = 0;
            toLength = 0;
            if (input[current] == '*')
            {
                current++;
            }
            else
            {
                fromLength = HttpRuleParser.GetNumberLength(input, current, false);
                if (fromLength == 0 || fromLength > 19)
                {
                    return false;
                }
                current += fromLength;
                current += HttpRuleParser.GetWhitespaceLength(input, current);
                if (current == input.Length || input[current] != '-')
                {
                    return false;
                }
                current++;
                current += HttpRuleParser.GetWhitespaceLength(input, current);
                if (current == input.Length)
                {
                    return false;
                }
                toStartIndex = current;
                toLength = HttpRuleParser.GetNumberLength(input, current, false);
                if (toLength == 0 || toLength > 19)
                {
                    return false;
                }
                current += toLength;
            }
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            return true;
        }

        // Token: 0x06000758 RID: 1880 RVA: 0x00055364 File Offset: 0x00035364
        private static bool TryCreateContentRange(string input, string unit, int fromStartIndex, int fromLength, int toStartIndex, int toLength, int lengthStartIndex, int lengthLength, out object parsedValue)
        {
            parsedValue = null;
            long num = 0L;
            if (fromLength > 0 && !HeaderUtilities.TryParseInt64(input, fromStartIndex, fromLength, out num))
            {
                return false;
            }
            long num2 = 0L;
            if (toLength > 0 && !HeaderUtilities.TryParseInt64(input, toStartIndex, toLength, out num2))
            {
                return false;
            }
            if (fromLength > 0 && toLength > 0 && num > num2)
            {
                return false;
            }
            long num3 = 0L;
            if (lengthLength > 0 && !HeaderUtilities.TryParseInt64(input, lengthStartIndex, lengthLength, out num3))
            {
                return false;
            }
            if (toLength > 0 && lengthLength > 0 && num2 >= num3)
            {
                return false;
            }
            ContentRangeHeaderValue contentRangeHeaderValue = new ContentRangeHeaderValue();
            contentRangeHeaderValue._unit = unit;
            if (fromLength > 0)
            {
                contentRangeHeaderValue._from = new long?(num);
                contentRangeHeaderValue._to = new long?(num2);
            }
            if (lengthLength > 0)
            {
                contentRangeHeaderValue._length = new long?(num3);
            }
            parsedValue = contentRangeHeaderValue;
            return true;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.ContentRangeHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x06000759 RID: 1881 RVA: 0x00055418 File Offset: 0x00035418
        object ICloneable.Clone()
        {
            return new ContentRangeHeaderValue(this);
        }

        // Token: 0x04000582 RID: 1410
        private string _unit;

        // Token: 0x04000583 RID: 1411
        private long? _from;

        // Token: 0x04000584 RID: 1412
        private long? _to;

        // Token: 0x04000585 RID: 1413
        private long? _length;
    }


    // Token: 0x02000125 RID: 293
    internal class DateHeaderParser : HttpHeaderParser
    {
        // Token: 0x0600075A RID: 1882 RVA: 0x00053469 File Offset: 0x00033469
        private DateHeaderParser() : base(false)
        {
        }

        // Token: 0x0600075B RID: 1883 RVA: 0x00055420 File Offset: 0x00035420
        public override string ToString(object value)
        {
            return HttpRuleParser.DateToString((DateTimeOffset)value);
        }

        // Token: 0x0600075C RID: 1884 RVA: 0x00055430 File Offset: 0x00035430
        public override bool TryParseValue(string value, object storeValue, ref int index, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(value) || index == value.Length)
            {
                return false;
            }
            string input = value;
            if (index > 0)
            {
                input = value.Substring(index);
            }
            DateTimeOffset dateTimeOffset;
            if (!HttpRuleParser.TryStringToDate(input, out dateTimeOffset))
            {
                return false;
            }
            index = value.Length;
            parsedValue = dateTimeOffset;
            return true;
        }

        // Token: 0x04000586 RID: 1414
        internal static readonly DateHeaderParser Parser = new DateHeaderParser();
    }

    /// <summary>
    ///         entity-tag ヘッダーの値を表します。
    ///       </summary>
    // Token: 0x02000126 RID: 294
    class EntityTagHeaderValue : ICloneable
    {
        /// <summary>
        ///         引用符で囲まれたを不透明な文字列を取得します。
        ///       </summary>
        /// <returns>
        ///         引用符で囲まれたを不透明な文字列。
        ///       </returns>
        // Token: 0x1700016D RID: 365
        // (get) Token: 0x0600075E RID: 1886 RVA: 0x0005548F File Offset: 0x0003548F
        public string Tag
        {
            get
            {
                return this._tag;
            }
        }

        /// <summary>
        ///         エンティティ タグの前に脆弱性インジケーターが付いたかどうかを取得します。
        ///       </summary>
        /// <returns>
        ///         エンティティ タグの前に脆弱性インジケータ―が付いている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x1700016E RID: 366
        // (get) Token: 0x0600075F RID: 1887 RVA: 0x00055497 File Offset: 0x00035497
        public bool IsWeak
        {
            get
            {
                return this._isWeak;
            }
        }

        /// <summary>
        ///         エンティティ タグ ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> を返します。
        ///       </returns>
        // Token: 0x1700016F RID: 367
        // (get) Token: 0x06000760 RID: 1888 RVA: 0x0005549F File Offset: 0x0003549F
        public static EntityTagHeaderValue Any
        {
            get
            {
                if (EntityTagHeaderValue.s_any == null)
                {
                    EntityTagHeaderValue.s_any = new EntityTagHeaderValue();
                    EntityTagHeaderValue.s_any._tag = "*";
                    EntityTagHeaderValue.s_any._isWeak = false;
                }
                return EntityTagHeaderValue.s_any;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="tag">
        ///           含む文字列、 <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" />です。
        ///         </param>
        // Token: 0x06000761 RID: 1889 RVA: 0x000554D1 File Offset: 0x000354D1
        public EntityTagHeaderValue(string tag) : this(tag, false)
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="tag">
        ///           含む文字列、  <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" />です。
        ///         </param>
        /// <param name="isWeak">
        ///           このエンティティ タグ ヘッダーが弱い性検証ツールであるかを示す値。
        ///            弱い検証コントロールは、エンティティ タグ ヘッダー <paramref name="isWeak" /> に設定する必要があります <see langword="true" />します。
        ///            厳密な検証は、エンティティ タグ ヘッダー <paramref name="isWeak" /> に設定する必要があります <see langword="false" />します。
        ///         </param>
        // Token: 0x06000762 RID: 1890 RVA: 0x000554DC File Offset: 0x000354DC
        public EntityTagHeaderValue(string tag, bool isWeak)
        {
            if (string.IsNullOrEmpty(tag))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, "tag");
            }
            int num = 0;
            if (HttpRuleParser.GetQuotedStringLength(tag, 0, out num) != HttpParseResult.Parsed || num != tag.Length)
            {
                throw new FormatException(SR.net_http_headers_invalid_etag_name);
            }
            this._tag = tag;
            this._isWeak = isWeak;
        }

        // Token: 0x06000763 RID: 1891 RVA: 0x00055536 File Offset: 0x00035536
        private EntityTagHeaderValue(EntityTagHeaderValue source)
        {
            this._tag = source._tag;
            this._isWeak = source._isWeak;
        }

        // Token: 0x06000764 RID: 1892 RVA: 0x00035094 File Offset: 0x00015094
        private EntityTagHeaderValue()
        {
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x06000765 RID: 1893 RVA: 0x00055556 File Offset: 0x00035556
        public override string ToString()
        {
            if (this._isWeak)
            {
                return "W/" + this._tag;
            }
            return this._tag;
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000766 RID: 1894 RVA: 0x00055578 File Offset: 0x00035578
        public override bool Equals(object obj)
        {
            EntityTagHeaderValue entityTagHeaderValue = obj as EntityTagHeaderValue;
            return entityTagHeaderValue != null && this._isWeak == entityTagHeaderValue._isWeak && string.Equals(this._tag, entityTagHeaderValue._tag, StringComparison.Ordinal);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x06000767 RID: 1895 RVA: 0x000555B3 File Offset: 0x000355B3
        public override int GetHashCode()
        {
            return this._tag.GetHashCode() ^ this._isWeak.GetHashCode();
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           エンティティ タグのヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> インスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は有効なエンティティ タグ ヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x06000768 RID: 1896 RVA: 0x000555CC File Offset: 0x000355CC
        public static EntityTagHeaderValue Parse(string input)
        {
            int num = 0;
            return (EntityTagHeaderValue)GenericHeaderParser.SingleValueEntityTagParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000769 RID: 1897 RVA: 0x000555F0 File Offset: 0x000355F0
        public static bool TryParse(string input, out EntityTagHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.SingleValueEntityTagParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (EntityTagHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x0600076A RID: 1898 RVA: 0x00055620 File Offset: 0x00035620
        internal static int GetEntityTagLength(string input, int startIndex, out EntityTagHeaderValue parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            bool isWeak = false;
            int num = startIndex;
            char c = input[startIndex];
            if (c == '*')
            {
                parsedValue = EntityTagHeaderValue.Any;
                num++;
            }
            else
            {
                if (c == 'W' || c == 'w')
                {
                    num++;
                    if (num + 2 >= input.Length || input[num] != '/')
                    {
                        return 0;
                    }
                    isWeak = true;
                    num++;
                    num += HttpRuleParser.GetWhitespaceLength(input, num);
                }
                int startIndex2 = num;
                int num2 = 0;
                if (HttpRuleParser.GetQuotedStringLength(input, num, out num2) != HttpParseResult.Parsed)
                {
                    return 0;
                }
                parsedValue = new EntityTagHeaderValue();
                if (num2 == input.Length)
                {
                    parsedValue._tag = input;
                    parsedValue._isWeak = false;
                }
                else
                {
                    parsedValue._tag = input.Substring(startIndex2, num2);
                    parsedValue._isWeak = isWeak;
                }
                num += num2;
            }
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            return num - startIndex;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x0600076B RID: 1899 RVA: 0x000556F9 File Offset: 0x000356F9
        object ICloneable.Clone()
        {
            if (this == EntityTagHeaderValue.s_any)
            {
                return EntityTagHeaderValue.s_any;
            }
            return new EntityTagHeaderValue(this);
        }

        // Token: 0x04000587 RID: 1415
        private static EntityTagHeaderValue s_any;

        // Token: 0x04000588 RID: 1416
        private string _tag;

        // Token: 0x04000589 RID: 1417
        private bool _isWeak;
    }


    // Token: 0x02000127 RID: 295
    internal sealed class GenericHeaderParser : BaseHeaderParser
    {
        // Token: 0x17000170 RID: 368
        // (get) Token: 0x0600076C RID: 1900 RVA: 0x0005570F File Offset: 0x0003570F
        public override IEqualityComparer Comparer
        {
            get
            {
                return this._comparer;
            }
        }

        // Token: 0x0600076D RID: 1901 RVA: 0x00055717 File Offset: 0x00035717
        private GenericHeaderParser(bool supportsMultipleValues, GenericHeaderParser.GetParsedValueLengthDelegate getParsedValueLength) : this(supportsMultipleValues, getParsedValueLength, null)
        {
        }

        // Token: 0x0600076E RID: 1902 RVA: 0x00055722 File Offset: 0x00035722
        private GenericHeaderParser(bool supportsMultipleValues, GenericHeaderParser.GetParsedValueLengthDelegate getParsedValueLength, IEqualityComparer comparer) : base(supportsMultipleValues)
        {
            this._getParsedValueLength = getParsedValueLength;
            this._comparer = comparer;
        }

        // Token: 0x0600076F RID: 1903 RVA: 0x00055739 File Offset: 0x00035739
        protected override int GetParsedValueLength(string value, int startIndex, object storeValue, out object parsedValue)
        {
            return this._getParsedValueLength(value, startIndex, out parsedValue);
        }

        // Token: 0x06000770 RID: 1904 RVA: 0x0005574C File Offset: 0x0003574C
        private static int ParseNameValue(string value, int startIndex, out object parsedValue)
        {
            NameValueHeaderValue nameValueHeaderValue = null;
            int nameValueLength = NameValueHeaderValue.GetNameValueLength(value, startIndex, out nameValueHeaderValue);
            parsedValue = nameValueHeaderValue;
            return nameValueLength;
        }

        // Token: 0x06000771 RID: 1905 RVA: 0x0005576C File Offset: 0x0003576C
        private static int ParseProduct(string value, int startIndex, out object parsedValue)
        {
            ProductHeaderValue productHeaderValue = null;
            int productLength = ProductHeaderValue.GetProductLength(value, startIndex, out productHeaderValue);
            parsedValue = productHeaderValue;
            return productLength;
        }

        // Token: 0x06000772 RID: 1906 RVA: 0x0005578C File Offset: 0x0003578C
        private static int ParseSingleEntityTag(string value, int startIndex, out object parsedValue)
        {
            EntityTagHeaderValue entityTagHeaderValue = null;
            parsedValue = null;
            int entityTagLength = EntityTagHeaderValue.GetEntityTagLength(value, startIndex, out entityTagHeaderValue);
            if (entityTagHeaderValue == EntityTagHeaderValue.Any)
            {
                return 0;
            }
            parsedValue = entityTagHeaderValue;
            return entityTagLength;
        }

        // Token: 0x06000773 RID: 1907 RVA: 0x000557B8 File Offset: 0x000357B8
        private static int ParseMultipleEntityTags(string value, int startIndex, out object parsedValue)
        {
            EntityTagHeaderValue entityTagHeaderValue = null;
            int entityTagLength = EntityTagHeaderValue.GetEntityTagLength(value, startIndex, out entityTagHeaderValue);
            parsedValue = entityTagHeaderValue;
            return entityTagLength;
        }

        // Token: 0x06000774 RID: 1908 RVA: 0x000557D8 File Offset: 0x000357D8
        private static int ParseMailAddress(string value, int startIndex, out object parsedValue)
        {
            parsedValue = null;
            if (HttpRuleParser.ContainsInvalidNewLine(value, startIndex))
            {
                return 0;
            }
            string text = value.Substring(startIndex);
            if (!HeaderUtilities.IsValidEmailAddress(text))
            {
                return 0;
            }
            parsedValue = text;
            return text.Length;
        }

        // Token: 0x06000775 RID: 1909 RVA: 0x00055810 File Offset: 0x00035810
        private static int ParseHost(string value, int startIndex, out object parsedValue)
        {
            string text = null;
            int hostLength = HttpRuleParser.GetHostLength(value, startIndex, false, out text);
            parsedValue = text;
            return hostLength;
        }

        // Token: 0x06000776 RID: 1910 RVA: 0x00055830 File Offset: 0x00035830
        private static int ParseTokenList(string value, int startIndex, out object parsedValue)
        {
            int tokenLength = HttpRuleParser.GetTokenLength(value, startIndex);
            parsedValue = value.Substring(startIndex, tokenLength);
            return tokenLength;
        }

        // Token: 0x0400058A RID: 1418
        internal static readonly GenericHeaderParser HostParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(GenericHeaderParser.ParseHost), StringComparer.OrdinalIgnoreCase);

        // Token: 0x0400058B RID: 1419
        internal static readonly GenericHeaderParser TokenListParser = new GenericHeaderParser(true, new GenericHeaderParser.GetParsedValueLengthDelegate(GenericHeaderParser.ParseTokenList), StringComparer.OrdinalIgnoreCase);

        // Token: 0x0400058C RID: 1420
        internal static readonly GenericHeaderParser SingleValueNameValueWithParametersParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(NameValueWithParametersHeaderValue.GetNameValueWithParametersLength));

        // Token: 0x0400058D RID: 1421
        internal static readonly GenericHeaderParser MultipleValueNameValueWithParametersParser = new GenericHeaderParser(true, new GenericHeaderParser.GetParsedValueLengthDelegate(NameValueWithParametersHeaderValue.GetNameValueWithParametersLength));

        // Token: 0x0400058E RID: 1422
        internal static readonly GenericHeaderParser SingleValueNameValueParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(GenericHeaderParser.ParseNameValue));

        // Token: 0x0400058F RID: 1423
        internal static readonly GenericHeaderParser MultipleValueNameValueParser = new GenericHeaderParser(true, new GenericHeaderParser.GetParsedValueLengthDelegate(GenericHeaderParser.ParseNameValue));

        // Token: 0x04000590 RID: 1424
        internal static readonly GenericHeaderParser MailAddressParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(GenericHeaderParser.ParseMailAddress));

        // Token: 0x04000591 RID: 1425
        internal static readonly GenericHeaderParser SingleValueProductParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(GenericHeaderParser.ParseProduct));

        // Token: 0x04000592 RID: 1426
        internal static readonly GenericHeaderParser MultipleValueProductParser = new GenericHeaderParser(true, new GenericHeaderParser.GetParsedValueLengthDelegate(GenericHeaderParser.ParseProduct));

        // Token: 0x04000593 RID: 1427
        internal static readonly GenericHeaderParser RangeConditionParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(RangeConditionHeaderValue.GetRangeConditionLength));

        // Token: 0x04000594 RID: 1428
        internal static readonly GenericHeaderParser SingleValueAuthenticationParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(AuthenticationHeaderValue.GetAuthenticationLength));

        // Token: 0x04000595 RID: 1429
        internal static readonly GenericHeaderParser MultipleValueAuthenticationParser = new GenericHeaderParser(true, new GenericHeaderParser.GetParsedValueLengthDelegate(AuthenticationHeaderValue.GetAuthenticationLength));

        // Token: 0x04000596 RID: 1430
        internal static readonly GenericHeaderParser RangeParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(RangeHeaderValue.GetRangeLength));

        // Token: 0x04000597 RID: 1431
        internal static readonly GenericHeaderParser RetryConditionParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(RetryConditionHeaderValue.GetRetryConditionLength));

        // Token: 0x04000598 RID: 1432
        internal static readonly GenericHeaderParser ContentRangeParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(ContentRangeHeaderValue.GetContentRangeLength));

        // Token: 0x04000599 RID: 1433
        internal static readonly GenericHeaderParser ContentDispositionParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(ContentDispositionHeaderValue.GetDispositionTypeLength));

        // Token: 0x0400059A RID: 1434
        internal static readonly GenericHeaderParser SingleValueStringWithQualityParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(StringWithQualityHeaderValue.GetStringWithQualityLength));

        // Token: 0x0400059B RID: 1435
        internal static readonly GenericHeaderParser MultipleValueStringWithQualityParser = new GenericHeaderParser(true, new GenericHeaderParser.GetParsedValueLengthDelegate(StringWithQualityHeaderValue.GetStringWithQualityLength));

        // Token: 0x0400059C RID: 1436
        internal static readonly GenericHeaderParser SingleValueEntityTagParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(GenericHeaderParser.ParseSingleEntityTag));

        // Token: 0x0400059D RID: 1437
        internal static readonly GenericHeaderParser MultipleValueEntityTagParser = new GenericHeaderParser(true, new GenericHeaderParser.GetParsedValueLengthDelegate(GenericHeaderParser.ParseMultipleEntityTags));

        // Token: 0x0400059E RID: 1438
        internal static readonly GenericHeaderParser SingleValueViaParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(ViaHeaderValue.GetViaLength));

        // Token: 0x0400059F RID: 1439
        internal static readonly GenericHeaderParser MultipleValueViaParser = new GenericHeaderParser(true, new GenericHeaderParser.GetParsedValueLengthDelegate(ViaHeaderValue.GetViaLength));

        // Token: 0x040005A0 RID: 1440
        internal static readonly GenericHeaderParser SingleValueWarningParser = new GenericHeaderParser(false, new GenericHeaderParser.GetParsedValueLengthDelegate(WarningHeaderValue.GetWarningLength));

        // Token: 0x040005A1 RID: 1441
        internal static readonly GenericHeaderParser MultipleValueWarningParser = new GenericHeaderParser(true, new GenericHeaderParser.GetParsedValueLengthDelegate(WarningHeaderValue.GetWarningLength));

        // Token: 0x040005A2 RID: 1442
        private GenericHeaderParser.GetParsedValueLengthDelegate _getParsedValueLength;

        // Token: 0x040005A3 RID: 1443
        private IEqualityComparer _comparer;

        // Token: 0x02000128 RID: 296
        // (Invoke) Token: 0x06000779 RID: 1913
        private delegate int GetParsedValueLengthDelegate(string value, int startIndex, out object parsedValue);
    }


    // Token: 0x02000129 RID: 297
    internal readonly struct HeaderDescriptor : IEquatable<HeaderDescriptor>
    {
        // Token: 0x0600077C RID: 1916 RVA: 0x00055A8F File Offset: 0x00035A8F
        public HeaderDescriptor(KnownHeader knownHeader)
        {
            this._knownHeader = knownHeader;
            this._headerName = knownHeader.Name;
        }

        // Token: 0x0600077D RID: 1917 RVA: 0x00055AA4 File Offset: 0x00035AA4
        private HeaderDescriptor(string headerName)
        {
            this._headerName = headerName;
            this._knownHeader = null;
        }

        // Token: 0x17000171 RID: 369
        // (get) Token: 0x0600077E RID: 1918 RVA: 0x00055AB4 File Offset: 0x00035AB4
        public string Name
        {
            get
            {
                return this._headerName;
            }
        }

        // Token: 0x17000172 RID: 370
        // (get) Token: 0x0600077F RID: 1919 RVA: 0x00055ABC File Offset: 0x00035ABC
        public HttpHeaderParser Parser
        {
            get
            {
                KnownHeader knownHeader = this._knownHeader;
                if (knownHeader == null)
                {
                    return null;
                }
                return knownHeader.Parser;
            }
        }

        // Token: 0x17000173 RID: 371
        // (get) Token: 0x06000780 RID: 1920 RVA: 0x00055ACF File Offset: 0x00035ACF
        public HttpHeaderType HeaderType
        {
            get
            {
                if (this._knownHeader != null)
                {
                    return this._knownHeader.HeaderType;
                }
                return HttpHeaderType.Custom;
            }
        }

        // Token: 0x17000174 RID: 372
        // (get) Token: 0x06000781 RID: 1921 RVA: 0x00055AE7 File Offset: 0x00035AE7
        public KnownHeader KnownHeader
        {
            get
            {
                return this._knownHeader;
            }
        }

        // Token: 0x06000782 RID: 1922 RVA: 0x00055AEF File Offset: 0x00035AEF
        public bool Equals(HeaderDescriptor other)
        {
            if (this._knownHeader != null)
            {
                return this._knownHeader == other._knownHeader;
            }
            return string.Equals(this._headerName, other._headerName, StringComparison.OrdinalIgnoreCase);
        }

        // Token: 0x06000783 RID: 1923 RVA: 0x00055B1A File Offset: 0x00035B1A
        public override int GetHashCode()
        {
            KnownHeader knownHeader = this._knownHeader;
            if (knownHeader == null)
            {
                return StringComparer.OrdinalIgnoreCase.GetHashCode(this._headerName);
            }
            return knownHeader.GetHashCode();
        }

        // Token: 0x06000784 RID: 1924 RVA: 0x00055B3C File Offset: 0x00035B3C
        public override bool Equals(object obj)
        {
            throw new InvalidOperationException();
        }

        // Token: 0x06000785 RID: 1925 RVA: 0x00055B44 File Offset: 0x00035B44
        public static bool TryGet(string headerName, out HeaderDescriptor descriptor)
        {
            KnownHeader knownHeader = KnownHeaders.TryGetKnownHeader(headerName);
            if (knownHeader != null)
            {
                descriptor = new HeaderDescriptor(knownHeader);
                return true;
            }
            if (!HttpRuleParser.IsToken(headerName))
            {
                descriptor = default(HeaderDescriptor);
                return false;
            }
            descriptor = new HeaderDescriptor(headerName);
            return true;
        }

        // Token: 0x06000786 RID: 1926 RVA: 0x00055B88 File Offset: 0x00035B88
        public static bool TryGet(ReadOnlySpan<byte> headerName, out HeaderDescriptor descriptor)
        {
            KnownHeader knownHeader = KnownHeaders.TryGetKnownHeader(headerName);
            if (knownHeader != null)
            {
                descriptor = new HeaderDescriptor(knownHeader);
                return true;
            }
            if (!HttpRuleParser.IsToken(headerName))
            {
                descriptor = default(HeaderDescriptor);
                return false;
            }
            descriptor = new HeaderDescriptor(HttpRuleParser.GetTokenString(headerName));
            return true;
        }

        // Token: 0x06000787 RID: 1927 RVA: 0x00055BD0 File Offset: 0x00035BD0
        public HeaderDescriptor AsCustomHeader()
        {
            return new HeaderDescriptor(this._knownHeader.Name);
        }

        // Token: 0x06000788 RID: 1928 RVA: 0x00055BE4 File Offset: 0x00035BE4
        public string GetHeaderValue(ReadOnlySpan<byte> headerValue)
        {
            if (headerValue.Length == 0)
            {
                return string.Empty;
            }
            if (this._knownHeader != null && this._knownHeader.KnownValues != null)
            {
                string[] knownValues = this._knownHeader.KnownValues;
                for (int i = 0; i < knownValues.Length; i++)
                {
                    if (ByteArrayHelpers.EqualsOrdinalAsciiIgnoreCase(knownValues[i], headerValue))
                    {
                        return knownValues[i];
                    }
                }
            }
            return HttpRuleParser.DefaultHttpEncoding.GetString(headerValue);
        }

        // Token: 0x040005A4 RID: 1444
        private readonly string _headerName;

        // Token: 0x040005A5 RID: 1445
        private readonly KnownHeader _knownHeader;
    }

    // Token: 0x0200012A RID: 298
    internal static class HeaderUtilities
    {
        // Token: 0x06000789 RID: 1929 RVA: 0x00055C4C File Offset: 0x00035C4C
        internal static void SetQuality(ObjectCollection<NameValueHeaderValue> parameters, double? value)
        {
            NameValueHeaderValue nameValueHeaderValue = NameValueHeaderValue.Find(parameters, "q");
            if (value == null)
            {
                if (nameValueHeaderValue != null)
                {
                    parameters.Remove(nameValueHeaderValue);
                }
                return;
            }
            if (value < 0.0 || value > (double)1)
            {
                throw new ArgumentOutOfRangeException("value");
            }
            string value2 = value.Value.ToString("0.0##", NumberFormatInfo.InvariantInfo);
            if (nameValueHeaderValue != null)
            {
                nameValueHeaderValue.Value = value2;
                return;
            }
            parameters.Add(new NameValueHeaderValue("q", value2));
        }

        // Token: 0x0600078A RID: 1930 RVA: 0x00055CFC File Offset: 0x00035CFC
        internal static string Encode5987(string input)
        {
            string result;
            HeaderUtilities.IsInputEncoded5987(input, out result);
            return result;
        }

        // Token: 0x0600078B RID: 1931 RVA: 0x00055D14 File Offset: 0x00035D14
        internal static bool IsInputEncoded5987(string input, out string output)
        {
            bool result = false;
            StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
            stringBuilder.Append("utf-8''");
            foreach (char c in input)
            {
                if (c > '\u007f')
                {
                    byte[] bytes = Encoding.UTF8.GetBytes(c.ToString());
                    foreach (byte c2 in bytes)
                    {
                        HeaderUtilities.AddHexEscaped((char)c2, stringBuilder);
                        result = true;
                    }
                }
                else if (!HttpRuleParser.IsTokenChar(c) || c == '*' || c == '\'' || c == '%')
                {
                    HeaderUtilities.AddHexEscaped(c, stringBuilder);
                    result = true;
                }
                else
                {
                    stringBuilder.Append(c);
                }
            }
            output = StringBuilderCache.GetStringAndRelease(stringBuilder);
            return result;
        }

        // Token: 0x0600078C RID: 1932 RVA: 0x00055DD5 File Offset: 0x00035DD5
        private static void AddHexEscaped(char c, StringBuilder destination)
        {
            destination.Append('%');
            destination.Append(HeaderUtilities.s_hexUpperChars[(int)((c & 'ð') >> 4)]);
            destination.Append(HeaderUtilities.s_hexUpperChars[(int)(c & '\u000f')]);
        }

        // Token: 0x0600078D RID: 1933 RVA: 0x00055E08 File Offset: 0x00035E08
        internal static double? GetQuality(ObjectCollection<NameValueHeaderValue> parameters)
        {
            NameValueHeaderValue nameValueHeaderValue = NameValueHeaderValue.Find(parameters, "q");
            if (nameValueHeaderValue != null)
            {
                double value = 0.0;
                if (double.TryParse(nameValueHeaderValue.Value, NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out value))
                {
                    return new double?(value);
                }
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(null, SR.Format(SR.net_http_log_headers_invalid_quality, nameValueHeaderValue.Value), "GetQuality");
                }
            }
            return null;
        }

        // Token: 0x0600078E RID: 1934 RVA: 0x00055E76 File Offset: 0x00035E76
        internal static void CheckValidToken(string value, string parameterName)
        {
            if (string.IsNullOrEmpty(value))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, parameterName);
            }
            if (HttpRuleParser.GetTokenLength(value, 0) != value.Length)
            {
                throw new FormatException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, value));
            }
        }

        // Token: 0x0600078F RID: 1935 RVA: 0x00055EB4 File Offset: 0x00035EB4
        internal static void CheckValidComment(string value, string parameterName)
        {
            if (string.IsNullOrEmpty(value))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, parameterName);
            }
            int num = 0;
            if (HttpRuleParser.GetCommentLength(value, 0, out num) != HttpParseResult.Parsed || num != value.Length)
            {
                throw new FormatException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, value));
            }
        }

        // Token: 0x06000790 RID: 1936 RVA: 0x00055F04 File Offset: 0x00035F04
        internal static void CheckValidQuotedString(string value, string parameterName)
        {
            if (string.IsNullOrEmpty(value))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, parameterName);
            }
            int num = 0;
            if (HttpRuleParser.GetQuotedStringLength(value, 0, out num) != HttpParseResult.Parsed || num != value.Length)
            {
                throw new FormatException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, value));
            }
        }

        // Token: 0x06000791 RID: 1937 RVA: 0x00055F51 File Offset: 0x00035F51
        internal static bool AreEqualCollections<T>(ObjectCollection<T> x, ObjectCollection<T> y) where T : class
        {
            return HeaderUtilities.AreEqualCollections<T>(x, y, null);
        }

        // Token: 0x06000792 RID: 1938 RVA: 0x00055F5C File Offset: 0x00035F5C
        internal static bool AreEqualCollections<T>(ObjectCollection<T> x, ObjectCollection<T> y, IEqualityComparer<T> comparer) where T : class
        {
            if (x == null)
            {
                return y == null || y.Count == 0;
            }
            if (y == null)
            {
                return x.Count == 0;
            }
            if (x.Count != y.Count)
            {
                return false;
            }
            if (x.Count == 0)
            {
                return true;
            }
            bool[] array = new bool[x.Count];
            foreach (T t in x)
            {
                int num = 0;
                bool flag = false;
                foreach (T t2 in y)
                {
                    if (!array[num] && ((comparer == null && t.Equals(t2)) || (comparer != null && comparer.Equals(t, t2))))
                    {
                        array[num] = true;
                        flag = true;
                        break;
                    }
                    num++;
                }
                if (!flag)
                {
                    return false;
                }
            }
            return true;
        }

        // Token: 0x06000793 RID: 1939 RVA: 0x00056070 File Offset: 0x00036070
        internal static int GetNextNonEmptyOrWhitespaceIndex(string input, int startIndex, bool skipEmptyValues, out bool separatorFound)
        {
            separatorFound = false;
            int num = startIndex + HttpRuleParser.GetWhitespaceLength(input, startIndex);
            if (num == input.Length || input[num] != ',')
            {
                return num;
            }
            separatorFound = true;
            num++;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            if (skipEmptyValues)
            {
                while (num < input.Length && input[num] == ',')
                {
                    num++;
                    num += HttpRuleParser.GetWhitespaceLength(input, num);
                }
            }
            return num;
        }

        // Token: 0x06000794 RID: 1940 RVA: 0x000560DC File Offset: 0x000360DC
        internal static DateTimeOffset? GetDateTimeOffsetValue(HeaderDescriptor descriptor, HttpHeaders store)
        {
            object parsedValues = store.GetParsedValues(descriptor);
            if (parsedValues != null)
            {
                return new DateTimeOffset?((DateTimeOffset)parsedValues);
            }
            return null;
        }

        // Token: 0x06000795 RID: 1941 RVA: 0x0005610C File Offset: 0x0003610C
        internal static TimeSpan? GetTimeSpanValue(HeaderDescriptor descriptor, HttpHeaders store)
        {
            object parsedValues = store.GetParsedValues(descriptor);
            if (parsedValues != null)
            {
                return new TimeSpan?((TimeSpan)parsedValues);
            }
            return null;
        }

        // Token: 0x06000796 RID: 1942 RVA: 0x00056139 File Offset: 0x00036139
        internal static bool TryParseInt32(string value, out int result)
        {
            return HeaderUtilities.TryParseInt32(value, 0, value.Length, out result);
        }

        // Token: 0x06000797 RID: 1943 RVA: 0x0005614C File Offset: 0x0003614C
        internal static bool TryParseInt32(string value, int offset, int length, out int result)
        {
            if (offset < 0 || length < 0 || offset > value.Length - length)
            {
                result = 0;
                return false;
            }
            int num = 0;
            int i = offset;
            int num2 = offset + length;
            while (i < num2)
            {
                char c = value[i++];
                int num3 = (int)(c - '0');
                if (num3 > 9 || num > 214748364 || (num == 214748364 && num3 > 7))
                {
                    result = 0;
                    return false;
                }
                num = num * 10 + num3;
            }
            result = num;
            return true;
        }

        // Token: 0x06000798 RID: 1944 RVA: 0x000561C0 File Offset: 0x000361C0
        internal static bool TryParseInt64(string value, int offset, int length, out long result)
        {
            if (offset < 0 || length < 0 || offset > value.Length - length)
            {
                result = 0L;
                return false;
            }
            long num = 0L;
            int i = offset;
            int num2 = offset + length;
            while (i < num2)
            {
                char c = value[i++];
                int num3 = (int)(c - '0');
                if (num3 > 9 || num > 922337203685477580L || (num == 922337203685477580L && num3 > 7))
                {
                    result = 0L;
                    return false;
                }
                num = num * 10L + (long)num3;
            }
            result = num;
            return true;
        }

        // Token: 0x06000799 RID: 1945 RVA: 0x00056240 File Offset: 0x00036240
        internal static string DumpHeaders(params HttpHeaders[] headers)
        {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.Append("{\r\n");
            for (int i = 0; i < headers.Length; i++)
            {
                if (headers[i] != null)
                {
                    foreach (KeyValuePair<string, IEnumerable<string>> keyValuePair in headers[i])
                    {
                        foreach (string value in keyValuePair.Value)
                        {
                            stringBuilder.Append("  ");
                            stringBuilder.Append(keyValuePair.Key);
                            stringBuilder.Append(": ");
                            stringBuilder.Append(value);
                            stringBuilder.Append("\r\n");
                        }
                    }
                }
            }
            stringBuilder.Append('}');
            return stringBuilder.ToString();
        }

        // Token: 0x0600079A RID: 1946 RVA: 0x00056338 File Offset: 0x00036338
        internal static bool IsValidEmailAddress(string value)
        {
            try
            {
                return Str.CheckMailAddress(value);
            }
            catch (FormatException ex)
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(null, SR.Format(SR.net_http_log_headers_wrong_email_format, value, ex.Message), "IsValidEmailAddress");
                }
            }
            return false;
        }

        // Token: 0x0600079B RID: 1947 RVA: 0x0005638C File Offset: 0x0003638C
        private static void ValidateToken(HttpHeaderValueCollection<string> collection, string value)
        {
            HeaderUtilities.CheckValidToken(value, "item");
        }

        // Token: 0x040005A6 RID: 1446
        internal static readonly TransferCodingHeaderValue TransferEncodingChunked = new TransferCodingHeaderValue("chunked");

        // Token: 0x040005A7 RID: 1447
        internal static readonly NameValueWithParametersHeaderValue ExpectContinue = new NameValueWithParametersHeaderValue("100-continue");

        // Token: 0x040005A8 RID: 1448
        internal static readonly Action<HttpHeaderValueCollection<string>, string> TokenValidator = new Action<HttpHeaderValueCollection<string>, string>(HeaderUtilities.ValidateToken);

        // Token: 0x040005A9 RID: 1449
        private static readonly char[] s_hexUpperChars = new char[]
        {
            '0',
            '1',
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9',
            'A',
            'B',
            'C',
            'D',
            'E',
            'F'
        };
    }


    /// <summary>
    ///         RFC 2616 で定義されているコンテンツ ヘッダーのコレクションを表します。
    ///       </summary>
    // Token: 0x0200012B RID: 299
    sealed class HttpContentHeaders : HttpHeaders
    {
        /// <summary>
        ///         HTTP 応答の <see langword="Allow" /> コンテンツ ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Allow" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x17000175 RID: 373
        // (get) Token: 0x0600079D RID: 1949 RVA: 0x000563EF File Offset: 0x000363EF
        public ICollection<string> Allow
        {
            get
            {
                if (this._allow == null)
                {
                    this._allow = new HttpHeaderValueCollection<string>(KnownHeaders.Allow.Descriptor, this, HeaderUtilities.TokenValidator);
                }
                return this._allow;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Content-Disposition" /> コンテンツ ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Content-Disposition" /> コンテンツ ヘッダーの値。
        ///       </returns>
        // Token: 0x17000176 RID: 374
        // (get) Token: 0x0600079E RID: 1950 RVA: 0x0005641A File Offset: 0x0003641A
        // (set) Token: 0x0600079F RID: 1951 RVA: 0x00056431 File Offset: 0x00036431
        public ContentDispositionHeaderValue ContentDisposition
        {
            get
            {
                return (ContentDispositionHeaderValue)base.GetParsedValues(KnownHeaders.ContentDisposition.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.ContentDisposition.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Content-Encoding" /> コンテンツ ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Content-Encoding" /> コンテンツ ヘッダーの値。
        ///       </returns>
        // Token: 0x17000177 RID: 375
        // (get) Token: 0x060007A0 RID: 1952 RVA: 0x00056444 File Offset: 0x00036444
        public ICollection<string> ContentEncoding
        {
            get
            {
                if (this._contentEncoding == null)
                {
                    this._contentEncoding = new HttpHeaderValueCollection<string>(KnownHeaders.ContentEncoding.Descriptor, this, HeaderUtilities.TokenValidator);
                }
                return this._contentEncoding;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Content-Language" /> コンテンツ ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Content-Language" /> コンテンツ ヘッダーの値。
        ///       </returns>
        // Token: 0x17000178 RID: 376
        // (get) Token: 0x060007A1 RID: 1953 RVA: 0x0005646F File Offset: 0x0003646F
        public ICollection<string> ContentLanguage
        {
            get
            {
                if (this._contentLanguage == null)
                {
                    this._contentLanguage = new HttpHeaderValueCollection<string>(KnownHeaders.ContentLanguage.Descriptor, this, HeaderUtilities.TokenValidator);
                }
                return this._contentLanguage;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Content-Length" /> コンテンツ ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Content-Length" /> コンテンツ ヘッダーの値。
        ///       </returns>
        // Token: 0x17000179 RID: 377
        // (get) Token: 0x060007A2 RID: 1954 RVA: 0x0005649C File Offset: 0x0003649C
        // (set) Token: 0x060007A3 RID: 1955 RVA: 0x00056510 File Offset: 0x00036510
        public long? ContentLength
        {
            get
            {
                object parsedValues = base.GetParsedValues(KnownHeaders.ContentLength.Descriptor);
                if (!this._contentLengthSet && parsedValues == null)
                {
                    long? computedOrBufferLength = this._parent.GetComputedOrBufferLength();
                    if (computedOrBufferLength != null)
                    {
                        base.SetParsedValue(KnownHeaders.ContentLength.Descriptor, computedOrBufferLength.Value);
                    }
                    return computedOrBufferLength;
                }
                if (parsedValues == null)
                {
                    return null;
                }
                return new long?((long)parsedValues);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.ContentLength.Descriptor, value);
                this._contentLengthSet = true;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Content-Location" /> コンテンツ ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Content-Location" /> コンテンツ ヘッダーの値。
        ///       </returns>
        // Token: 0x1700017A RID: 378
        // (get) Token: 0x060007A4 RID: 1956 RVA: 0x0005652F File Offset: 0x0003652F
        // (set) Token: 0x060007A5 RID: 1957 RVA: 0x00056546 File Offset: 0x00036546
        public Uri ContentLocation
        {
            get
            {
                return (Uri)base.GetParsedValues(KnownHeaders.ContentLocation.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.ContentLocation.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Content-MD5" /> コンテンツ ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Content-MD5" /> コンテンツ ヘッダーの値。
        ///       </returns>
        // Token: 0x1700017B RID: 379
        // (get) Token: 0x060007A6 RID: 1958 RVA: 0x00056559 File Offset: 0x00036559
        // (set) Token: 0x060007A7 RID: 1959 RVA: 0x00056570 File Offset: 0x00036570
        public byte[] ContentMD5
        {
            get
            {
                return (byte[])base.GetParsedValues(KnownHeaders.ContentMD5.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.ContentMD5.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Content-Range" /> コンテンツ ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Content-Range" /> コンテンツ ヘッダーの値。
        ///       </returns>
        // Token: 0x1700017C RID: 380
        // (get) Token: 0x060007A8 RID: 1960 RVA: 0x00056583 File Offset: 0x00036583
        // (set) Token: 0x060007A9 RID: 1961 RVA: 0x0005659A File Offset: 0x0003659A
        public ContentRangeHeaderValue ContentRange
        {
            get
            {
                return (ContentRangeHeaderValue)base.GetParsedValues(KnownHeaders.ContentRange.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.ContentRange.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Content-Type" /> コンテンツ ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Content-Type" /> コンテンツ ヘッダーの値。
        ///       </returns>
        // Token: 0x1700017D RID: 381
        // (get) Token: 0x060007AA RID: 1962 RVA: 0x000565AD File Offset: 0x000365AD
        // (set) Token: 0x060007AB RID: 1963 RVA: 0x000565C4 File Offset: 0x000365C4
        public MediaTypeHeaderValue ContentType
        {
            get
            {
                return (MediaTypeHeaderValue)base.GetParsedValues(KnownHeaders.ContentType.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.ContentType.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Expires" /> コンテンツ ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Expires" /> コンテンツ ヘッダーの値。
        ///       </returns>
        // Token: 0x1700017E RID: 382
        // (get) Token: 0x060007AC RID: 1964 RVA: 0x000565D7 File Offset: 0x000365D7
        // (set) Token: 0x060007AD RID: 1965 RVA: 0x000565E9 File Offset: 0x000365E9
        public DateTimeOffset? Expires
        {
            get
            {
                return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.Expires.Descriptor, this);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.Expires.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Last-Modified" /> コンテンツ ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Last-Modified" /> コンテンツ ヘッダーの値。
        ///       </returns>
        // Token: 0x1700017F RID: 383
        // (get) Token: 0x060007AE RID: 1966 RVA: 0x00056601 File Offset: 0x00036601
        // (set) Token: 0x060007AF RID: 1967 RVA: 0x00056613 File Offset: 0x00036613
        public DateTimeOffset? LastModified
        {
            get
            {
                return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.LastModified.Descriptor, this);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.LastModified.Descriptor, value);
            }
        }

        // Token: 0x060007B0 RID: 1968 RVA: 0x0005662B File Offset: 0x0003662B
        internal HttpContentHeaders(HttpContent parent) : base(HttpHeaderType.Content | HttpHeaderType.Custom, HttpHeaderType.None)
        {
            this._parent = parent;
        }

        // Token: 0x040005AA RID: 1450
        private readonly HttpContent _parent;

        // Token: 0x040005AB RID: 1451
        private bool _contentLengthSet;

        // Token: 0x040005AC RID: 1452
        private HttpHeaderValueCollection<string> _allow;

        // Token: 0x040005AD RID: 1453
        private HttpHeaderValueCollection<string> _contentEncoding;

        // Token: 0x040005AE RID: 1454
        private HttpHeaderValueCollection<string> _contentLanguage;
    }


    // Token: 0x0200012C RID: 300
    internal sealed class HttpGeneralHeaders
    {
        // Token: 0x17000180 RID: 384
        // (get) Token: 0x060007B1 RID: 1969 RVA: 0x0005663D File Offset: 0x0003663D
        // (set) Token: 0x060007B2 RID: 1970 RVA: 0x00056659 File Offset: 0x00036659
        public CacheControlHeaderValue CacheControl
        {
            get
            {
                return (CacheControlHeaderValue)this._parent.GetParsedValues(KnownHeaders.CacheControl.Descriptor);
            }
            set
            {
                this._parent.SetOrRemoveParsedValue(KnownHeaders.CacheControl.Descriptor, value);
            }
        }

        // Token: 0x17000181 RID: 385
        // (get) Token: 0x060007B3 RID: 1971 RVA: 0x00056671 File Offset: 0x00036671
        public HttpHeaderValueCollection<string> Connection
        {
            get
            {
                return this.ConnectionCore;
            }
        }

        // Token: 0x17000182 RID: 386
        // (get) Token: 0x060007B4 RID: 1972 RVA: 0x00056679 File Offset: 0x00036679
        // (set) Token: 0x060007B5 RID: 1973 RVA: 0x00056688 File Offset: 0x00036688
        public bool? ConnectionClose
        {
            get
            {
                return HttpGeneralHeaders.GetConnectionClose(this._parent, this);
            }
            set
            {
                if (value == true)
                {
                    this._connectionCloseSet = true;
                    this.ConnectionCore.SetSpecialValue();
                    return;
                }
                this._connectionCloseSet = (value != null);
                this.ConnectionCore.RemoveSpecialValue();
            }
        }

        // Token: 0x060007B6 RID: 1974 RVA: 0x000566DC File Offset: 0x000366DC
        internal static bool? GetConnectionClose(HttpHeaders parent, HttpGeneralHeaders headers)
        {
            if (((headers != null) ? headers._connection : null) != null)
            {
                if (headers._connection.IsSpecialValueSet)
                {
                    return new bool?(true);
                }
            }
            else if (parent.ContainsParsedValue(KnownHeaders.Connection.Descriptor, "close"))
            {
                return new bool?(true);
            }
            if (headers != null && headers._connectionCloseSet)
            {
                return new bool?(false);
            }
            return null;
        }

        // Token: 0x17000183 RID: 387
        // (get) Token: 0x060007B7 RID: 1975 RVA: 0x00056744 File Offset: 0x00036744
        // (set) Token: 0x060007B8 RID: 1976 RVA: 0x0005675B File Offset: 0x0003675B
        public DateTimeOffset? Date
        {
            get
            {
                return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.Date.Descriptor, this._parent);
            }
            set
            {
                this._parent.SetOrRemoveParsedValue(KnownHeaders.Date.Descriptor, value);
            }
        }

        // Token: 0x17000184 RID: 388
        // (get) Token: 0x060007B9 RID: 1977 RVA: 0x00056778 File Offset: 0x00036778
        public HttpHeaderValueCollection<NameValueHeaderValue> Pragma
        {
            get
            {
                if (this._pragma == null)
                {
                    this._pragma = new HttpHeaderValueCollection<NameValueHeaderValue>(KnownHeaders.Pragma.Descriptor, this._parent);
                }
                return this._pragma;
            }
        }

        // Token: 0x17000185 RID: 389
        // (get) Token: 0x060007BA RID: 1978 RVA: 0x000567A3 File Offset: 0x000367A3
        public HttpHeaderValueCollection<string> Trailer
        {
            get
            {
                if (this._trailer == null)
                {
                    this._trailer = new HttpHeaderValueCollection<string>(KnownHeaders.Trailer.Descriptor, this._parent, HeaderUtilities.TokenValidator);
                }
                return this._trailer;
            }
        }

        // Token: 0x17000186 RID: 390
        // (get) Token: 0x060007BB RID: 1979 RVA: 0x000567D3 File Offset: 0x000367D3
        public HttpHeaderValueCollection<TransferCodingHeaderValue> TransferEncoding
        {
            get
            {
                return this.TransferEncodingCore;
            }
        }

        // Token: 0x060007BC RID: 1980 RVA: 0x000567DC File Offset: 0x000367DC
        internal static bool? GetTransferEncodingChunked(HttpHeaders parent, HttpGeneralHeaders headers)
        {
            if (((headers != null) ? headers._transferEncoding : null) != null)
            {
                if (headers._transferEncoding.IsSpecialValueSet)
                {
                    return new bool?(true);
                }
            }
            else if (parent.ContainsParsedValue(KnownHeaders.TransferEncoding.Descriptor, HeaderUtilities.TransferEncodingChunked))
            {
                return new bool?(true);
            }
            if (headers != null && headers._transferEncodingChunkedSet)
            {
                return new bool?(false);
            }
            return null;
        }

        // Token: 0x17000187 RID: 391
        // (get) Token: 0x060007BD RID: 1981 RVA: 0x00056844 File Offset: 0x00036844
        // (set) Token: 0x060007BE RID: 1982 RVA: 0x00056854 File Offset: 0x00036854
        public bool? TransferEncodingChunked
        {
            get
            {
                return HttpGeneralHeaders.GetTransferEncodingChunked(this._parent, this);
            }
            set
            {
                if (value == true)
                {
                    this._transferEncodingChunkedSet = true;
                    this.TransferEncodingCore.SetSpecialValue();
                    return;
                }
                this._transferEncodingChunkedSet = (value != null);
                this.TransferEncodingCore.RemoveSpecialValue();
            }
        }

        // Token: 0x17000188 RID: 392
        // (get) Token: 0x060007BF RID: 1983 RVA: 0x000568A6 File Offset: 0x000368A6
        public HttpHeaderValueCollection<ProductHeaderValue> Upgrade
        {
            get
            {
                if (this._upgrade == null)
                {
                    this._upgrade = new HttpHeaderValueCollection<ProductHeaderValue>(KnownHeaders.Upgrade.Descriptor, this._parent);
                }
                return this._upgrade;
            }
        }

        // Token: 0x17000189 RID: 393
        // (get) Token: 0x060007C0 RID: 1984 RVA: 0x000568D1 File Offset: 0x000368D1
        public HttpHeaderValueCollection<ViaHeaderValue> Via
        {
            get
            {
                if (this._via == null)
                {
                    this._via = new HttpHeaderValueCollection<ViaHeaderValue>(KnownHeaders.Via.Descriptor, this._parent);
                }
                return this._via;
            }
        }

        // Token: 0x1700018A RID: 394
        // (get) Token: 0x060007C1 RID: 1985 RVA: 0x000568FC File Offset: 0x000368FC
        public HttpHeaderValueCollection<WarningHeaderValue> Warning
        {
            get
            {
                if (this._warning == null)
                {
                    this._warning = new HttpHeaderValueCollection<WarningHeaderValue>(KnownHeaders.Warning.Descriptor, this._parent);
                }
                return this._warning;
            }
        }

        // Token: 0x1700018B RID: 395
        // (get) Token: 0x060007C2 RID: 1986 RVA: 0x00056927 File Offset: 0x00036927
        private HttpHeaderValueCollection<string> ConnectionCore
        {
            get
            {
                if (this._connection == null)
                {
                    this._connection = new HttpHeaderValueCollection<string>(KnownHeaders.Connection.Descriptor, this._parent, "close", HeaderUtilities.TokenValidator);
                }
                return this._connection;
            }
        }

        // Token: 0x1700018C RID: 396
        // (get) Token: 0x060007C3 RID: 1987 RVA: 0x0005695C File Offset: 0x0003695C
        private HttpHeaderValueCollection<TransferCodingHeaderValue> TransferEncodingCore
        {
            get
            {
                if (this._transferEncoding == null)
                {
                    this._transferEncoding = new HttpHeaderValueCollection<TransferCodingHeaderValue>(KnownHeaders.TransferEncoding.Descriptor, this._parent, HeaderUtilities.TransferEncodingChunked);
                }
                return this._transferEncoding;
            }
        }

        // Token: 0x060007C4 RID: 1988 RVA: 0x0005698C File Offset: 0x0003698C
        internal HttpGeneralHeaders(HttpHeaders parent)
        {
            this._parent = parent;
        }

        // Token: 0x060007C5 RID: 1989 RVA: 0x0005699C File Offset: 0x0003699C
        internal void AddSpecialsFrom(HttpGeneralHeaders sourceHeaders)
        {
            if (this.TransferEncodingChunked == null)
            {
                this.TransferEncodingChunked = sourceHeaders.TransferEncodingChunked;
            }
            if (this.ConnectionClose == null)
            {
                this.ConnectionClose = sourceHeaders.ConnectionClose;
            }
        }

        // Token: 0x040005AF RID: 1455
        private HttpHeaderValueCollection<string> _connection;

        // Token: 0x040005B0 RID: 1456
        private HttpHeaderValueCollection<string> _trailer;

        // Token: 0x040005B1 RID: 1457
        private HttpHeaderValueCollection<TransferCodingHeaderValue> _transferEncoding;

        // Token: 0x040005B2 RID: 1458
        private HttpHeaderValueCollection<ProductHeaderValue> _upgrade;

        // Token: 0x040005B3 RID: 1459
        private HttpHeaderValueCollection<ViaHeaderValue> _via;

        // Token: 0x040005B4 RID: 1460
        private HttpHeaderValueCollection<WarningHeaderValue> _warning;

        // Token: 0x040005B5 RID: 1461
        private HttpHeaderValueCollection<NameValueHeaderValue> _pragma;

        // Token: 0x040005B6 RID: 1462
        private HttpHeaders _parent;

        // Token: 0x040005B7 RID: 1463
        private bool _transferEncodingChunkedSet;

        // Token: 0x040005B8 RID: 1464
        private bool _connectionCloseSet;
    }


    // Token: 0x0200012D RID: 301
    internal abstract class HttpHeaderParser
    {
        // Token: 0x1700018D RID: 397
        // (get) Token: 0x060007C6 RID: 1990 RVA: 0x000569E1 File Offset: 0x000369E1
        public bool SupportsMultipleValues
        {
            get
            {
                return this._supportsMultipleValues;
            }
        }

        // Token: 0x1700018E RID: 398
        // (get) Token: 0x060007C7 RID: 1991 RVA: 0x000569E9 File Offset: 0x000369E9
        public string Separator
        {
            get
            {
                return this._separator;
            }
        }

        // Token: 0x1700018F RID: 399
        // (get) Token: 0x060007C8 RID: 1992 RVA: 0x0003BB2E File Offset: 0x0001BB2E
        public virtual IEqualityComparer Comparer
        {
            get
            {
                return null;
            }
        }

        // Token: 0x060007C9 RID: 1993 RVA: 0x000569F1 File Offset: 0x000369F1
        protected HttpHeaderParser(bool supportsMultipleValues)
        {
            this._supportsMultipleValues = supportsMultipleValues;
            if (supportsMultipleValues)
            {
                this._separator = ", ";
            }
        }

        // Token: 0x060007CA RID: 1994 RVA: 0x00056A0E File Offset: 0x00036A0E
        protected HttpHeaderParser(bool supportsMultipleValues, string separator)
        {
            this._supportsMultipleValues = supportsMultipleValues;
            this._separator = separator;
        }

        // Token: 0x060007CB RID: 1995
        public abstract bool TryParseValue(string value, object storeValue, ref int index, out object parsedValue);

        // Token: 0x060007CC RID: 1996 RVA: 0x00056A24 File Offset: 0x00036A24
        public object ParseValue(string value, object storeValue, ref int index)
        {
            object result = null;
            if (!this.TryParseValue(value, storeValue, ref index, out result))
            {
                throw new FormatException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, (value == null) ? "<null>" : value.Substring(index)));
            }
            return result;
        }

        // Token: 0x060007CD RID: 1997 RVA: 0x00056A68 File Offset: 0x00036A68
        public virtual string ToString(object value)
        {
            return value.ToString();
        }

        // Token: 0x040005B9 RID: 1465
        private bool _supportsMultipleValues;

        // Token: 0x040005BA RID: 1466
        private string _separator;
    }


    /// <summary>
    ///         RFC 2616 で定義されているヘッダーとその値のコレクション。
    ///       </summary>
    // Token: 0x0200012E RID: 302
    abstract class HttpHeaders : IEnumerable<KeyValuePair<string, IEnumerable<string>>>, IEnumerable
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaders" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        // Token: 0x060007CE RID: 1998 RVA: 0x00056A70 File Offset: 0x00036A70
        protected HttpHeaders() : this(HttpHeaderType.All, HttpHeaderType.None)
        {
        }

        // Token: 0x060007CF RID: 1999 RVA: 0x00056A7B File Offset: 0x00036A7B
        internal HttpHeaders(HttpHeaderType allowedHeaderTypes, HttpHeaderType treatAsCustomHeaderTypes)
        {
            this._allowedHeaderTypes = allowedHeaderTypes;
            this._treatAsCustomHeaderTypes = treatAsCustomHeaderTypes;
        }

        /// <summary>
        ///         指定されたヘッダーとその値を追加、 <see cref="T:System.Net.Http.Headers.HttpHeaders" /> コレクションです。
        ///       </summary>
        /// <param name="name">
        ///           コレクションに追加するヘッダー。
        ///         </param>
        /// <param name="value">
        ///           ヘッダーの内容。
        ///         </param>
        // Token: 0x060007D0 RID: 2000 RVA: 0x00056A91 File Offset: 0x00036A91
        public void Add(string name, string value)
        {
            this.Add(this.GetHeaderDescriptor(name), value);
        }

        // Token: 0x060007D1 RID: 2001 RVA: 0x00056AA4 File Offset: 0x00036AA4
        internal void Add(HeaderDescriptor descriptor, string value)
        {
            HttpHeaders.HeaderStoreItemInfo headerStoreItemInfo;
            bool flag;
            this.PrepareHeaderInfoForAdd(descriptor, out headerStoreItemInfo, out flag);
            this.ParseAndAddValue(descriptor, headerStoreItemInfo, value);
            if (flag && headerStoreItemInfo.ParsedValue != null)
            {
                this.AddHeaderToStore(descriptor, headerStoreItemInfo);
            }
        }

        /// <summary>
        ///         指定されたヘッダーとその値を追加、 <see cref="T:System.Net.Http.Headers.HttpHeaders" /> コレクションです。
        ///       </summary>
        /// <param name="name">
        ///           コレクションに追加するヘッダー。
        ///         </param>
        /// <param name="values">
        ///           コレクションに追加するヘッダーの値の一覧。
        ///         </param>
        // Token: 0x060007D2 RID: 2002 RVA: 0x00056AD8 File Offset: 0x00036AD8
        public void Add(string name, IEnumerable<string> values)
        {
            this.Add(this.GetHeaderDescriptor(name), values);
        }

        // Token: 0x060007D3 RID: 2003 RVA: 0x00056AE8 File Offset: 0x00036AE8
        internal void Add(HeaderDescriptor descriptor, IEnumerable<string> values)
        {
            if (values == null)
            {
                throw new ArgumentNullException("values");
            }
            HttpHeaders.HeaderStoreItemInfo headerStoreItemInfo;
            bool flag;
            this.PrepareHeaderInfoForAdd(descriptor, out headerStoreItemInfo, out flag);
            try
            {
                foreach (string value in values)
                {
                    this.ParseAndAddValue(descriptor, headerStoreItemInfo, value);
                }
            }
            finally
            {
                if (flag && headerStoreItemInfo.ParsedValue != null)
                {
                    this.AddHeaderToStore(descriptor, headerStoreItemInfo);
                }
            }
        }

        /// <summary>
        ///         指定したヘッダーとその値が、提供された情報を検証せずに <see cref="T:System.Net.Http.Headers.HttpHeaders" /> コレクションに追加されたかどうかを示す値を返します。
        ///       </summary>
        /// <param name="name">
        ///           コレクションに追加するヘッダー。
        ///         </param>
        /// <param name="value">
        ///           ヘッダーの内容。
        ///         </param>
        /// <returns>
        ///         指定したヘッダー <paramref name="name" /> と <paramref name="value" /> がコレクションに追加された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060007D4 RID: 2004 RVA: 0x00056B6C File Offset: 0x00036B6C
        public bool TryAddWithoutValidation(string name, string value)
        {
            HeaderDescriptor descriptor;
            return this.TryGetHeaderDescriptor(name, out descriptor) && this.TryAddWithoutValidation(descriptor, value);
        }

        // Token: 0x060007D5 RID: 2005 RVA: 0x00056B90 File Offset: 0x00036B90
        internal bool TryAddWithoutValidation(HeaderDescriptor descriptor, string value)
        {
            if (value == null)
            {
                value = string.Empty;
            }
            HttpHeaders.HeaderStoreItemInfo orCreateHeaderInfo = this.GetOrCreateHeaderInfo(descriptor, false);
            HttpHeaders.AddValue(orCreateHeaderInfo, value, HttpHeaders.StoreLocation.Raw);
            return true;
        }

        /// <summary>
        ///         指定したヘッダーとその値が、提供された情報を検証せずに <see cref="T:System.Net.Http.Headers.HttpHeaders" /> コレクションに追加されたかどうかを示す値を返します。
        ///       </summary>
        /// <param name="name">
        ///           コレクションに追加するヘッダー。
        ///         </param>
        /// <param name="values">
        ///           ヘッダーの値。
        ///         </param>
        /// <returns>
        ///         指定したヘッダー <paramref name="name" /> と <paramref name="values" /> がコレクションに追加された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060007D6 RID: 2006 RVA: 0x00056BBC File Offset: 0x00036BBC
        public bool TryAddWithoutValidation(string name, IEnumerable<string> values)
        {
            HeaderDescriptor descriptor;
            return this.TryGetHeaderDescriptor(name, out descriptor) && this.TryAddWithoutValidation(descriptor, values);
        }

        // Token: 0x060007D7 RID: 2007 RVA: 0x00056BE0 File Offset: 0x00036BE0
        internal bool TryAddWithoutValidation(HeaderDescriptor descriptor, IEnumerable<string> values)
        {
            if (values == null)
            {
                throw new ArgumentNullException("values");
            }
            HttpHeaders.HeaderStoreItemInfo orCreateHeaderInfo = this.GetOrCreateHeaderInfo(descriptor, false);
            foreach (string text in values)
            {
                HttpHeaders.AddValue(orCreateHeaderInfo, text ?? string.Empty, HttpHeaders.StoreLocation.Raw);
            }
            return true;
        }

        /// <summary>
        ///         すべてのヘッダーを削除、 <see cref="T:System.Net.Http.Headers.HttpHeaders" /> コレクションです。
        ///       </summary>
        // Token: 0x060007D8 RID: 2008 RVA: 0x00056C4C File Offset: 0x00036C4C
        public void Clear()
        {
            if (this._headerStore != null)
            {
                this._headerStore.Clear();
            }
        }

        /// <summary>
        ///         指定したヘッダーから削除、 <see cref="T:System.Net.Http.Headers.HttpHeaders" /> コレクションです。
        ///       </summary>
        /// <param name="name">
        ///           コレクションから削除するヘッダーの名前。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Boolean" /> を返します。
        ///       </returns>
        // Token: 0x060007D9 RID: 2009 RVA: 0x00056C61 File Offset: 0x00036C61
        public bool Remove(string name)
        {
            return this.Remove(this.GetHeaderDescriptor(name));
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaders" /> コレクションに格納されている指定したヘッダーのすべてのヘッダーの値を返します。
        ///       </summary>
        /// <param name="name">
        ///           値を返す指定したヘッダー。
        ///         </param>
        /// <returns>
        ///         ヘッダー文字列の配列。
        ///       </returns>
        // Token: 0x060007DA RID: 2010 RVA: 0x00056C70 File Offset: 0x00036C70
        public IEnumerable<string> GetValues(string name)
        {
            return this.GetValues(this.GetHeaderDescriptor(name));
        }

        // Token: 0x060007DB RID: 2011 RVA: 0x00056C80 File Offset: 0x00036C80
        internal IEnumerable<string> GetValues(HeaderDescriptor descriptor)
        {
            IEnumerable<string> result;
            if (!this.TryGetValues(descriptor, out result))
            {
                throw new InvalidOperationException(SR.net_http_headers_not_found);
            }
            return result;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaders" /> コレクションに指定されたヘッダーと指定した値が格納されているかどうかを返します。
        ///       </summary>
        /// <param name="name">
        ///           指定されたヘッダー。
        ///         </param>
        /// <param name="values">
        ///           指定されたヘッダーの値。
        ///         </param>
        /// <returns>
        ///         <see langword="true" /> は指定したヘッダー <paramref name="name" /> で、<see langword="values" /> はコレクションに存在しています。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060007DC RID: 2012 RVA: 0x00056CA4 File Offset: 0x00036CA4
        public bool TryGetValues(string name, out IEnumerable<string> values)
        {
            HeaderDescriptor descriptor;
            if (!this.TryGetHeaderDescriptor(name, out descriptor))
            {
                values = null;
                return false;
            }
            return this.TryGetValues(descriptor, out values);
        }

        // Token: 0x060007DD RID: 2013 RVA: 0x00056CCC File Offset: 0x00036CCC
        internal bool TryGetValues(HeaderDescriptor descriptor, out IEnumerable<string> values)
        {
            if (this._headerStore == null)
            {
                values = null;
                return false;
            }
            HttpHeaders.HeaderStoreItemInfo info = null;
            if (this.TryGetAndParseHeaderInfo(descriptor, out info))
            {
                values = HttpHeaders.GetValuesAsStrings(descriptor, info, null);
                return true;
            }
            values = null;
            return false;
        }

        /// <summary>
        ///         特定のヘッダーが <see cref="T:System.Net.Http.Headers.HttpHeaders" /> コレクションに存在しているかどうかを返します。
        ///       </summary>
        /// <param name="name">
        ///           特定のヘッダー。
        ///         </param>
        /// <returns>
        ///         <see langword="true" /> には指定したヘッダーがコレクションに存在しています。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060007DE RID: 2014 RVA: 0x00056D03 File Offset: 0x00036D03
        public bool Contains(string name)
        {
            return this.Contains(this.GetHeaderDescriptor(name));
        }

        // Token: 0x060007DF RID: 2015 RVA: 0x00056D14 File Offset: 0x00036D14
        internal bool Contains(HeaderDescriptor descriptor)
        {
            if (this._headerStore == null)
            {
                return false;
            }
            HttpHeaders.HeaderStoreItemInfo headerStoreItemInfo = null;
            return this.TryGetAndParseHeaderInfo(descriptor, out headerStoreItemInfo);
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.HttpHeaders" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x060007E0 RID: 2016 RVA: 0x00056D38 File Offset: 0x00036D38
        public override string ToString()
        {
            if (this._headerStore == null || this._headerStore.Count == 0)
            {
                return string.Empty;
            }
            StringBuilder stringBuilder = new StringBuilder();
            foreach (KeyValuePair<string, string> keyValuePair in this.GetHeaderStrings())
            {
                stringBuilder.Append(keyValuePair.Key);
                stringBuilder.Append(": ");
                stringBuilder.Append(keyValuePair.Value);
                stringBuilder.Append("\r\n");
            }
            return stringBuilder.ToString();
        }

        // Token: 0x060007E1 RID: 2017 RVA: 0x00056DDC File Offset: 0x00036DDC
        internal IEnumerable<KeyValuePair<string, string>> GetHeaderStrings()
        {
            if (this._headerStore == null)
            {
                yield break;
            }
            foreach (KeyValuePair<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo> keyValuePair in this._headerStore)
            {
                string headerString = this.GetHeaderString(keyValuePair.Key, keyValuePair.Value, null);
                yield return new KeyValuePair<string, string>(keyValuePair.Key.Name, headerString);
            }
            Dictionary<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo>.Enumerator enumerator = default(Dictionary<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo>.Enumerator);
            yield break;
            yield break;
        }

        // Token: 0x060007E2 RID: 2018 RVA: 0x00056DEC File Offset: 0x00036DEC
        internal string GetHeaderString(string name)
        {
            HeaderDescriptor descriptor;
            if (!this.TryGetHeaderDescriptor(name, out descriptor))
            {
                return string.Empty;
            }
            return this.GetHeaderString(descriptor, null);
        }

        // Token: 0x060007E3 RID: 2019 RVA: 0x00056E14 File Offset: 0x00036E14
        internal string GetHeaderString(HeaderDescriptor descriptor, object exclude = null)
        {
            HttpHeaders.HeaderStoreItemInfo info;
            if (!this.TryGetHeaderInfo(descriptor, out info))
            {
                return string.Empty;
            }
            return this.GetHeaderString(descriptor, info, exclude);
        }

        // Token: 0x060007E4 RID: 2020 RVA: 0x00056E3C File Offset: 0x00036E3C
        private string GetHeaderString(HeaderDescriptor descriptor, HttpHeaders.HeaderStoreItemInfo info, object exclude = null)
        {
            string[] valuesAsStrings = HttpHeaders.GetValuesAsStrings(descriptor, info, exclude);
            string result;
            if (valuesAsStrings.Length == 1)
            {
                result = valuesAsStrings[0];
            }
            else
            {
                string separator = ", ";
                if (descriptor.Parser != null && descriptor.Parser.SupportsMultipleValues)
                {
                    separator = descriptor.Parser.Separator;
                }
                result = string.Join(separator, valuesAsStrings);
            }
            return result;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaders" /> インスタンスを反復処理できる列挙子を返します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaders" /> の列挙子。
        ///       </returns>
        // Token: 0x060007E5 RID: 2021 RVA: 0x00056E91 File Offset: 0x00036E91
        public IEnumerator<KeyValuePair<string, IEnumerable<string>>> GetEnumerator()
        {
            if (this._headerStore == null || this._headerStore.Count <= 0)
            {
                return ((IEnumerable<KeyValuePair<string, IEnumerable<string>>>)Array.Empty<KeyValuePair<string, IEnumerable<string>>>()).GetEnumerator();
            }
            return this.GetEnumeratorCore();
        }

        // Token: 0x060007E6 RID: 2022 RVA: 0x00056EBA File Offset: 0x00036EBA
        private IEnumerator<KeyValuePair<string, IEnumerable<string>>> GetEnumeratorCore()
        {
            List<HeaderDescriptor> invalidHeaders = null;
            foreach (KeyValuePair<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo> keyValuePair in this._headerStore)
            {
                HeaderDescriptor key = keyValuePair.Key;
                HttpHeaders.HeaderStoreItemInfo value = keyValuePair.Value;
                if (!this.ParseRawHeaderValues(key, value, false))
                {
                    if (invalidHeaders == null)
                    {
                        invalidHeaders = new List<HeaderDescriptor>();
                    }
                    invalidHeaders.Add(key);
                }
                else
                {
                    string[] valuesAsStrings = HttpHeaders.GetValuesAsStrings(key, value, null);
                    yield return new KeyValuePair<string, IEnumerable<string>>(key.Name, valuesAsStrings);
                }
            }
            Dictionary<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo>.Enumerator enumerator = default(Dictionary<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo>.Enumerator);
            if (invalidHeaders != null)
            {
                using (List<HeaderDescriptor>.Enumerator enumerator2 = invalidHeaders.GetEnumerator())
                {
                    while (enumerator2.MoveNext())
                    {
                        HeaderDescriptor key2 = enumerator2.Current;
                        this._headerStore.Remove(key2);
                    }
                    yield break;
                }
            }
            yield break;
            yield break;
        }

        // Token: 0x060007E7 RID: 2023 RVA: 0x00056ECC File Offset: 0x00036ECC
        internal IEnumerable<KeyValuePair<HeaderDescriptor, string[]>> GetHeaderDescriptorsAndValues()
        {
            if (this._headerStore == null || this._headerStore.Count <= 0)
            {
                return Array.Empty<KeyValuePair<HeaderDescriptor, string[]>>();
            }
            return this.GetHeaderDescriptorsAndValuesCore();
        }

        // Token: 0x060007E8 RID: 2024 RVA: 0x00056EFD File Offset: 0x00036EFD
        private IEnumerable<KeyValuePair<HeaderDescriptor, string[]>> GetHeaderDescriptorsAndValuesCore()
        {
            List<HeaderDescriptor> invalidHeaders = null;
            foreach (KeyValuePair<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo> keyValuePair in this._headerStore)
            {
                HeaderDescriptor key = keyValuePair.Key;
                HttpHeaders.HeaderStoreItemInfo value = keyValuePair.Value;
                if (!this.ParseRawHeaderValues(key, value, false))
                {
                    if (invalidHeaders == null)
                    {
                        invalidHeaders = new List<HeaderDescriptor>();
                    }
                    invalidHeaders.Add(key);
                }
                else
                {
                    string[] valuesAsStrings = HttpHeaders.GetValuesAsStrings(key, value, null);
                    yield return new KeyValuePair<HeaderDescriptor, string[]>(key, valuesAsStrings);
                }
            }
            Dictionary<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo>.Enumerator enumerator = default(Dictionary<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo>.Enumerator);
            if (invalidHeaders != null)
            {
                using (List<HeaderDescriptor>.Enumerator enumerator2 = invalidHeaders.GetEnumerator())
                {
                    while (enumerator2.MoveNext())
                    {
                        HeaderDescriptor key2 = enumerator2.Current;
                        this._headerStore.Remove(key2);
                    }
                    yield break;
                }
            }
            yield break;
            yield break;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaders" /> を反復処理できる列挙子を取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaders" /> を反復処理できる <see cref="T:System.Collections.IEnumerator" /> の実装のインスタンス。
        ///       </returns>
        // Token: 0x060007E9 RID: 2025 RVA: 0x00056F0D File Offset: 0x00036F0D
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        // Token: 0x060007EA RID: 2026 RVA: 0x00056F18 File Offset: 0x00036F18
        internal void AddParsedValue(HeaderDescriptor descriptor, object value)
        {
            HttpHeaders.HeaderStoreItemInfo orCreateHeaderInfo = this.GetOrCreateHeaderInfo(descriptor, true);
            HttpHeaders.AddValue(orCreateHeaderInfo, value, HttpHeaders.StoreLocation.Parsed);
        }

        // Token: 0x060007EB RID: 2027 RVA: 0x00056F38 File Offset: 0x00036F38
        internal void SetParsedValue(HeaderDescriptor descriptor, object value)
        {
            HttpHeaders.HeaderStoreItemInfo orCreateHeaderInfo = this.GetOrCreateHeaderInfo(descriptor, true);
            orCreateHeaderInfo.InvalidValue = null;
            orCreateHeaderInfo.ParsedValue = null;
            orCreateHeaderInfo.RawValue = null;
            HttpHeaders.AddValue(orCreateHeaderInfo, value, HttpHeaders.StoreLocation.Parsed);
        }

        // Token: 0x060007EC RID: 2028 RVA: 0x00056F6B File Offset: 0x00036F6B
        internal void SetOrRemoveParsedValue(HeaderDescriptor descriptor, object value)
        {
            if (value == null)
            {
                this.Remove(descriptor);
                return;
            }
            this.SetParsedValue(descriptor, value);
        }

        // Token: 0x060007ED RID: 2029 RVA: 0x00056F81 File Offset: 0x00036F81
        internal bool Remove(HeaderDescriptor descriptor)
        {
            return this._headerStore != null && this._headerStore.Remove(descriptor);
        }

        // Token: 0x060007EE RID: 2030 RVA: 0x00056F9C File Offset: 0x00036F9C
        internal bool RemoveParsedValue(HeaderDescriptor descriptor, object value)
        {
            if (this._headerStore == null)
            {
                return false;
            }
            HttpHeaders.HeaderStoreItemInfo headerStoreItemInfo = null;
            if (!this.TryGetAndParseHeaderInfo(descriptor, out headerStoreItemInfo))
            {
                return false;
            }
            bool result = false;
            if (headerStoreItemInfo.ParsedValue == null)
            {
                return false;
            }
            IEqualityComparer comparer = descriptor.Parser.Comparer;
            List<object> list = headerStoreItemInfo.ParsedValue as List<object>;
            if (list == null)
            {
                if (this.AreEqual(value, headerStoreItemInfo.ParsedValue, comparer))
                {
                    headerStoreItemInfo.ParsedValue = null;
                    result = true;
                }
            }
            else
            {
                foreach (object obj in list)
                {
                    if (this.AreEqual(value, obj, comparer))
                    {
                        result = list.Remove(obj);
                        break;
                    }
                }
                if (list.Count == 0)
                {
                    headerStoreItemInfo.ParsedValue = null;
                }
            }
            if (headerStoreItemInfo.IsEmpty)
            {
                bool flag = this.Remove(descriptor);
            }
            return result;
        }

        // Token: 0x060007EF RID: 2031 RVA: 0x0005707C File Offset: 0x0003707C
        internal bool ContainsParsedValue(HeaderDescriptor descriptor, object value)
        {
            if (this._headerStore == null)
            {
                return false;
            }
            HttpHeaders.HeaderStoreItemInfo headerStoreItemInfo = null;
            if (!this.TryGetAndParseHeaderInfo(descriptor, out headerStoreItemInfo))
            {
                return false;
            }
            if (headerStoreItemInfo.ParsedValue == null)
            {
                return false;
            }
            List<object> list = headerStoreItemInfo.ParsedValue as List<object>;
            IEqualityComparer comparer = descriptor.Parser.Comparer;
            if (list == null)
            {
                return this.AreEqual(value, headerStoreItemInfo.ParsedValue, comparer);
            }
            foreach (object storeValue in list)
            {
                if (this.AreEqual(value, storeValue, comparer))
                {
                    return true;
                }
            }
            return false;
        }

        // Token: 0x060007F0 RID: 2032 RVA: 0x00057128 File Offset: 0x00037128
        internal virtual void AddHeaders(HttpHeaders sourceHeaders)
        {
            if (sourceHeaders._headerStore == null)
            {
                return;
            }
            List<HeaderDescriptor> list = null;
            foreach (KeyValuePair<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo> keyValuePair in sourceHeaders._headerStore)
            {
                if (this._headerStore == null || !this._headerStore.ContainsKey(keyValuePair.Key))
                {
                    HttpHeaders.HeaderStoreItemInfo value = keyValuePair.Value;
                    if (!sourceHeaders.ParseRawHeaderValues(keyValuePair.Key, value, false))
                    {
                        if (list == null)
                        {
                            list = new List<HeaderDescriptor>();
                        }
                        list.Add(keyValuePair.Key);
                    }
                    else
                    {
                        this.AddHeaderInfo(keyValuePair.Key, value);
                    }
                }
            }
            if (list != null)
            {
                foreach (HeaderDescriptor key in list)
                {
                    sourceHeaders._headerStore.Remove(key);
                }
            }
        }

        // Token: 0x060007F1 RID: 2033 RVA: 0x00057224 File Offset: 0x00037224
        private void AddHeaderInfo(HeaderDescriptor descriptor, HttpHeaders.HeaderStoreItemInfo sourceInfo)
        {
            HttpHeaders.HeaderStoreItemInfo headerStoreItemInfo = this.CreateAndAddHeaderToStore(descriptor);
            if (descriptor.Parser == null)
            {
                headerStoreItemInfo.ParsedValue = HttpHeaders.CloneStringHeaderInfoValues(sourceInfo.ParsedValue);
                return;
            }
            headerStoreItemInfo.InvalidValue = HttpHeaders.CloneStringHeaderInfoValues(sourceInfo.InvalidValue);
            if (sourceInfo.ParsedValue != null)
            {
                List<object> list = sourceInfo.ParsedValue as List<object>;
                if (list == null)
                {
                    HttpHeaders.CloneAndAddValue(headerStoreItemInfo, sourceInfo.ParsedValue);
                    return;
                }
                foreach (object source in list)
                {
                    HttpHeaders.CloneAndAddValue(headerStoreItemInfo, source);
                }
            }
        }

        // Token: 0x060007F2 RID: 2034 RVA: 0x000572CC File Offset: 0x000372CC
        private static void CloneAndAddValue(HttpHeaders.HeaderStoreItemInfo destinationInfo, object source)
        {
            ICloneable cloneable = source as ICloneable;
            if (cloneable != null)
            {
                HttpHeaders.AddValue(destinationInfo, cloneable.Clone(), HttpHeaders.StoreLocation.Parsed);
                return;
            }
            HttpHeaders.AddValue(destinationInfo, source, HttpHeaders.StoreLocation.Parsed);
        }

        // Token: 0x060007F3 RID: 2035 RVA: 0x000572FC File Offset: 0x000372FC
        private static object CloneStringHeaderInfoValues(object source)
        {
            if (source == null)
            {
                return null;
            }
            List<object> list = source as List<object>;
            if (list == null)
            {
                return source;
            }
            return new List<object>(list);
        }

        // Token: 0x060007F4 RID: 2036 RVA: 0x00057320 File Offset: 0x00037320
        private HttpHeaders.HeaderStoreItemInfo GetOrCreateHeaderInfo(HeaderDescriptor descriptor, bool parseRawValues)
        {
            HttpHeaders.HeaderStoreItemInfo result = null;
            bool flag;
            if (parseRawValues)
            {
                flag = this.TryGetAndParseHeaderInfo(descriptor, out result);
            }
            else
            {
                flag = this.TryGetHeaderInfo(descriptor, out result);
            }
            if (!flag)
            {
                result = this.CreateAndAddHeaderToStore(descriptor);
            }
            return result;
        }

        // Token: 0x060007F5 RID: 2037 RVA: 0x00057358 File Offset: 0x00037358
        private HttpHeaders.HeaderStoreItemInfo CreateAndAddHeaderToStore(HeaderDescriptor descriptor)
        {
            HttpHeaders.HeaderStoreItemInfo headerStoreItemInfo = new HttpHeaders.HeaderStoreItemInfo();
            this.AddHeaderToStore(descriptor, headerStoreItemInfo);
            return headerStoreItemInfo;
        }

        // Token: 0x060007F6 RID: 2038 RVA: 0x00057374 File Offset: 0x00037374
        private void AddHeaderToStore(HeaderDescriptor descriptor, HttpHeaders.HeaderStoreItemInfo info)
        {
            if (this._headerStore == null)
            {
                this._headerStore = new Dictionary<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo>();
            }
            this._headerStore.Add(descriptor, info);
        }

        // Token: 0x060007F7 RID: 2039 RVA: 0x00057396 File Offset: 0x00037396
        private bool TryGetHeaderInfo(HeaderDescriptor descriptor, out HttpHeaders.HeaderStoreItemInfo info)
        {
            if (this._headerStore == null)
            {
                info = null;
                return false;
            }
            return this._headerStore.TryGetValue(descriptor, out info);
        }

        // Token: 0x060007F8 RID: 2040 RVA: 0x000573B2 File Offset: 0x000373B2
        private bool TryGetAndParseHeaderInfo(HeaderDescriptor key, out HttpHeaders.HeaderStoreItemInfo info)
        {
            return this.TryGetHeaderInfo(key, out info) && this.ParseRawHeaderValues(key, info, true);
        }

        // Token: 0x060007F9 RID: 2041 RVA: 0x000573CC File Offset: 0x000373CC
        private bool ParseRawHeaderValues(HeaderDescriptor descriptor, HttpHeaders.HeaderStoreItemInfo info, bool removeEmptyHeader)
        {
            lock (info)
            {
                if (info.RawValue != null)
                {
                    List<string> list = info.RawValue as List<string>;
                    if (list == null)
                    {
                        HttpHeaders.ParseSingleRawHeaderValue(descriptor, info);
                    }
                    else
                    {
                        HttpHeaders.ParseMultipleRawHeaderValues(descriptor, info, list);
                    }
                    info.RawValue = null;
                    if (info.InvalidValue == null && info.ParsedValue == null)
                    {
                        if (removeEmptyHeader)
                        {
                            this._headerStore.Remove(descriptor);
                        }
                        return false;
                    }
                }
            }
            return true;
        }

        // Token: 0x060007FA RID: 2042 RVA: 0x00057458 File Offset: 0x00037458
        private static void ParseMultipleRawHeaderValues(HeaderDescriptor descriptor, HttpHeaders.HeaderStoreItemInfo info, List<string> rawValues)
        {
            if (descriptor.Parser == null)
            {
                using (List<string>.Enumerator enumerator = rawValues.GetEnumerator())
                {
                    while (enumerator.MoveNext())
                    {
                        string value = enumerator.Current;
                        if (!HttpHeaders.ContainsInvalidNewLine(value, descriptor.Name))
                        {
                            HttpHeaders.AddValue(info, value, HttpHeaders.StoreLocation.Parsed);
                        }
                    }
                    return;
                }
            }
            foreach (string text in rawValues)
            {
                if (!HttpHeaders.TryParseAndAddRawHeaderValue(descriptor, info, text, true) && NetEventSource.IsEnabled)
                {
                    NetEventSource.Log.HeadersInvalidValue(descriptor.Name, text);
                }
            }
        }

        // Token: 0x060007FB RID: 2043 RVA: 0x0005751C File Offset: 0x0003751C
        private static void ParseSingleRawHeaderValue(HeaderDescriptor descriptor, HttpHeaders.HeaderStoreItemInfo info)
        {
            string text = info.RawValue as string;
            if (descriptor.Parser == null)
            {
                if (!HttpHeaders.ContainsInvalidNewLine(text, descriptor.Name))
                {
                    HttpHeaders.AddValue(info, text, HttpHeaders.StoreLocation.Parsed);
                    return;
                }
            }
            else if (!HttpHeaders.TryParseAndAddRawHeaderValue(descriptor, info, text, true) && NetEventSource.IsEnabled)
            {
                NetEventSource.Log.HeadersInvalidValue(descriptor.Name, text);
            }
        }

        // Token: 0x060007FC RID: 2044 RVA: 0x0005757C File Offset: 0x0003757C
        internal bool TryParseAndAddValue(HeaderDescriptor descriptor, string value)
        {
            HttpHeaders.HeaderStoreItemInfo headerStoreItemInfo;
            bool flag;
            this.PrepareHeaderInfoForAdd(descriptor, out headerStoreItemInfo, out flag);
            bool flag2 = HttpHeaders.TryParseAndAddRawHeaderValue(descriptor, headerStoreItemInfo, value, false);
            if (flag2 && flag && headerStoreItemInfo.ParsedValue != null)
            {
                this.AddHeaderToStore(descriptor, headerStoreItemInfo);
            }
            return flag2;
        }

        // Token: 0x060007FD RID: 2045 RVA: 0x000575B4 File Offset: 0x000375B4
        private static bool TryParseAndAddRawHeaderValue(HeaderDescriptor descriptor, HttpHeaders.HeaderStoreItemInfo info, string value, bool addWhenInvalid)
        {
            if (!info.CanAddValue(descriptor.Parser))
            {
                if (addWhenInvalid)
                {
                    HttpHeaders.AddValue(info, value ?? string.Empty, HttpHeaders.StoreLocation.Invalid);
                }
                return false;
            }
            int i = 0;
            object obj = null;
            if (!descriptor.Parser.TryParseValue(value, info.ParsedValue, ref i, out obj))
            {
                if (!HttpHeaders.ContainsInvalidNewLine(value, descriptor.Name) && addWhenInvalid)
                {
                    HttpHeaders.AddValue(info, value ?? string.Empty, HttpHeaders.StoreLocation.Invalid);
                }
                return false;
            }
            if (value == null || i == value.Length)
            {
                if (obj != null)
                {
                    HttpHeaders.AddValue(info, obj, HttpHeaders.StoreLocation.Parsed);
                }
                return true;
            }
            List<object> list = new List<object>();
            if (obj != null)
            {
                list.Add(obj);
            }
            while (i < value.Length)
            {
                if (!descriptor.Parser.TryParseValue(value, info.ParsedValue, ref i, out obj))
                {
                    if (!HttpHeaders.ContainsInvalidNewLine(value, descriptor.Name) && addWhenInvalid)
                    {
                        HttpHeaders.AddValue(info, value, HttpHeaders.StoreLocation.Invalid);
                    }
                    return false;
                }
                if (obj != null)
                {
                    list.Add(obj);
                }
            }
            foreach (object value2 in list)
            {
                HttpHeaders.AddValue(info, value2, HttpHeaders.StoreLocation.Parsed);
            }
            return true;
        }

        // Token: 0x060007FE RID: 2046 RVA: 0x000576EC File Offset: 0x000376EC
        private static void AddValue(HttpHeaders.HeaderStoreItemInfo info, object value, HttpHeaders.StoreLocation location)
        {
            object obj = null;
            switch (location)
            {
                case HttpHeaders.StoreLocation.Raw:
                    obj = info.RawValue;
                    HttpHeaders.AddValueToStoreValue<string>(value, ref obj);
                    info.RawValue = obj;
                    return;
                case HttpHeaders.StoreLocation.Invalid:
                    obj = info.InvalidValue;
                    HttpHeaders.AddValueToStoreValue<string>(value, ref obj);
                    info.InvalidValue = obj;
                    return;
                case HttpHeaders.StoreLocation.Parsed:
                    obj = info.ParsedValue;
                    HttpHeaders.AddValueToStoreValue<object>(value, ref obj);
                    info.ParsedValue = obj;
                    return;
                default:
                    return;
            }
        }

        // Token: 0x060007FF RID: 2047 RVA: 0x00057754 File Offset: 0x00037754
        private static void AddValueToStoreValue<T>(object value, ref object currentStoreValue) where T : class
        {
            if (currentStoreValue == null)
            {
                currentStoreValue = value;
                return;
            }
            List<T> list = currentStoreValue as List<T>;
            if (list == null)
            {
                list = new List<T>(2);
                list.Add(currentStoreValue as T);
                currentStoreValue = list;
            }
            list.Add(value as T);
        }

        // Token: 0x06000800 RID: 2048 RVA: 0x000577A4 File Offset: 0x000377A4
        internal object GetParsedValues(HeaderDescriptor descriptor)
        {
            HttpHeaders.HeaderStoreItemInfo headerStoreItemInfo = null;
            if (!this.TryGetAndParseHeaderInfo(descriptor, out headerStoreItemInfo))
            {
                return null;
            }
            return headerStoreItemInfo.ParsedValue;
        }

        // Token: 0x06000801 RID: 2049 RVA: 0x000577C6 File Offset: 0x000377C6
        private void PrepareHeaderInfoForAdd(HeaderDescriptor descriptor, out HttpHeaders.HeaderStoreItemInfo info, out bool addToStore)
        {
            info = null;
            addToStore = false;
            if (!this.TryGetAndParseHeaderInfo(descriptor, out info))
            {
                info = new HttpHeaders.HeaderStoreItemInfo();
                addToStore = true;
            }
        }

        // Token: 0x06000802 RID: 2050 RVA: 0x000577E4 File Offset: 0x000377E4
        private void ParseAndAddValue(HeaderDescriptor descriptor, HttpHeaders.HeaderStoreItemInfo info, string value)
        {
            if (descriptor.Parser == null)
            {
                HttpHeaders.CheckInvalidNewLine(value);
                HttpHeaders.AddValue(info, value ?? string.Empty, HttpHeaders.StoreLocation.Parsed);
                return;
            }
            if (!info.CanAddValue(descriptor.Parser))
            {
                throw new FormatException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_single_value_header, descriptor.Name));
            }
            int i = 0;
            object obj = descriptor.Parser.ParseValue(value, info.ParsedValue, ref i);
            if (value == null || i == value.Length)
            {
                if (obj != null)
                {
                    HttpHeaders.AddValue(info, obj, HttpHeaders.StoreLocation.Parsed);
                }
                return;
            }
            List<object> list = new List<object>();
            if (obj != null)
            {
                list.Add(obj);
            }
            while (i < value.Length)
            {
                obj = descriptor.Parser.ParseValue(value, info.ParsedValue, ref i);
                if (obj != null)
                {
                    list.Add(obj);
                }
            }
            foreach (object value2 in list)
            {
                HttpHeaders.AddValue(info, value2, HttpHeaders.StoreLocation.Parsed);
            }
        }

        // Token: 0x06000803 RID: 2051 RVA: 0x000578EC File Offset: 0x000378EC
        private HeaderDescriptor GetHeaderDescriptor(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, "name");
            }
            HeaderDescriptor result;
            if (!HeaderDescriptor.TryGet(name, out result))
            {
                throw new FormatException(SR.net_http_headers_invalid_header_name);
            }
            if ((result.HeaderType & this._allowedHeaderTypes) != HttpHeaderType.None)
            {
                return result;
            }
            if ((result.HeaderType & this._treatAsCustomHeaderTypes) != HttpHeaderType.None)
            {
                return result.AsCustomHeader();
            }
            throw new InvalidOperationException(SR.net_http_headers_not_allowed_header_name);
        }

        // Token: 0x06000804 RID: 2052 RVA: 0x0005795C File Offset: 0x0003795C
        private bool TryGetHeaderDescriptor(string name, out HeaderDescriptor descriptor)
        {
            if (string.IsNullOrEmpty(name))
            {
                descriptor = default(HeaderDescriptor);
                return false;
            }
            if (!HeaderDescriptor.TryGet(name, out descriptor))
            {
                return false;
            }
            if ((descriptor.HeaderType & this._allowedHeaderTypes) != HttpHeaderType.None)
            {
                return true;
            }
            if ((descriptor.HeaderType & this._treatAsCustomHeaderTypes) != HttpHeaderType.None)
            {
                descriptor = descriptor.AsCustomHeader();
                return true;
            }
            return false;
        }

        // Token: 0x06000805 RID: 2053 RVA: 0x000579B4 File Offset: 0x000379B4
        private static void CheckInvalidNewLine(string value)
        {
            if (value == null)
            {
                return;
            }
            if (HttpRuleParser.ContainsInvalidNewLine(value))
            {
                throw new FormatException(SR.net_http_headers_no_newlines);
            }
        }

        // Token: 0x06000806 RID: 2054 RVA: 0x000579CD File Offset: 0x000379CD
        private static bool ContainsInvalidNewLine(string value, string name)
        {
            if (HttpRuleParser.ContainsInvalidNewLine(value))
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(null, SR.Format(SR.net_http_log_headers_no_newlines, name, value), "ContainsInvalidNewLine");
                }
                return true;
            }
            return false;
        }

        // Token: 0x06000807 RID: 2055 RVA: 0x000579F8 File Offset: 0x000379F8
        private static string[] GetValuesAsStrings(HeaderDescriptor descriptor, HttpHeaders.HeaderStoreItemInfo info, object exclude = null)
        {
            int valueCount = HttpHeaders.GetValueCount(info);
            string[] array;
            if (valueCount > 0)
            {
                array = new string[valueCount];
                int num = 0;
                HttpHeaders.ReadStoreValues<string>(array, info.RawValue, null, null, ref num);
                HttpHeaders.ReadStoreValues<object>(array, info.ParsedValue, descriptor.Parser, exclude, ref num);
                HttpHeaders.ReadStoreValues<string>(array, info.InvalidValue, null, null, ref num);
                if (num < valueCount)
                {
                    string[] array2 = new string[num];
                    Array.Copy(array, 0, array2, 0, num);
                    array = array2;
                }
            }
            else
            {
                array = Array.Empty<string>();
            }
            return array;
        }

        // Token: 0x06000808 RID: 2056 RVA: 0x00057A70 File Offset: 0x00037A70
        private static int GetValueCount(HttpHeaders.HeaderStoreItemInfo info)
        {
            int result = 0;
            HttpHeaders.UpdateValueCount<string>(info.RawValue, ref result);
            HttpHeaders.UpdateValueCount<string>(info.InvalidValue, ref result);
            HttpHeaders.UpdateValueCount<object>(info.ParsedValue, ref result);
            return result;
        }

        // Token: 0x06000809 RID: 2057 RVA: 0x00057AA8 File Offset: 0x00037AA8
        private static void UpdateValueCount<T>(object valueStore, ref int valueCount)
        {
            if (valueStore == null)
            {
                return;
            }
            List<T> list = valueStore as List<T>;
            if (list != null)
            {
                valueCount += list.Count;
                return;
            }
            valueCount++;
        }

        // Token: 0x0600080A RID: 2058 RVA: 0x00057AD8 File Offset: 0x00037AD8
        private static void ReadStoreValues<T>(string[] values, object storeValue, HttpHeaderParser parser, T exclude, ref int currentIndex)
        {
            if (storeValue != null)
            {
                List<T> list = storeValue as List<T>;
                if (list == null)
                {
                    if (HttpHeaders.ShouldAdd<T>(storeValue, parser, exclude))
                    {
                        values[currentIndex] = ((parser == null) ? storeValue.ToString() : parser.ToString(storeValue));
                        currentIndex++;
                        return;
                    }
                }
                else
                {
                    foreach (T t in list)
                    {
                        object obj = t;
                        if (HttpHeaders.ShouldAdd<T>(obj, parser, exclude))
                        {
                            values[currentIndex] = ((parser == null) ? obj.ToString() : parser.ToString(obj));
                            currentIndex++;
                        }
                    }
                }
            }
        }

        // Token: 0x0600080B RID: 2059 RVA: 0x00057B88 File Offset: 0x00037B88
        private static bool ShouldAdd<T>(object storeValue, HttpHeaderParser parser, T exclude)
        {
            bool result = true;
            if (parser != null && exclude != null)
            {
                if (parser.Comparer != null)
                {
                    result = !parser.Comparer.Equals(exclude, storeValue);
                }
                else
                {
                    result = !exclude.Equals(storeValue);
                }
            }
            return result;
        }

        // Token: 0x0600080C RID: 2060 RVA: 0x00057BD5 File Offset: 0x00037BD5
        private bool AreEqual(object value, object storeValue, IEqualityComparer comparer)
        {
            if (comparer != null)
            {
                return comparer.Equals(value, storeValue);
            }
            return value.Equals(storeValue);
        }

        // Token: 0x040005BB RID: 1467
        private Dictionary<HeaderDescriptor, HttpHeaders.HeaderStoreItemInfo> _headerStore;

        // Token: 0x040005BC RID: 1468
        private readonly HttpHeaderType _allowedHeaderTypes;

        // Token: 0x040005BD RID: 1469
        private readonly HttpHeaderType _treatAsCustomHeaderTypes;

        // Token: 0x0200012F RID: 303
        private enum StoreLocation
        {
            // Token: 0x040005BF RID: 1471
            Raw,
            // Token: 0x040005C0 RID: 1472
            Invalid,
            // Token: 0x040005C1 RID: 1473
            Parsed
        }

        // Token: 0x02000130 RID: 304
        private class HeaderStoreItemInfo
        {
            // Token: 0x17000190 RID: 400
            // (get) Token: 0x0600080D RID: 2061 RVA: 0x00057BEA File Offset: 0x00037BEA
            // (set) Token: 0x0600080E RID: 2062 RVA: 0x00057BF2 File Offset: 0x00037BF2
            internal object RawValue
            {
                get
                {
                    return this._rawValue;
                }
                set
                {
                    this._rawValue = value;
                }
            }

            // Token: 0x17000191 RID: 401
            // (get) Token: 0x0600080F RID: 2063 RVA: 0x00057BFB File Offset: 0x00037BFB
            // (set) Token: 0x06000810 RID: 2064 RVA: 0x00057C03 File Offset: 0x00037C03
            internal object InvalidValue
            {
                get
                {
                    return this._invalidValue;
                }
                set
                {
                    this._invalidValue = value;
                }
            }

            // Token: 0x17000192 RID: 402
            // (get) Token: 0x06000811 RID: 2065 RVA: 0x00057C0C File Offset: 0x00037C0C
            // (set) Token: 0x06000812 RID: 2066 RVA: 0x00057C14 File Offset: 0x00037C14
            internal object ParsedValue
            {
                get
                {
                    return this._parsedValue;
                }
                set
                {
                    this._parsedValue = value;
                }
            }

            // Token: 0x06000813 RID: 2067 RVA: 0x00057C1D File Offset: 0x00037C1D
            internal bool CanAddValue(HttpHeaderParser parser)
            {
                return parser.SupportsMultipleValues || (this._invalidValue == null && this._parsedValue == null);
            }

            // Token: 0x17000193 RID: 403
            // (get) Token: 0x06000814 RID: 2068 RVA: 0x00057C3C File Offset: 0x00037C3C
            internal bool IsEmpty
            {
                get
                {
                    return this._rawValue == null && this._invalidValue == null && this._parsedValue == null;
                }
            }

            // Token: 0x06000815 RID: 2069 RVA: 0x00035094 File Offset: 0x00015094
            internal HeaderStoreItemInfo()
            {
            }

            // Token: 0x040005C2 RID: 1474
            private object _rawValue;

            // Token: 0x040005C3 RID: 1475
            private object _invalidValue;

            // Token: 0x040005C4 RID: 1476
            private object _parsedValue;
        }
    }

    // Token: 0x02000119 RID: 281
    [Flags]
    internal enum HttpHeaderType : byte
    {
        // Token: 0x0400050C RID: 1292
        General = 1,
        // Token: 0x0400050D RID: 1293
        Request = 2,
        // Token: 0x0400050E RID: 1294
        Response = 4,
        // Token: 0x0400050F RID: 1295
        Content = 8,
        // Token: 0x04000510 RID: 1296
        Custom = 16,
        // Token: 0x04000511 RID: 1297
        All = 31,
        // Token: 0x04000512 RID: 1298
        None = 0
    }


    /// <summary>
    ///         ヘッダー値のコレクションを表します。
    ///       </summary>
    /// <typeparam name="T">
    ///           ヘッダーのコレクション型。
    ///         </typeparam>
    // Token: 0x02000134 RID: 308
    sealed class HttpHeaderValueCollection<T> : ICollection<T>, IEnumerable<T>, IEnumerable where T : class
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> 内のヘッダーの数を取得します。
        ///       </summary>
        /// <returns>
        ///         このコレクション内のヘッダーの数
        ///       </returns>
        // Token: 0x1700019A RID: 410
        // (get) Token: 0x0600082F RID: 2095 RVA: 0x0005825B File Offset: 0x0003825B
        public int Count
        {
            get
            {
                return this.GetCount();
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> インスタンスが読み取り専用かどうかを示す値を取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> インスタンスが読み取り専用の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x1700019B RID: 411
        // (get) Token: 0x06000830 RID: 2096 RVA: 0x000356C2 File Offset: 0x000156C2
        public bool IsReadOnly
        {
            get
            {
                return false;
            }
        }

        // Token: 0x1700019C RID: 412
        // (get) Token: 0x06000831 RID: 2097 RVA: 0x00058263 File Offset: 0x00038263
        internal bool IsSpecialValueSet
        {
            get
            {
                return this._specialValue != null && this._store.ContainsParsedValue(this._descriptor, this._specialValue);
            }
        }

        // Token: 0x06000832 RID: 2098 RVA: 0x00058290 File Offset: 0x00038290
        internal HttpHeaderValueCollection(HeaderDescriptor descriptor, HttpHeaders store) : this(descriptor, store, default(T), null)
        {
        }

        // Token: 0x06000833 RID: 2099 RVA: 0x000582B0 File Offset: 0x000382B0
        internal HttpHeaderValueCollection(HeaderDescriptor descriptor, HttpHeaders store, Action<HttpHeaderValueCollection<T>, T> validator) : this(descriptor, store, default(T), validator)
        {
        }

        // Token: 0x06000834 RID: 2100 RVA: 0x000582CF File Offset: 0x000382CF
        internal HttpHeaderValueCollection(HeaderDescriptor descriptor, HttpHeaders store, T specialValue) : this(descriptor, store, specialValue, null)
        {
        }

        // Token: 0x06000835 RID: 2101 RVA: 0x000582DB File Offset: 0x000382DB
        internal HttpHeaderValueCollection(HeaderDescriptor descriptor, HttpHeaders store, T specialValue, Action<HttpHeaderValueCollection<T>, T> validator)
        {
            this._store = store;
            this._descriptor = descriptor;
            this._specialValue = specialValue;
            this._validator = validator;
        }

        /// <summary>
        ///         エントリを追加、 <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" />です。
        ///       </summary>
        /// <param name="item">
        ///           ヘッダーのコレクションに追加する項目。
        ///         </param>
        // Token: 0x06000836 RID: 2102 RVA: 0x00058300 File Offset: 0x00038300
        public void Add(T item)
        {
            this.CheckValue(item);
            this._store.AddParsedValue(this._descriptor, item);
        }

        /// <summary>
        ///         解析しにエントリを追加、 <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" />です。
        ///       </summary>
        /// <param name="input">
        ///           追加するエントリです。
        ///         </param>
        // Token: 0x06000837 RID: 2103 RVA: 0x00058320 File Offset: 0x00038320
        public void ParseAdd(string input)
        {
            this._store.Add(this._descriptor, input);
        }

        /// <summary>
        ///         入力を解析して <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> に追加できるかどうか決定します。
        ///       </summary>
        /// <param name="input">
        ///           検証するエントリ。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が解析され <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> インスタンスに追加できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000838 RID: 2104 RVA: 0x00058334 File Offset: 0x00038334
        public bool TryParseAdd(string input)
        {
            return this._store.TryParseAndAddValue(this._descriptor, input);
        }

        /// <summary>
        ///         すべてのエントリを削除、 <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" />です。
        ///       </summary>
        // Token: 0x06000839 RID: 2105 RVA: 0x00058348 File Offset: 0x00038348
        public void Clear()
        {
            this._store.Remove(this._descriptor);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> に項目が格納されているかどうかを確認します。
        ///       </summary>
        /// <param name="item">
        ///           ヘッダーのコレクションを検索する項目。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> インスタンスにエントリが含まれている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x0600083A RID: 2106 RVA: 0x0005835C File Offset: 0x0003835C
        public bool Contains(T item)
        {
            this.CheckValue(item);
            return this._store.ContainsParsedValue(this._descriptor, item);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> 全体を、互換性のある 1 次元の <see cref="T:System.Array" /> にコピーします。コピー操作は、コピー先の配列の指定したインデックスから始まる部分に行います。
        ///       </summary>
        /// <param name="array">
        ///           <see cref="T:System.Array" /> から要素がコピーされる 1 次元の <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" />。
        ///           <see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。
        ///         </param>
        /// <param name="arrayIndex">
        ///           コピーの開始位置とする <paramref name="array" /> のインデックス (0 から始まる)。
        ///         </param>
        // Token: 0x0600083B RID: 2107 RVA: 0x0005837C File Offset: 0x0003837C
        public void CopyTo(T[] array, int arrayIndex)
        {
            if (array == null)
            {
                throw new ArgumentNullException("array");
            }
            if (arrayIndex < 0 || arrayIndex > array.Length)
            {
                throw new ArgumentOutOfRangeException("arrayIndex");
            }
            object parsedValues = this._store.GetParsedValues(this._descriptor);
            if (parsedValues == null)
            {
                return;
            }
            List<object> list = parsedValues as List<object>;
            if (list != null)
            {
                list.CopyTo(array, arrayIndex);
                return;
            }
            if (arrayIndex == array.Length)
            {
                throw new ArgumentException(SR.net_http_copyto_array_too_small);
            }
            array[arrayIndex] = (parsedValues as T);
        }

        /// <summary>
        ///         指定した項目を <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> から削除します。
        ///       </summary>
        /// <param name="item">
        ///           削除する項目。
        ///         </param>
        /// <returns>
        ///         <paramref name="item" /> が <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> インスタンスから削除された場合は <see langword="true" />。それ以外の場合は <see langword="false" />
        ///       </returns>
        // Token: 0x0600083C RID: 2108 RVA: 0x000583FA File Offset: 0x000383FA
        public bool Remove(T item)
        {
            this.CheckValue(item);
            return this._store.RemoveParsedValue(this._descriptor, item);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> を反復処理する列挙子を返します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> インスタンスの列挙子。
        ///       </returns>
        // Token: 0x0600083D RID: 2109 RVA: 0x0005841A File Offset: 0x0003841A
        public IEnumerator<T> GetEnumerator()
        {
            object parsedValues = this._store.GetParsedValues(this._descriptor);
            if (parsedValues == null)
            {
                yield break;
            }
            List<object> list = parsedValues as List<object>;
            if (list == null)
            {
                yield return parsedValues as T;
            }
            else
            {
                foreach (object obj in list)
                {
                    yield return obj as T;
                }
            }
            yield break;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> を反復処理する列挙子を返します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> インスタンスの列挙子。
        ///       </returns>
        // Token: 0x0600083E RID: 2110 RVA: 0x00058429 File Offset: 0x00038429
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> オブジェクトを表す文字列を返します。
        ///          オブジェクト。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x0600083F RID: 2111 RVA: 0x00058431 File Offset: 0x00038431
        public override string ToString()
        {
            return this._store.GetHeaderString(this._descriptor, null);
        }

        // Token: 0x06000840 RID: 2112 RVA: 0x00058445 File Offset: 0x00038445
        internal void SetSpecialValue()
        {
            if (!this._store.ContainsParsedValue(this._descriptor, this._specialValue))
            {
                this._store.AddParsedValue(this._descriptor, this._specialValue);
            }
        }

        // Token: 0x06000841 RID: 2113 RVA: 0x00058481 File Offset: 0x00038481
        internal void RemoveSpecialValue()
        {
            this._store.RemoveParsedValue(this._descriptor, this._specialValue);
        }

        // Token: 0x06000842 RID: 2114 RVA: 0x000584A0 File Offset: 0x000384A0
        private void CheckValue(T item)
        {
            if (item == null)
            {
                throw new ArgumentNullException("item");
            }
            if (this._validator != null)
            {
                this._validator(this, item);
            }
        }

        // Token: 0x06000843 RID: 2115 RVA: 0x000584CC File Offset: 0x000384CC
        private int GetCount()
        {
            object parsedValues = this._store.GetParsedValues(this._descriptor);
            if (parsedValues == null)
            {
                return 0;
            }
            List<object> list = parsedValues as List<object>;
            if (list == null)
            {
                return 1;
            }
            return list.Count;
        }

        // Token: 0x040005D5 RID: 1493
        private HeaderDescriptor _descriptor;

        // Token: 0x040005D6 RID: 1494
        private HttpHeaders _store;

        // Token: 0x040005D7 RID: 1495
        private T _specialValue;

        // Token: 0x040005D8 RID: 1496
        private Action<HttpHeaderValueCollection<T>, T> _validator;
    }

    /// <summary>
    ///         RFC 2616 で定義されている要求ヘッダーのコレクションを表します。
    ///       </summary>
    // Token: 0x02000136 RID: 310
    sealed class HttpRequestHeaders : HttpHeaders
    {
        // Token: 0x0600084B RID: 2123 RVA: 0x00058688 File Offset: 0x00038688
        private T GetSpecializedCollection<T>(int slot, Func<HttpRequestHeaders, T> creationFunc)
        {
            object[] array;
            if ((array = this._specialCollectionsSlots) == null)
            {
                array = (this._specialCollectionsSlots = new object[9]);
            }
            object[] array2 = array;
            object obj = array2[slot];
            if (obj == null)
            {
                obj = (array2[slot] = creationFunc(this));
            }
            return (T)((object)obj);
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Accept" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Accept" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x1700019F RID: 415
        // (get) Token: 0x0600084C RID: 2124 RVA: 0x000586CE File Offset: 0x000386CE
        public HttpHeaderValueCollection<MediaTypeWithQualityHeaderValue> Accept
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<MediaTypeWithQualityHeaderValue>>(0, (HttpRequestHeaders thisRef) => new HttpHeaderValueCollection<MediaTypeWithQualityHeaderValue>(KnownHeaders.Accept.Descriptor, thisRef));
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Accept-Charset" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Accept-Charset" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001A0 RID: 416
        // (get) Token: 0x0600084D RID: 2125 RVA: 0x000586F6 File Offset: 0x000386F6
        public HttpHeaderValueCollection<StringWithQualityHeaderValue> AcceptCharset
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<StringWithQualityHeaderValue>>(1, (HttpRequestHeaders thisRef) => new HttpHeaderValueCollection<StringWithQualityHeaderValue>(KnownHeaders.AcceptCharset.Descriptor, thisRef));
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Accept-Encoding" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Accept-Encoding" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001A1 RID: 417
        // (get) Token: 0x0600084E RID: 2126 RVA: 0x0005871E File Offset: 0x0003871E
        public HttpHeaderValueCollection<StringWithQualityHeaderValue> AcceptEncoding
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<StringWithQualityHeaderValue>>(2, (HttpRequestHeaders thisRef) => new HttpHeaderValueCollection<StringWithQualityHeaderValue>(KnownHeaders.AcceptEncoding.Descriptor, thisRef));
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Accept-Language" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Accept-Language" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001A2 RID: 418
        // (get) Token: 0x0600084F RID: 2127 RVA: 0x00058746 File Offset: 0x00038746
        public HttpHeaderValueCollection<StringWithQualityHeaderValue> AcceptLanguage
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<StringWithQualityHeaderValue>>(3, (HttpRequestHeaders thisRef) => new HttpHeaderValueCollection<StringWithQualityHeaderValue>(KnownHeaders.AcceptLanguage.Descriptor, thisRef));
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Authorization" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Authorization" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001A3 RID: 419
        // (get) Token: 0x06000850 RID: 2128 RVA: 0x0005876E File Offset: 0x0003876E
        // (set) Token: 0x06000851 RID: 2129 RVA: 0x00058785 File Offset: 0x00038785
        public AuthenticationHeaderValue Authorization
        {
            get
            {
                return (AuthenticationHeaderValue)base.GetParsedValues(KnownHeaders.Authorization.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.Authorization.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Expect" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Expect" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001A4 RID: 420
        // (get) Token: 0x06000852 RID: 2130 RVA: 0x00058798 File Offset: 0x00038798
        public HttpHeaderValueCollection<NameValueWithParametersHeaderValue> Expect
        {
            get
            {
                return this.ExpectCore;
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Expect" /> ヘッダーに Continue が含まれているかどうかを示す値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         <see langword="Expect" /> ヘッダーに Continue が含まれる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x170001A5 RID: 421
        // (get) Token: 0x06000853 RID: 2131 RVA: 0x000587A0 File Offset: 0x000387A0
        // (set) Token: 0x06000854 RID: 2132 RVA: 0x000587DC File Offset: 0x000387DC
        public bool? ExpectContinue
        {
            get
            {
                if (this.ExpectCore.IsSpecialValueSet)
                {
                    return new bool?(true);
                }
                if (this._expectContinueSet)
                {
                    return new bool?(false);
                }
                return null;
            }
            set
            {
                if (value == true)
                {
                    this._expectContinueSet = true;
                    this.ExpectCore.SetSpecialValue();
                    return;
                }
                this._expectContinueSet = (value != null);
                this.ExpectCore.RemoveSpecialValue();
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="From" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="From" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001A6 RID: 422
        // (get) Token: 0x06000855 RID: 2133 RVA: 0x0005882E File Offset: 0x0003882E
        // (set) Token: 0x06000856 RID: 2134 RVA: 0x00058845 File Offset: 0x00038845
        public string From
        {
            get
            {
                return (string)base.GetParsedValues(KnownHeaders.From.Descriptor);
            }
            set
            {
                if (value == string.Empty)
                {
                    value = null;
                }
                if (value != null && !HeaderUtilities.IsValidEmailAddress(value))
                {
                    throw new FormatException(SR.net_http_headers_invalid_from_header);
                }
                base.SetOrRemoveParsedValue(KnownHeaders.From.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Host" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Host" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001A7 RID: 423
        // (get) Token: 0x06000857 RID: 2135 RVA: 0x0005887E File Offset: 0x0003887E
        // (set) Token: 0x06000858 RID: 2136 RVA: 0x00058898 File Offset: 0x00038898
        public string Host
        {
            get
            {
                return (string)base.GetParsedValues(KnownHeaders.Host.Descriptor);
            }
            set
            {
                if (value == string.Empty)
                {
                    value = null;
                }
                string text = null;
                if (value != null && HttpRuleParser.GetHostLength(value, 0, false, out text) != value.Length)
                {
                    throw new FormatException(SR.net_http_headers_invalid_host_header);
                }
                base.SetOrRemoveParsedValue(KnownHeaders.Host.Descriptor, value);
            }
        }

        /// <summary>
        ///         値を取得、 <see langword="If-Match" /> HTTP 要求のヘッダー。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> を返します。
        ///
        ///         値、 <see langword="If-Match" /> HTTP 要求のヘッダー。
        ///       </returns>
        // Token: 0x170001A8 RID: 424
        // (get) Token: 0x06000859 RID: 2137 RVA: 0x000588E8 File Offset: 0x000388E8
        public HttpHeaderValueCollection<EntityTagHeaderValue> IfMatch
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<EntityTagHeaderValue>>(5, (HttpRequestHeaders thisRef) => new HttpHeaderValueCollection<EntityTagHeaderValue>(KnownHeaders.IfMatch.Descriptor, thisRef));
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="If-Modified-Since" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="If-Modified-Since" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001A9 RID: 425
        // (get) Token: 0x0600085A RID: 2138 RVA: 0x00058910 File Offset: 0x00038910
        // (set) Token: 0x0600085B RID: 2139 RVA: 0x00058922 File Offset: 0x00038922
        public DateTimeOffset? IfModifiedSince
        {
            get
            {
                return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.IfModifiedSince.Descriptor, this);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.IfModifiedSince.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="If-None-Match" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="If-None-Match" /> ヘッダーの値を取得します。
        ///       </returns>
        // Token: 0x170001AA RID: 426
        // (get) Token: 0x0600085C RID: 2140 RVA: 0x0005893A File Offset: 0x0003893A
        public HttpHeaderValueCollection<EntityTagHeaderValue> IfNoneMatch
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<EntityTagHeaderValue>>(6, (HttpRequestHeaders thisRef) => new HttpHeaderValueCollection<EntityTagHeaderValue>(KnownHeaders.IfNoneMatch.Descriptor, thisRef));
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="If-Range" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="If-Range" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001AB RID: 427
        // (get) Token: 0x0600085D RID: 2141 RVA: 0x00058962 File Offset: 0x00038962
        // (set) Token: 0x0600085E RID: 2142 RVA: 0x00058979 File Offset: 0x00038979
        public RangeConditionHeaderValue IfRange
        {
            get
            {
                return (RangeConditionHeaderValue)base.GetParsedValues(KnownHeaders.IfRange.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.IfRange.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="If-Unmodified-Since" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="If-Unmodified-Since" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001AC RID: 428
        // (get) Token: 0x0600085F RID: 2143 RVA: 0x0005898C File Offset: 0x0003898C
        // (set) Token: 0x06000860 RID: 2144 RVA: 0x0005899E File Offset: 0x0003899E
        public DateTimeOffset? IfUnmodifiedSince
        {
            get
            {
                return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.IfUnmodifiedSince.Descriptor, this);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.IfUnmodifiedSince.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Max-Forwards" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Max-Forwards" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001AD RID: 429
        // (get) Token: 0x06000861 RID: 2145 RVA: 0x000589B8 File Offset: 0x000389B8
        // (set) Token: 0x06000862 RID: 2146 RVA: 0x000589EE File Offset: 0x000389EE
        public int? MaxForwards
        {
            get
            {
                object parsedValues = base.GetParsedValues(KnownHeaders.MaxForwards.Descriptor);
                if (parsedValues != null)
                {
                    return new int?((int)parsedValues);
                }
                return null;
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.MaxForwards.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Proxy-Authorization" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Proxy-Authorization" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001AE RID: 430
        // (get) Token: 0x06000863 RID: 2147 RVA: 0x00058A06 File Offset: 0x00038A06
        // (set) Token: 0x06000864 RID: 2148 RVA: 0x00058A1D File Offset: 0x00038A1D
        public AuthenticationHeaderValue ProxyAuthorization
        {
            get
            {
                return (AuthenticationHeaderValue)base.GetParsedValues(KnownHeaders.ProxyAuthorization.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.ProxyAuthorization.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Range" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Range" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001AF RID: 431
        // (get) Token: 0x06000865 RID: 2149 RVA: 0x00058A30 File Offset: 0x00038A30
        // (set) Token: 0x06000866 RID: 2150 RVA: 0x00058A47 File Offset: 0x00038A47
        public RangeHeaderValue Range
        {
            get
            {
                return (RangeHeaderValue)base.GetParsedValues(KnownHeaders.Range.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.Range.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Referer" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Referer" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001B0 RID: 432
        // (get) Token: 0x06000867 RID: 2151 RVA: 0x00058A5A File Offset: 0x00038A5A
        // (set) Token: 0x06000868 RID: 2152 RVA: 0x00058A71 File Offset: 0x00038A71
        public Uri Referrer
        {
            get
            {
                return (Uri)base.GetParsedValues(KnownHeaders.Referer.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.Referer.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="TE" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="TE" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001B1 RID: 433
        // (get) Token: 0x06000869 RID: 2153 RVA: 0x00058A84 File Offset: 0x00038A84
        public HttpHeaderValueCollection<TransferCodingWithQualityHeaderValue> TE
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<TransferCodingWithQualityHeaderValue>>(7, (HttpRequestHeaders thisRef) => new HttpHeaderValueCollection<TransferCodingWithQualityHeaderValue>(KnownHeaders.TE.Descriptor, thisRef));
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="User-Agent" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="User-Agent" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001B2 RID: 434
        // (get) Token: 0x0600086A RID: 2154 RVA: 0x00058AAC File Offset: 0x00038AAC
        public HttpHeaderValueCollection<ProductInfoHeaderValue> UserAgent
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<ProductInfoHeaderValue>>(8, (HttpRequestHeaders thisRef) => new HttpHeaderValueCollection<ProductInfoHeaderValue>(KnownHeaders.UserAgent.Descriptor, thisRef));
            }
        }

        // Token: 0x170001B3 RID: 435
        // (get) Token: 0x0600086B RID: 2155 RVA: 0x00058AD4 File Offset: 0x00038AD4
        private HttpHeaderValueCollection<NameValueWithParametersHeaderValue> ExpectCore
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<NameValueWithParametersHeaderValue>>(4, (HttpRequestHeaders thisRef) => new HttpHeaderValueCollection<NameValueWithParametersHeaderValue>(KnownHeaders.Expect.Descriptor, thisRef, HeaderUtilities.ExpectContinue));
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Cache-Control" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Cache-Control" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001B4 RID: 436
        // (get) Token: 0x0600086C RID: 2156 RVA: 0x00058AFC File Offset: 0x00038AFC
        // (set) Token: 0x0600086D RID: 2157 RVA: 0x00058B09 File Offset: 0x00038B09
        public CacheControlHeaderValue CacheControl
        {
            get
            {
                return this.GeneralHeaders.CacheControl;
            }
            set
            {
                this.GeneralHeaders.CacheControl = value;
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Connection" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Connection" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001B5 RID: 437
        // (get) Token: 0x0600086E RID: 2158 RVA: 0x00058B17 File Offset: 0x00038B17
        public HttpHeaderValueCollection<string> Connection
        {
            get
            {
                return this.GeneralHeaders.Connection;
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Connection" /> ヘッダーに Close が含まれているかどうかを示す値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         <see langword="Connection" /> ヘッダーに Close が含まれる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x170001B6 RID: 438
        // (get) Token: 0x0600086F RID: 2159 RVA: 0x00058B24 File Offset: 0x00038B24
        // (set) Token: 0x06000870 RID: 2160 RVA: 0x00058B32 File Offset: 0x00038B32
        public bool? ConnectionClose
        {
            get
            {
                return HttpGeneralHeaders.GetConnectionClose(this, this._generalHeaders);
            }
            set
            {
                this.GeneralHeaders.ConnectionClose = value;
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Date" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Date" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001B7 RID: 439
        // (get) Token: 0x06000871 RID: 2161 RVA: 0x00058B40 File Offset: 0x00038B40
        // (set) Token: 0x06000872 RID: 2162 RVA: 0x00058B4D File Offset: 0x00038B4D
        public DateTimeOffset? Date
        {
            get
            {
                return this.GeneralHeaders.Date;
            }
            set
            {
                this.GeneralHeaders.Date = value;
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Pragma" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Pragma" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001B8 RID: 440
        // (get) Token: 0x06000873 RID: 2163 RVA: 0x00058B5B File Offset: 0x00038B5B
        public HttpHeaderValueCollection<NameValueHeaderValue> Pragma
        {
            get
            {
                return this.GeneralHeaders.Pragma;
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Trailer" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Trailer" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001B9 RID: 441
        // (get) Token: 0x06000874 RID: 2164 RVA: 0x00058B68 File Offset: 0x00038B68
        public HttpHeaderValueCollection<string> Trailer
        {
            get
            {
                return this.GeneralHeaders.Trailer;
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Transfer-Encoding" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Transfer-Encoding" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001BA RID: 442
        // (get) Token: 0x06000875 RID: 2165 RVA: 0x00058B75 File Offset: 0x00038B75
        public HttpHeaderValueCollection<TransferCodingHeaderValue> TransferEncoding
        {
            get
            {
                return this.GeneralHeaders.TransferEncoding;
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Transfer-Encoding" /> ヘッダーにチャンクが含まれているかどうかを示す値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         <see langword="Transfer-Encoding" /> ヘッダーにチャンクが含まれる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x170001BB RID: 443
        // (get) Token: 0x06000876 RID: 2166 RVA: 0x00058B82 File Offset: 0x00038B82
        // (set) Token: 0x06000877 RID: 2167 RVA: 0x00058B90 File Offset: 0x00038B90
        public bool? TransferEncodingChunked
        {
            get
            {
                return HttpGeneralHeaders.GetTransferEncodingChunked(this, this._generalHeaders);
            }
            set
            {
                this.GeneralHeaders.TransferEncodingChunked = value;
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Upgrade" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Upgrade" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001BC RID: 444
        // (get) Token: 0x06000878 RID: 2168 RVA: 0x00058B9E File Offset: 0x00038B9E
        public HttpHeaderValueCollection<ProductHeaderValue> Upgrade
        {
            get
            {
                return this.GeneralHeaders.Upgrade;
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Via" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Via" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001BD RID: 445
        // (get) Token: 0x06000879 RID: 2169 RVA: 0x00058BAB File Offset: 0x00038BAB
        public HttpHeaderValueCollection<ViaHeaderValue> Via
        {
            get
            {
                return this.GeneralHeaders.Via;
            }
        }

        /// <summary>
        ///         HTTP 要求の <see langword="Warning" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求の <see langword="Warning" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001BE RID: 446
        // (get) Token: 0x0600087A RID: 2170 RVA: 0x00058BB8 File Offset: 0x00038BB8
        public HttpHeaderValueCollection<WarningHeaderValue> Warning
        {
            get
            {
                return this.GeneralHeaders.Warning;
            }
        }

        // Token: 0x0600087B RID: 2171 RVA: 0x00058BC5 File Offset: 0x00038BC5
        internal HttpRequestHeaders() : base(HttpHeaderType.General | HttpHeaderType.Request | HttpHeaderType.Custom, HttpHeaderType.Response)
        {
        }

        // Token: 0x0600087C RID: 2172 RVA: 0x00058BD0 File Offset: 0x00038BD0
        internal override void AddHeaders(HttpHeaders sourceHeaders)
        {
            base.AddHeaders(sourceHeaders);
            HttpRequestHeaders httpRequestHeaders = sourceHeaders as HttpRequestHeaders;
            if (httpRequestHeaders._generalHeaders != null)
            {
                this.GeneralHeaders.AddSpecialsFrom(httpRequestHeaders._generalHeaders);
            }
            if (this.ExpectContinue == null)
            {
                this.ExpectContinue = httpRequestHeaders.ExpectContinue;
            }
        }

        // Token: 0x170001BF RID: 447
        // (get) Token: 0x0600087D RID: 2173 RVA: 0x00058C20 File Offset: 0x00038C20
        private HttpGeneralHeaders GeneralHeaders
        {
            get
            {
                HttpGeneralHeaders result;
                if ((result = this._generalHeaders) == null)
                {
                    result = (this._generalHeaders = new HttpGeneralHeaders(this));
                }
                return result;
            }
        }

        // Token: 0x040005DD RID: 1501
        private object[] _specialCollectionsSlots;

        // Token: 0x040005DE RID: 1502
        private HttpGeneralHeaders _generalHeaders;

        // Token: 0x040005DF RID: 1503
        private bool _expectContinueSet;
    }

    /// <summary>
    ///         RFC 2616 で定義されている応答ヘッダーのコレクションを表します。
    ///       </summary>
    // Token: 0x02000138 RID: 312
    sealed class HttpResponseHeaders : HttpHeaders
    {
        // Token: 0x06000889 RID: 2185 RVA: 0x00058CFC File Offset: 0x00038CFC
        private T GetSpecializedCollection<T>(int slot, Func<HttpResponseHeaders, T> creationFunc)
        {
            object[] array;
            if ((array = this._specialCollectionsSlots) == null)
            {
                array = (this._specialCollectionsSlots = new object[5]);
            }
            object[] array2 = array;
            object obj = array2[slot];
            if (obj == null)
            {
                obj = (array2[slot] = creationFunc(this));
            }
            return (T)((object)obj);
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Accept-Ranges" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Accept-Ranges" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001C0 RID: 448
        // (get) Token: 0x0600088A RID: 2186 RVA: 0x00058D41 File Offset: 0x00038D41
        public HttpHeaderValueCollection<string> AcceptRanges
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<string>>(0, (HttpResponseHeaders thisRef) => new HttpHeaderValueCollection<string>(KnownHeaders.AcceptRanges.Descriptor, thisRef, HeaderUtilities.TokenValidator));
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Age" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Age" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001C1 RID: 449
        // (get) Token: 0x0600088B RID: 2187 RVA: 0x00058D69 File Offset: 0x00038D69
        // (set) Token: 0x0600088C RID: 2188 RVA: 0x00058D7B File Offset: 0x00038D7B
        public TimeSpan? Age
        {
            get
            {
                return HeaderUtilities.GetTimeSpanValue(KnownHeaders.Age.Descriptor, this);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.Age.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="ETag" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="ETag" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001C2 RID: 450
        // (get) Token: 0x0600088D RID: 2189 RVA: 0x00058D93 File Offset: 0x00038D93
        // (set) Token: 0x0600088E RID: 2190 RVA: 0x00058DAA File Offset: 0x00038DAA
        public EntityTagHeaderValue ETag
        {
            get
            {
                return (EntityTagHeaderValue)base.GetParsedValues(KnownHeaders.ETag.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.ETag.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Location" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Location" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001C3 RID: 451
        // (get) Token: 0x0600088F RID: 2191 RVA: 0x00058DBD File Offset: 0x00038DBD
        // (set) Token: 0x06000890 RID: 2192 RVA: 0x00058DD4 File Offset: 0x00038DD4
        public Uri Location
        {
            get
            {
                return (Uri)base.GetParsedValues(KnownHeaders.Location.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.Location.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Proxy-Authenticate" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Proxy-Authenticate" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001C4 RID: 452
        // (get) Token: 0x06000891 RID: 2193 RVA: 0x00058DE7 File Offset: 0x00038DE7
        public HttpHeaderValueCollection<AuthenticationHeaderValue> ProxyAuthenticate
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<AuthenticationHeaderValue>>(1, (HttpResponseHeaders thisRef) => new HttpHeaderValueCollection<AuthenticationHeaderValue>(KnownHeaders.ProxyAuthenticate.Descriptor, thisRef));
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Retry-After" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Retry-After" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001C5 RID: 453
        // (get) Token: 0x06000892 RID: 2194 RVA: 0x00058E0F File Offset: 0x00038E0F
        // (set) Token: 0x06000893 RID: 2195 RVA: 0x00058E26 File Offset: 0x00038E26
        public RetryConditionHeaderValue RetryAfter
        {
            get
            {
                return (RetryConditionHeaderValue)base.GetParsedValues(KnownHeaders.RetryAfter.Descriptor);
            }
            set
            {
                base.SetOrRemoveParsedValue(KnownHeaders.RetryAfter.Descriptor, value);
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Server" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Server" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001C6 RID: 454
        // (get) Token: 0x06000894 RID: 2196 RVA: 0x00058E39 File Offset: 0x00038E39
        public HttpHeaderValueCollection<ProductInfoHeaderValue> Server
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<ProductInfoHeaderValue>>(2, (HttpResponseHeaders thisRef) => new HttpHeaderValueCollection<ProductInfoHeaderValue>(KnownHeaders.Server.Descriptor, thisRef));
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Vary" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Vary" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001C7 RID: 455
        // (get) Token: 0x06000895 RID: 2197 RVA: 0x00058E61 File Offset: 0x00038E61
        public HttpHeaderValueCollection<string> Vary
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<string>>(3, (HttpResponseHeaders thisRef) => new HttpHeaderValueCollection<string>(KnownHeaders.Vary.Descriptor, thisRef, HeaderUtilities.TokenValidator));
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="WWW-Authenticate" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="WWW-Authenticate" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001C8 RID: 456
        // (get) Token: 0x06000896 RID: 2198 RVA: 0x00058E89 File Offset: 0x00038E89
        public HttpHeaderValueCollection<AuthenticationHeaderValue> WwwAuthenticate
        {
            get
            {
                return this.GetSpecializedCollection<HttpHeaderValueCollection<AuthenticationHeaderValue>>(4, (HttpResponseHeaders thisRef) => new HttpHeaderValueCollection<AuthenticationHeaderValue>(KnownHeaders.WWWAuthenticate.Descriptor, thisRef));
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Cache-Control" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Cache-Control" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001C9 RID: 457
        // (get) Token: 0x06000897 RID: 2199 RVA: 0x00058EB1 File Offset: 0x00038EB1
        // (set) Token: 0x06000898 RID: 2200 RVA: 0x00058EBE File Offset: 0x00038EBE
        public CacheControlHeaderValue CacheControl
        {
            get
            {
                return this.GeneralHeaders.CacheControl;
            }
            set
            {
                this.GeneralHeaders.CacheControl = value;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Connection" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Connection" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001CA RID: 458
        // (get) Token: 0x06000899 RID: 2201 RVA: 0x00058ECC File Offset: 0x00038ECC
        public HttpHeaderValueCollection<string> Connection
        {
            get
            {
                return this.GeneralHeaders.Connection;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Connection" /> ヘッダーに Close が含まれているかどうかを示す値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         <see langword="Connection" /> ヘッダーに Close が含まれる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x170001CB RID: 459
        // (get) Token: 0x0600089A RID: 2202 RVA: 0x00058ED9 File Offset: 0x00038ED9
        // (set) Token: 0x0600089B RID: 2203 RVA: 0x00058EE7 File Offset: 0x00038EE7
        public bool? ConnectionClose
        {
            get
            {
                return HttpGeneralHeaders.GetConnectionClose(this, this._generalHeaders);
            }
            set
            {
                this.GeneralHeaders.ConnectionClose = value;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Date" /> ヘッダーの値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Date" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001CC RID: 460
        // (get) Token: 0x0600089C RID: 2204 RVA: 0x00058EF5 File Offset: 0x00038EF5
        // (set) Token: 0x0600089D RID: 2205 RVA: 0x00058F02 File Offset: 0x00038F02
        public DateTimeOffset? Date
        {
            get
            {
                return this.GeneralHeaders.Date;
            }
            set
            {
                this.GeneralHeaders.Date = value;
            }
        }

        /// <summary>
        ///         値を取得、 <see langword="Pragma" /> HTTP 応答のヘッダー。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.HttpHeaderValueCollection`1" /> を返します。
        ///
        ///         値、 <see langword="Pragma" /> HTTP 応答のヘッダー。
        ///       </returns>
        // Token: 0x170001CD RID: 461
        // (get) Token: 0x0600089E RID: 2206 RVA: 0x00058F10 File Offset: 0x00038F10
        public HttpHeaderValueCollection<NameValueHeaderValue> Pragma
        {
            get
            {
                return this.GeneralHeaders.Pragma;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Trailer" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Trailer" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001CE RID: 462
        // (get) Token: 0x0600089F RID: 2207 RVA: 0x00058F1D File Offset: 0x00038F1D
        public HttpHeaderValueCollection<string> Trailer
        {
            get
            {
                return this.GeneralHeaders.Trailer;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Transfer-Encoding" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Transfer-Encoding" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001CF RID: 463
        // (get) Token: 0x060008A0 RID: 2208 RVA: 0x00058F2A File Offset: 0x00038F2A
        public HttpHeaderValueCollection<TransferCodingHeaderValue> TransferEncoding
        {
            get
            {
                return this.GeneralHeaders.TransferEncoding;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Transfer-Encoding" /> ヘッダーにチャンクが含まれているかどうかを示す値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         <see langword="Transfer-Encoding" /> ヘッダーにチャンクが含まれる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x170001D0 RID: 464
        // (get) Token: 0x060008A1 RID: 2209 RVA: 0x00058F37 File Offset: 0x00038F37
        // (set) Token: 0x060008A2 RID: 2210 RVA: 0x00058F45 File Offset: 0x00038F45
        public bool? TransferEncodingChunked
        {
            get
            {
                return HttpGeneralHeaders.GetTransferEncodingChunked(this, this._generalHeaders);
            }
            set
            {
                this.GeneralHeaders.TransferEncodingChunked = value;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Upgrade" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Upgrade" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001D1 RID: 465
        // (get) Token: 0x060008A3 RID: 2211 RVA: 0x00058F53 File Offset: 0x00038F53
        public HttpHeaderValueCollection<ProductHeaderValue> Upgrade
        {
            get
            {
                return this.GeneralHeaders.Upgrade;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Via" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Via" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001D2 RID: 466
        // (get) Token: 0x060008A4 RID: 2212 RVA: 0x00058F60 File Offset: 0x00038F60
        public HttpHeaderValueCollection<ViaHeaderValue> Via
        {
            get
            {
                return this.GeneralHeaders.Via;
            }
        }

        /// <summary>
        ///         HTTP 応答の <see langword="Warning" /> ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答の <see langword="Warning" /> ヘッダーの値。
        ///       </returns>
        // Token: 0x170001D3 RID: 467
        // (get) Token: 0x060008A5 RID: 2213 RVA: 0x00058F6D File Offset: 0x00038F6D
        public HttpHeaderValueCollection<WarningHeaderValue> Warning
        {
            get
            {
                return this.GeneralHeaders.Warning;
            }
        }

        // Token: 0x060008A6 RID: 2214 RVA: 0x00058F7A File Offset: 0x00038F7A
        internal HttpResponseHeaders() : base(HttpHeaderType.General | HttpHeaderType.Response | HttpHeaderType.Custom, HttpHeaderType.Request)
        {
        }

        // Token: 0x060008A7 RID: 2215 RVA: 0x00058F88 File Offset: 0x00038F88
        internal override void AddHeaders(HttpHeaders sourceHeaders)
        {
            base.AddHeaders(sourceHeaders);
            HttpResponseHeaders httpResponseHeaders = sourceHeaders as HttpResponseHeaders;
            if (httpResponseHeaders._generalHeaders != null)
            {
                this.GeneralHeaders.AddSpecialsFrom(httpResponseHeaders._generalHeaders);
            }
        }

        // Token: 0x170001D4 RID: 468
        // (get) Token: 0x060008A8 RID: 2216 RVA: 0x00058FBC File Offset: 0x00038FBC
        private HttpGeneralHeaders GeneralHeaders
        {
            get
            {
                HttpGeneralHeaders result;
                if ((result = this._generalHeaders) == null)
                {
                    result = (this._generalHeaders = new HttpGeneralHeaders(this));
                }
                return result;
            }
        }

        // Token: 0x040005EA RID: 1514
        private object[] _specialCollectionsSlots;

        // Token: 0x040005EB RID: 1515
        private HttpGeneralHeaders _generalHeaders;
    }


    // Token: 0x0200013A RID: 314
    internal class Int32NumberHeaderParser : BaseHeaderParser
    {
        // Token: 0x060008B0 RID: 2224 RVA: 0x00059052 File Offset: 0x00039052
        private Int32NumberHeaderParser() : base(false)
        {
        }

        // Token: 0x060008B1 RID: 2225 RVA: 0x0005905C File Offset: 0x0003905C
        public override string ToString(object value)
        {
            return ((int)value).ToString(NumberFormatInfo.InvariantInfo);
        }

        // Token: 0x060008B2 RID: 2226 RVA: 0x0005907C File Offset: 0x0003907C
        protected override int GetParsedValueLength(string value, int startIndex, object storeValue, out object parsedValue)
        {
            parsedValue = null;
            int numberLength = HttpRuleParser.GetNumberLength(value, startIndex, false);
            if (numberLength == 0 || numberLength > 10)
            {
                return 0;
            }
            int num = 0;
            if (!HeaderUtilities.TryParseInt32(value, startIndex, numberLength, out num))
            {
                return 0;
            }
            parsedValue = num;
            return numberLength;
        }

        // Token: 0x040005F2 RID: 1522
        internal static readonly Int32NumberHeaderParser Parser = new Int32NumberHeaderParser();
    }


    // Token: 0x0200013B RID: 315
    internal class Int64NumberHeaderParser : BaseHeaderParser
    {
        // Token: 0x060008B4 RID: 2228 RVA: 0x00059052 File Offset: 0x00039052
        private Int64NumberHeaderParser() : base(false)
        {
        }

        // Token: 0x060008B5 RID: 2229 RVA: 0x000590C8 File Offset: 0x000390C8
        public override string ToString(object value)
        {
            return ((long)value).ToString(NumberFormatInfo.InvariantInfo);
        }

        // Token: 0x060008B6 RID: 2230 RVA: 0x000590E8 File Offset: 0x000390E8
        protected override int GetParsedValueLength(string value, int startIndex, object storeValue, out object parsedValue)
        {
            parsedValue = null;
            int numberLength = HttpRuleParser.GetNumberLength(value, startIndex, false);
            if (numberLength == 0 || numberLength > 19)
            {
                return 0;
            }
            long num = 0L;
            if (!HeaderUtilities.TryParseInt64(value, startIndex, numberLength, out num))
            {
                return 0;
            }
            parsedValue = num;
            return numberLength;
        }

        // Token: 0x040005F3 RID: 1523
        internal static readonly Int64NumberHeaderParser Parser = new Int64NumberHeaderParser();
    }


    // Token: 0x02000118 RID: 280
    internal sealed class KnownHeader
    {
        // Token: 0x060006C1 RID: 1729 RVA: 0x00051F10 File Offset: 0x00031F10
        public KnownHeader(string name) : this(name, HttpHeaderType.Custom, null, null)
        {
        }

        // Token: 0x060006C2 RID: 1730 RVA: 0x00051F20 File Offset: 0x00031F20
        public KnownHeader(string name, HttpHeaderType headerType, HttpHeaderParser parser, string[] knownValues = null)
        {
            this._name = name;
            this._headerType = headerType;
            this._parser = parser;
            this._knownValues = knownValues;
            this._asciiBytesWithColonSpace = new byte[name.Length + 2];
            int bytes = Encoding.ASCII.GetBytes(name, this._asciiBytesWithColonSpace);
            this._asciiBytesWithColonSpace[this._asciiBytesWithColonSpace.Length - 2] = 58;
            this._asciiBytesWithColonSpace[this._asciiBytesWithColonSpace.Length - 1] = 32;
        }

        // Token: 0x17000140 RID: 320
        // (get) Token: 0x060006C3 RID: 1731 RVA: 0x00051FA5 File Offset: 0x00031FA5
        public string Name
        {
            get
            {
                return this._name;
            }
        }

        // Token: 0x17000141 RID: 321
        // (get) Token: 0x060006C4 RID: 1732 RVA: 0x00051FAD File Offset: 0x00031FAD
        public HttpHeaderParser Parser
        {
            get
            {
                return this._parser;
            }
        }

        // Token: 0x17000142 RID: 322
        // (get) Token: 0x060006C5 RID: 1733 RVA: 0x00051FB5 File Offset: 0x00031FB5
        public HttpHeaderType HeaderType
        {
            get
            {
                return this._headerType;
            }
        }

        // Token: 0x17000143 RID: 323
        // (get) Token: 0x060006C6 RID: 1734 RVA: 0x00051FBD File Offset: 0x00031FBD
        public string[] KnownValues
        {
            get
            {
                return this._knownValues;
            }
        }

        // Token: 0x17000144 RID: 324
        // (get) Token: 0x060006C7 RID: 1735 RVA: 0x00051FC5 File Offset: 0x00031FC5
        public byte[] AsciiBytesWithColonSpace
        {
            get
            {
                return this._asciiBytesWithColonSpace;
            }
        }

        // Token: 0x17000145 RID: 325
        // (get) Token: 0x060006C8 RID: 1736 RVA: 0x00051FCD File Offset: 0x00031FCD
        public HeaderDescriptor Descriptor
        {
            get
            {
                return new HeaderDescriptor(this);
            }
        }

        // Token: 0x04000506 RID: 1286
        private readonly string _name;

        // Token: 0x04000507 RID: 1287
        private readonly HttpHeaderType _headerType;

        // Token: 0x04000508 RID: 1288
        private readonly HttpHeaderParser _parser;

        // Token: 0x04000509 RID: 1289
        private readonly string[] _knownValues;

        // Token: 0x0400050A RID: 1290
        private readonly byte[] _asciiBytesWithColonSpace;
    }


    // Token: 0x0200011A RID: 282
    internal static class KnownHeaders
    {
        // Token: 0x060006C9 RID: 1737 RVA: 0x00051FD8 File Offset: 0x00031FD8
        private static KnownHeader GetCandidate<T>(T key) where T : struct, KnownHeaders.IHeaderNameAccessor
        {
            switch (key.Length)
            {
                case 2:
                    return KnownHeaders.TE;
                case 3:
                    {
                        char c = key[0];
                        if (c <= 'V')
                        {
                            if (c <= 'P')
                            {
                                if (c != 'A')
                                {
                                    if (c != 'P')
                                    {
                                        break;
                                    }
                                    goto IL_FD;
                                }
                            }
                            else
                            {
                                if (c == 'T')
                                {
                                    goto IL_103;
                                }
                                if (c != 'V')
                                {
                                    break;
                                }
                                goto IL_109;
                            }
                        }
                        else if (c <= 'p')
                        {
                            if (c != 'a')
                            {
                                if (c != 'p')
                                {
                                    break;
                                }
                                goto IL_FD;
                            }
                        }
                        else
                        {
                            if (c == 't')
                            {
                                goto IL_103;
                            }
                            if (c != 'v')
                            {
                                break;
                            }
                            goto IL_109;
                        }
                        return KnownHeaders.Age;
                        IL_FD:
                        return KnownHeaders.P3P;
                        IL_103:
                        return KnownHeaders.TSV;
                        IL_109:
                        return KnownHeaders.Via;
                    }
                case 4:
                    {
                        char c = key[0];
                        if (c <= 'V')
                        {
                            switch (c)
                            {
                                case 'D':
                                    break;
                                case 'E':
                                    goto IL_197;
                                case 'F':
                                    goto IL_19D;
                                case 'G':
                                case 'I':
                                case 'J':
                                case 'K':
                                    goto IL_8C3;
                                case 'H':
                                    goto IL_1A3;
                                case 'L':
                                    goto IL_1A9;
                                default:
                                    if (c != 'V')
                                    {
                                        goto IL_8C3;
                                    }
                                    goto IL_1AF;
                            }
                        }
                        else
                        {
                            switch (c)
                            {
                                case 'd':
                                    break;
                                case 'e':
                                    goto IL_197;
                                case 'f':
                                    goto IL_19D;
                                case 'g':
                                case 'i':
                                case 'j':
                                case 'k':
                                    goto IL_8C3;
                                case 'h':
                                    goto IL_1A3;
                                case 'l':
                                    goto IL_1A9;
                                default:
                                    if (c != 'v')
                                    {
                                        goto IL_8C3;
                                    }
                                    goto IL_1AF;
                            }
                        }
                        return KnownHeaders.Date;
                        IL_197:
                        return KnownHeaders.ETag;
                        IL_19D:
                        return KnownHeaders.From;
                        IL_1A3:
                        return KnownHeaders.Host;
                        IL_1A9:
                        return KnownHeaders.Link;
                        IL_1AF:
                        return KnownHeaders.Vary;
                    }
                case 5:
                    {
                        char c = key[0];
                        if (c <= 'R')
                        {
                            if (c != 'A')
                            {
                                if (c != 'R')
                                {
                                    break;
                                }
                                goto IL_1ED;
                            }
                        }
                        else if (c != 'a')
                        {
                            if (c != 'r')
                            {
                                break;
                            }
                            goto IL_1ED;
                        }
                        return KnownHeaders.Allow;
                        IL_1ED:
                        return KnownHeaders.Range;
                    }
                case 6:
                    {
                        char c = key[0];
                        if (c <= 'S')
                        {
                            switch (c)
                            {
                                case 'A':
                                    break;
                                case 'B':
                                case 'D':
                                    goto IL_8C3;
                                case 'C':
                                    goto IL_28B;
                                case 'E':
                                    goto IL_291;
                                default:
                                    switch (c)
                                    {
                                        case 'O':
                                            goto IL_297;
                                        case 'P':
                                            goto IL_29D;
                                        case 'Q':
                                        case 'R':
                                            goto IL_8C3;
                                        case 'S':
                                            goto IL_2A3;
                                        default:
                                            goto IL_8C3;
                                    }
                                    break;
                            }
                        }
                        else
                        {
                            switch (c)
                            {
                                case 'a':
                                    break;
                                case 'b':
                                case 'd':
                                    goto IL_8C3;
                                case 'c':
                                    goto IL_28B;
                                case 'e':
                                    goto IL_291;
                                default:
                                    switch (c)
                                    {
                                        case 'o':
                                            goto IL_297;
                                        case 'p':
                                            goto IL_29D;
                                        case 'q':
                                        case 'r':
                                            goto IL_8C3;
                                        case 's':
                                            goto IL_2A3;
                                        default:
                                            goto IL_8C3;
                                    }
                                    break;
                            }
                        }
                        return KnownHeaders.Accept;
                        IL_28B:
                        return KnownHeaders.Cookie;
                        IL_291:
                        return KnownHeaders.Expect;
                        IL_297:
                        return KnownHeaders.Origin;
                        IL_29D:
                        return KnownHeaders.Pragma;
                        IL_2A3:
                        return KnownHeaders.Server;
                    }
                case 7:
                    {
                        char c = key[0];
                        if (c <= 'W')
                        {
                            switch (c)
                            {
                                case 'A':
                                    break;
                                case 'B':
                                case 'D':
                                    goto IL_8C3;
                                case 'C':
                                    goto IL_349;
                                case 'E':
                                    goto IL_34F;
                                default:
                                    switch (c)
                                    {
                                        case 'R':
                                            goto IL_355;
                                        case 'S':
                                        case 'V':
                                            goto IL_8C3;
                                        case 'T':
                                            goto IL_35B;
                                        case 'U':
                                            goto IL_361;
                                        case 'W':
                                            goto IL_367;
                                        default:
                                            goto IL_8C3;
                                    }
                                    break;
                            }
                        }
                        else
                        {
                            switch (c)
                            {
                                case 'a':
                                    break;
                                case 'b':
                                case 'd':
                                    goto IL_8C3;
                                case 'c':
                                    goto IL_349;
                                case 'e':
                                    goto IL_34F;
                                default:
                                    switch (c)
                                    {
                                        case 'r':
                                            goto IL_355;
                                        case 's':
                                        case 'v':
                                            goto IL_8C3;
                                        case 't':
                                            goto IL_35B;
                                        case 'u':
                                            goto IL_361;
                                        case 'w':
                                            goto IL_367;
                                        default:
                                            goto IL_8C3;
                                    }
                                    break;
                            }
                        }
                        return KnownHeaders.AltSvc;
                        IL_349:
                        return KnownHeaders.Cookie2;
                        IL_34F:
                        return KnownHeaders.Expires;
                        IL_355:
                        return KnownHeaders.Referer;
                        IL_35B:
                        return KnownHeaders.Trailer;
                        IL_361:
                        return KnownHeaders.Upgrade;
                        IL_367:
                        return KnownHeaders.Warning;
                    }
                case 8:
                    {
                        char c = key[3];
                        if (c <= 'R')
                        {
                            if (c == 'A')
                            {
                                goto IL_3B5;
                            }
                            if (c != 'M')
                            {
                                if (c != 'R')
                                {
                                    break;
                                }
                                goto IL_3AF;
                            }
                        }
                        else
                        {
                            if (c == 'a')
                            {
                                goto IL_3B5;
                            }
                            if (c != 'm')
                            {
                                if (c != 'r')
                                {
                                    break;
                                }
                                goto IL_3AF;
                            }
                        }
                        return KnownHeaders.IfMatch;
                        IL_3AF:
                        return KnownHeaders.IfRange;
                        IL_3B5:
                        return KnownHeaders.Location;
                    }
                case 10:
                    {
                        char c = key[0];
                        if (c <= 'U')
                        {
                            if (c <= 'K')
                            {
                                if (c != 'C')
                                {
                                    if (c != 'K')
                                    {
                                        break;
                                    }
                                    goto IL_41B;
                                }
                            }
                            else
                            {
                                if (c == 'S')
                                {
                                    goto IL_421;
                                }
                                if (c != 'U')
                                {
                                    break;
                                }
                                goto IL_427;
                            }
                        }
                        else if (c <= 'k')
                        {
                            if (c != 'c')
                            {
                                if (c != 'k')
                                {
                                    break;
                                }
                                goto IL_41B;
                            }
                        }
                        else
                        {
                            if (c == 's')
                            {
                                goto IL_421;
                            }
                            if (c != 'u')
                            {
                                break;
                            }
                            goto IL_427;
                        }
                        return KnownHeaders.Connection;
                        IL_41B:
                        return KnownHeaders.KeepAlive;
                        IL_421:
                        return KnownHeaders.SetCookie;
                        IL_427:
                        return KnownHeaders.UserAgent;
                    }
                case 11:
                    {
                        char c = key[0];
                        if (c <= 'S')
                        {
                            if (c != 'C')
                            {
                                if (c == 'R')
                                {
                                    goto IL_46F;
                                }
                                if (c != 'S')
                                {
                                    break;
                                }
                                goto IL_475;
                            }
                        }
                        else if (c != 'c')
                        {
                            if (c == 'r')
                            {
                                goto IL_46F;
                            }
                            if (c != 's')
                            {
                                break;
                            }
                            goto IL_475;
                        }
                        return KnownHeaders.ContentMD5;
                        IL_46F:
                        return KnownHeaders.RetryAfter;
                        IL_475:
                        return KnownHeaders.SetCookie2;
                    }
                case 12:
                    {
                        char c = key[2];
                        if (c <= 'X')
                        {
                            if (c != 'C')
                            {
                                switch (c)
                                {
                                    case 'M':
                                        goto IL_501;
                                    case 'N':
                                        goto IL_4F5;
                                    case 'O':
                                    case 'Q':
                                        goto IL_8C3;
                                    case 'P':
                                        goto IL_507;
                                    case 'R':
                                        goto IL_50D;
                                    default:
                                        if (c != 'X')
                                        {
                                            goto IL_8C3;
                                        }
                                        goto IL_4FB;
                                }
                            }
                        }
                        else if (c != 'c')
                        {
                            switch (c)
                            {
                                case 'm':
                                    goto IL_501;
                                case 'n':
                                    goto IL_4F5;
                                case 'o':
                                case 'q':
                                    goto IL_8C3;
                                case 'p':
                                    goto IL_507;
                                case 'r':
                                    goto IL_50D;
                                default:
                                    if (c != 'x')
                                    {
                                        goto IL_8C3;
                                    }
                                    goto IL_4FB;
                            }
                        }
                        return KnownHeaders.AcceptPatch;
                        IL_4F5:
                        return KnownHeaders.ContentType;
                        IL_4FB:
                        return KnownHeaders.MaxForwards;
                        IL_501:
                        return KnownHeaders.XMSEdgeRef;
                        IL_507:
                        return KnownHeaders.XPoweredBy;
                        IL_50D:
                        return KnownHeaders.XRequestID;
                    }
                case 13:
                    {
                        char c = key[6];
                        if (c > 'S')
                        {
                            if (c <= 'e')
                            {
                                if (c != 'T')
                                {
                                    if (c == 'c')
                                    {
                                        goto IL_59C;
                                    }
                                    if (c != 'e')
                                    {
                                        break;
                                    }
                                    goto IL_5A8;
                                }
                            }
                            else if (c <= 'o')
                            {
                                if (c == 'i')
                                {
                                    goto IL_596;
                                }
                                if (c != 'o')
                                {
                                    break;
                                }
                                goto IL_5AE;
                            }
                            else
                            {
                                if (c == 's')
                                {
                                    goto IL_5B4;
                                }
                                if (c != 't')
                                {
                                    break;
                                }
                            }
                            return KnownHeaders.ContentRange;
                        }
                        if (c <= 'E')
                        {
                            if (c == '-')
                            {
                                return KnownHeaders.AcceptRanges;
                            }
                            if (c == 'C')
                            {
                                goto IL_59C;
                            }
                            if (c != 'E')
                            {
                                break;
                            }
                            goto IL_5A8;
                        }
                        else if (c != 'I')
                        {
                            if (c == 'O')
                            {
                                goto IL_5AE;
                            }
                            if (c != 'S')
                            {
                                break;
                            }
                            goto IL_5B4;
                        }
                        IL_596:
                        return KnownHeaders.Authorization;
                        IL_59C:
                        return KnownHeaders.CacheControl;
                        IL_5A8:
                        return KnownHeaders.IfNoneMatch;
                        IL_5AE:
                        return KnownHeaders.LastModified;
                        IL_5B4:
                        return KnownHeaders.ProxySupport;
                    }
                case 14:
                    {
                        char c = key[0];
                        if (c <= 'C')
                        {
                            if (c != 'A')
                            {
                                if (c != 'C')
                                {
                                    break;
                                }
                                goto IL_5F2;
                            }
                        }
                        else if (c != 'a')
                        {
                            if (c != 'c')
                            {
                                break;
                            }
                            goto IL_5F2;
                        }
                        return KnownHeaders.AcceptCharset;
                        IL_5F2:
                        return KnownHeaders.ContentLength;
                    }
                case 15:
                    {
                        char c = key[7];
                        if (c > 'E')
                        {
                            switch (c)
                            {
                                case 'K':
                                    goto IL_661;
                                case 'L':
                                    goto IL_667;
                                case 'M':
                                    break;
                                default:
                                    if (c == 'e')
                                    {
                                        goto IL_65B;
                                    }
                                    switch (c)
                                    {
                                        case 'k':
                                            goto IL_661;
                                        case 'l':
                                            goto IL_667;
                                        case 'm':
                                            break;
                                        default:
                                            goto IL_8C3;
                                    }
                                    break;
                            }
                            return KnownHeaders.XUACompatible;
                            IL_661:
                            return KnownHeaders.PublicKeyPins;
                            IL_667:
                            return KnownHeaders.AcceptLanguage;
                        }
                        if (c == '-')
                        {
                            return KnownHeaders.XFrameOptions;
                        }
                        if (c != 'E')
                        {
                            break;
                        }
                        IL_65B:
                        return KnownHeaders.AcceptEncoding;
                    }
                case 16:
                    {
                        char c = key[11];
                        if (c <= 'R')
                        {
                            if (c <= 'G')
                            {
                                if (c == 'A')
                                {
                                    goto IL_6E8;
                                }
                                if (c == 'C')
                                {
                                    goto IL_6EE;
                                }
                                if (c != 'G')
                                {
                                    break;
                                }
                                goto IL_6E2;
                            }
                            else
                            {
                                if (c == 'I')
                                {
                                    goto IL_6F4;
                                }
                                if (c != 'O')
                                {
                                    if (c != 'R')
                                    {
                                        break;
                                    }
                                    goto IL_6FA;
                                }
                            }
                        }
                        else if (c <= 'g')
                        {
                            if (c == 'a')
                            {
                                goto IL_6E8;
                            }
                            if (c == 'c')
                            {
                                goto IL_6EE;
                            }
                            if (c != 'g')
                            {
                                break;
                            }
                            goto IL_6E2;
                        }
                        else
                        {
                            if (c == 'i')
                            {
                                goto IL_6F4;
                            }
                            if (c != 'o')
                            {
                                if (c != 'r')
                                {
                                    break;
                                }
                                goto IL_6FA;
                            }
                        }
                        return KnownHeaders.ContentEncoding;
                        IL_6E2:
                        return KnownHeaders.ContentLanguage;
                        IL_6E8:
                        return KnownHeaders.ContentLocation;
                        IL_6EE:
                        return KnownHeaders.ProxyConnection;
                        IL_6F4:
                        return KnownHeaders.WWWAuthenticate;
                        IL_6FA:
                        return KnownHeaders.XAspNetVersion;
                    }
                case 17:
                    {
                        char c = key[0];
                        if (c <= 'T')
                        {
                            if (c != 'I')
                            {
                                if (c == 'S')
                                {
                                    goto IL_742;
                                }
                                if (c != 'T')
                                {
                                    break;
                                }
                                goto IL_748;
                            }
                        }
                        else if (c != 'i')
                        {
                            if (c == 's')
                            {
                                goto IL_742;
                            }
                            if (c != 't')
                            {
                                break;
                            }
                            goto IL_748;
                        }
                        return KnownHeaders.IfModifiedSince;
                        IL_742:
                        return KnownHeaders.SecWebSocketKey;
                        IL_748:
                        return KnownHeaders.TransferEncoding;
                    }
                case 18:
                    {
                        char c = key[0];
                        if (c <= 'X')
                        {
                            if (c != 'P')
                            {
                                if (c != 'X')
                                {
                                    break;
                                }
                                goto IL_786;
                            }
                        }
                        else if (c != 'p')
                        {
                            if (c != 'x')
                            {
                                break;
                            }
                            goto IL_786;
                        }
                        return KnownHeaders.ProxyAuthenticate;
                        IL_786:
                        return KnownHeaders.XContentDuration;
                    }
                case 19:
                    {
                        char c = key[0];
                        if (c <= 'P')
                        {
                            if (c != 'C')
                            {
                                if (c == 'I')
                                {
                                    goto IL_7CE;
                                }
                                if (c != 'P')
                                {
                                    break;
                                }
                                goto IL_7D4;
                            }
                        }
                        else if (c != 'c')
                        {
                            if (c == 'i')
                            {
                                goto IL_7CE;
                            }
                            if (c != 'p')
                            {
                                break;
                            }
                            goto IL_7D4;
                        }
                        return KnownHeaders.ContentDisposition;
                        IL_7CE:
                        return KnownHeaders.IfUnmodifiedSince;
                        IL_7D4:
                        return KnownHeaders.ProxyAuthorization;
                    }
                case 20:
                    return KnownHeaders.SecWebSocketAccept;
                case 21:
                    return KnownHeaders.SecWebSocketVersion;
                case 22:
                    {
                        char c = key[0];
                        if (c <= 'X')
                        {
                            if (c != 'A')
                            {
                                if (c == 'S')
                                {
                                    goto IL_828;
                                }
                                if (c != 'X')
                                {
                                    break;
                                }
                                goto IL_82E;
                            }
                        }
                        else if (c != 'a')
                        {
                            if (c == 's')
                            {
                                goto IL_828;
                            }
                            if (c != 'x')
                            {
                                break;
                            }
                            goto IL_82E;
                        }
                        return KnownHeaders.AccessControlMaxAge;
                        IL_828:
                        return KnownHeaders.SecWebSocketProtocol;
                        IL_82E:
                        return KnownHeaders.XContentTypeOptions;
                    }
                case 23:
                    return KnownHeaders.ContentSecurityPolicy;
                case 24:
                    return KnownHeaders.SecWebSocketExtensions;
                case 25:
                    {
                        char c = key[0];
                        if (c <= 'U')
                        {
                            if (c != 'S')
                            {
                                if (c != 'U')
                                {
                                    break;
                                }
                                goto IL_872;
                            }
                        }
                        else if (c != 's')
                        {
                            if (c != 'u')
                            {
                                break;
                            }
                            goto IL_872;
                        }
                        return KnownHeaders.StrictTransportSecurity;
                        IL_872:
                        return KnownHeaders.UpgradeInsecureRequests;
                    }
                case 27:
                    return KnownHeaders.AccessControlAllowOrigin;
                case 28:
                    {
                        char c = key[21];
                        if (c <= 'M')
                        {
                            if (c != 'H')
                            {
                                if (c != 'M')
                                {
                                    break;
                                }
                                goto IL_8B1;
                            }
                        }
                        else if (c != 'h')
                        {
                            if (c != 'm')
                            {
                                break;
                            }
                            goto IL_8B1;
                        }
                        return KnownHeaders.AccessControlAllowHeaders;
                        IL_8B1:
                        return KnownHeaders.AccessControlAllowMethods;
                    }
                case 29:
                    return KnownHeaders.AccessControlExposeHeaders;
                case 32:
                    return KnownHeaders.AccessControlAllowCredentials;
            }
            IL_8C3:
            return null;
        }

        // Token: 0x060006CA RID: 1738 RVA: 0x000528AC File Offset: 0x000328AC
        internal static KnownHeader TryGetKnownHeader(string name)
        {
            KnownHeader candidate = KnownHeaders.GetCandidate<KnownHeaders.StringAccessor>(new KnownHeaders.StringAccessor(name));
            if (candidate != null && StringComparer.OrdinalIgnoreCase.Equals(name, candidate.Name))
            {
                return candidate;
            }
            return null;
        }

        // Token: 0x060006CB RID: 1739 RVA: 0x000528E0 File Offset: 0x000328E0
        internal unsafe static KnownHeader TryGetKnownHeader(ReadOnlySpan<byte> name)
        {
            fixed (byte* reference = &name[0])
            {
                byte* p = reference;
                KnownHeader candidate = KnownHeaders.GetCandidate<KnownHeaders.BytePtrAccessor>(new KnownHeaders.BytePtrAccessor(p, name.Length));
                if (candidate != null && ByteArrayHelpers.EqualsOrdinalAsciiIgnoreCase(candidate.Name, name))
                {
                    return candidate;
                }
            }
            return null;
        }

        // Token: 0x04000513 RID: 1299
        public static readonly KnownHeader Accept = new KnownHeader("Accept", HttpHeaderType.Request, MediaTypeHeaderParser.MultipleValuesParser, null);

        // Token: 0x04000514 RID: 1300
        public static readonly KnownHeader AcceptCharset = new KnownHeader("Accept-Charset", HttpHeaderType.Request, GenericHeaderParser.MultipleValueStringWithQualityParser, null);

        // Token: 0x04000515 RID: 1301
        public static readonly KnownHeader AcceptEncoding = new KnownHeader("Accept-Encoding", HttpHeaderType.Request, GenericHeaderParser.MultipleValueStringWithQualityParser, null);

        // Token: 0x04000516 RID: 1302
        public static readonly KnownHeader AcceptLanguage = new KnownHeader("Accept-Language", HttpHeaderType.Request, GenericHeaderParser.MultipleValueStringWithQualityParser, null);

        // Token: 0x04000517 RID: 1303
        public static readonly KnownHeader AcceptPatch = new KnownHeader("Accept-Patch");

        // Token: 0x04000518 RID: 1304
        public static readonly KnownHeader AcceptRanges = new KnownHeader("Accept-Ranges", HttpHeaderType.Response, GenericHeaderParser.TokenListParser, null);

        // Token: 0x04000519 RID: 1305
        public static readonly KnownHeader AccessControlAllowCredentials = new KnownHeader("Access-Control-Allow-Credentials");

        // Token: 0x0400051A RID: 1306
        public static readonly KnownHeader AccessControlAllowHeaders = new KnownHeader("Access-Control-Allow-Headers");

        // Token: 0x0400051B RID: 1307
        public static readonly KnownHeader AccessControlAllowMethods = new KnownHeader("Access-Control-Allow-Methods");

        // Token: 0x0400051C RID: 1308
        public static readonly KnownHeader AccessControlAllowOrigin = new KnownHeader("Access-Control-Allow-Origin");

        // Token: 0x0400051D RID: 1309
        public static readonly KnownHeader AccessControlExposeHeaders = new KnownHeader("Access-Control-Expose-Headers");

        // Token: 0x0400051E RID: 1310
        public static readonly KnownHeader AccessControlMaxAge = new KnownHeader("Access-Control-Max-Age");

        // Token: 0x0400051F RID: 1311
        public static readonly KnownHeader Age = new KnownHeader("Age", HttpHeaderType.Response, TimeSpanHeaderParser.Parser, null);

        // Token: 0x04000520 RID: 1312
        public static readonly KnownHeader Allow = new KnownHeader("Allow", HttpHeaderType.Content, GenericHeaderParser.TokenListParser, null);

        // Token: 0x04000521 RID: 1313
        public static readonly KnownHeader AltSvc = new KnownHeader("Alt-Svc");

        // Token: 0x04000522 RID: 1314
        public static readonly KnownHeader Authorization = new KnownHeader("Authorization", HttpHeaderType.Request, GenericHeaderParser.SingleValueAuthenticationParser, null);

        // Token: 0x04000523 RID: 1315
        public static readonly KnownHeader CacheControl = new KnownHeader("Cache-Control", HttpHeaderType.General, CacheControlHeaderParser.Parser, null);

        // Token: 0x04000524 RID: 1316
        public static readonly KnownHeader Connection = new KnownHeader("Connection", HttpHeaderType.General, GenericHeaderParser.TokenListParser, new string[]
        {
            "close"
        });

        // Token: 0x04000525 RID: 1317
        public static readonly KnownHeader ContentDisposition = new KnownHeader("Content-Disposition", HttpHeaderType.Content, GenericHeaderParser.ContentDispositionParser, null);

        // Token: 0x04000526 RID: 1318
        public static readonly KnownHeader ContentEncoding = new KnownHeader("Content-Encoding", HttpHeaderType.Content, GenericHeaderParser.TokenListParser, new string[]
        {
            "gzip",
            "deflate"
        });

        // Token: 0x04000527 RID: 1319
        public static readonly KnownHeader ContentLanguage = new KnownHeader("Content-Language", HttpHeaderType.Content, GenericHeaderParser.TokenListParser, null);

        // Token: 0x04000528 RID: 1320
        public static readonly KnownHeader ContentLength = new KnownHeader("Content-Length", HttpHeaderType.Content, Int64NumberHeaderParser.Parser, null);

        // Token: 0x04000529 RID: 1321
        public static readonly KnownHeader ContentLocation = new KnownHeader("Content-Location", HttpHeaderType.Content, UriHeaderParser.RelativeOrAbsoluteUriParser, null);

        // Token: 0x0400052A RID: 1322
        public static readonly KnownHeader ContentMD5 = new KnownHeader("Content-MD5", HttpHeaderType.Content, ByteArrayHeaderParser.Parser, null);

        // Token: 0x0400052B RID: 1323
        public static readonly KnownHeader ContentRange = new KnownHeader("Content-Range", HttpHeaderType.Content, GenericHeaderParser.ContentRangeParser, null);

        // Token: 0x0400052C RID: 1324
        public static readonly KnownHeader ContentSecurityPolicy = new KnownHeader("Content-Security-Policy");

        // Token: 0x0400052D RID: 1325
        public static readonly KnownHeader ContentType = new KnownHeader("Content-Type", HttpHeaderType.Content, MediaTypeHeaderParser.SingleValueParser, null);

        // Token: 0x0400052E RID: 1326
        public static readonly KnownHeader Cookie = new KnownHeader("Cookie");

        // Token: 0x0400052F RID: 1327
        public static readonly KnownHeader Cookie2 = new KnownHeader("Cookie2");

        // Token: 0x04000530 RID: 1328
        public static readonly KnownHeader Date = new KnownHeader("Date", HttpHeaderType.General, DateHeaderParser.Parser, null);

        // Token: 0x04000531 RID: 1329
        public static readonly KnownHeader ETag = new KnownHeader("ETag", HttpHeaderType.Response, GenericHeaderParser.SingleValueEntityTagParser, null);

        // Token: 0x04000532 RID: 1330
        public static readonly KnownHeader Expect = new KnownHeader("Expect", HttpHeaderType.Request, GenericHeaderParser.MultipleValueNameValueWithParametersParser, new string[]
        {
            "100-continue"
        });

        // Token: 0x04000533 RID: 1331
        public static readonly KnownHeader Expires = new KnownHeader("Expires", HttpHeaderType.Content, DateHeaderParser.Parser, null);

        // Token: 0x04000534 RID: 1332
        public static readonly KnownHeader From = new KnownHeader("From", HttpHeaderType.Request, GenericHeaderParser.MailAddressParser, null);

        // Token: 0x04000535 RID: 1333
        public static readonly KnownHeader Host = new KnownHeader("Host", HttpHeaderType.Request, GenericHeaderParser.HostParser, null);

        // Token: 0x04000536 RID: 1334
        public static readonly KnownHeader IfMatch = new KnownHeader("If-Match", HttpHeaderType.Request, GenericHeaderParser.MultipleValueEntityTagParser, null);

        // Token: 0x04000537 RID: 1335
        public static readonly KnownHeader IfModifiedSince = new KnownHeader("If-Modified-Since", HttpHeaderType.Request, DateHeaderParser.Parser, null);

        // Token: 0x04000538 RID: 1336
        public static readonly KnownHeader IfNoneMatch = new KnownHeader("If-None-Match", HttpHeaderType.Request, GenericHeaderParser.MultipleValueEntityTagParser, null);

        // Token: 0x04000539 RID: 1337
        public static readonly KnownHeader IfRange = new KnownHeader("If-Range", HttpHeaderType.Request, GenericHeaderParser.RangeConditionParser, null);

        // Token: 0x0400053A RID: 1338
        public static readonly KnownHeader IfUnmodifiedSince = new KnownHeader("If-Unmodified-Since", HttpHeaderType.Request, DateHeaderParser.Parser, null);

        // Token: 0x0400053B RID: 1339
        public static readonly KnownHeader KeepAlive = new KnownHeader("Keep-Alive");

        // Token: 0x0400053C RID: 1340
        public static readonly KnownHeader LastModified = new KnownHeader("Last-Modified", HttpHeaderType.Content, DateHeaderParser.Parser, null);

        // Token: 0x0400053D RID: 1341
        public static readonly KnownHeader Link = new KnownHeader("Link");

        // Token: 0x0400053E RID: 1342
        public static readonly KnownHeader Location = new KnownHeader("Location", HttpHeaderType.Response, UriHeaderParser.RelativeOrAbsoluteUriParser, null);

        // Token: 0x0400053F RID: 1343
        public static readonly KnownHeader MaxForwards = new KnownHeader("Max-Forwards", HttpHeaderType.Request, Int32NumberHeaderParser.Parser, null);

        // Token: 0x04000540 RID: 1344
        public static readonly KnownHeader Origin = new KnownHeader("Origin");

        // Token: 0x04000541 RID: 1345
        public static readonly KnownHeader P3P = new KnownHeader("P3P");

        // Token: 0x04000542 RID: 1346
        public static readonly KnownHeader Pragma = new KnownHeader("Pragma", HttpHeaderType.General, GenericHeaderParser.MultipleValueNameValueParser, null);

        // Token: 0x04000543 RID: 1347
        public static readonly KnownHeader ProxyAuthenticate = new KnownHeader("Proxy-Authenticate", HttpHeaderType.Response, GenericHeaderParser.MultipleValueAuthenticationParser, null);

        // Token: 0x04000544 RID: 1348
        public static readonly KnownHeader ProxyAuthorization = new KnownHeader("Proxy-Authorization", HttpHeaderType.Request, GenericHeaderParser.SingleValueAuthenticationParser, null);

        // Token: 0x04000545 RID: 1349
        public static readonly KnownHeader ProxyConnection = new KnownHeader("Proxy-Connection");

        // Token: 0x04000546 RID: 1350
        public static readonly KnownHeader ProxySupport = new KnownHeader("Proxy-Support");

        // Token: 0x04000547 RID: 1351
        public static readonly KnownHeader PublicKeyPins = new KnownHeader("Public-Key-Pins");

        // Token: 0x04000548 RID: 1352
        public static readonly KnownHeader Range = new KnownHeader("Range", HttpHeaderType.Request, GenericHeaderParser.RangeParser, null);

        // Token: 0x04000549 RID: 1353
        public static readonly KnownHeader Referer = new KnownHeader("Referer", HttpHeaderType.Request, UriHeaderParser.RelativeOrAbsoluteUriParser, null);

        // Token: 0x0400054A RID: 1354
        public static readonly KnownHeader RetryAfter = new KnownHeader("Retry-After", HttpHeaderType.Response, GenericHeaderParser.RetryConditionParser, null);

        // Token: 0x0400054B RID: 1355
        public static readonly KnownHeader SecWebSocketAccept = new KnownHeader("Sec-WebSocket-Accept");

        // Token: 0x0400054C RID: 1356
        public static readonly KnownHeader SecWebSocketExtensions = new KnownHeader("Sec-WebSocket-Extensions");

        // Token: 0x0400054D RID: 1357
        public static readonly KnownHeader SecWebSocketKey = new KnownHeader("Sec-WebSocket-Key");

        // Token: 0x0400054E RID: 1358
        public static readonly KnownHeader SecWebSocketProtocol = new KnownHeader("Sec-WebSocket-Protocol");

        // Token: 0x0400054F RID: 1359
        public static readonly KnownHeader SecWebSocketVersion = new KnownHeader("Sec-WebSocket-Version");

        // Token: 0x04000550 RID: 1360
        public static readonly KnownHeader Server = new KnownHeader("Server", HttpHeaderType.Response, ProductInfoHeaderParser.MultipleValueParser, null);

        // Token: 0x04000551 RID: 1361
        public static readonly KnownHeader SetCookie = new KnownHeader("Set-Cookie");

        // Token: 0x04000552 RID: 1362
        public static readonly KnownHeader SetCookie2 = new KnownHeader("Set-Cookie2");

        // Token: 0x04000553 RID: 1363
        public static readonly KnownHeader StrictTransportSecurity = new KnownHeader("Strict-Transport-Security");

        // Token: 0x04000554 RID: 1364
        public static readonly KnownHeader TE = new KnownHeader("TE", HttpHeaderType.Request, TransferCodingHeaderParser.MultipleValueWithQualityParser, null);

        // Token: 0x04000555 RID: 1365
        public static readonly KnownHeader TSV = new KnownHeader("TSV");

        // Token: 0x04000556 RID: 1366
        public static readonly KnownHeader Trailer = new KnownHeader("Trailer", HttpHeaderType.General, GenericHeaderParser.TokenListParser, null);

        // Token: 0x04000557 RID: 1367
        public static readonly KnownHeader TransferEncoding = new KnownHeader("Transfer-Encoding", HttpHeaderType.General, TransferCodingHeaderParser.MultipleValueParser, new string[]
        {
            "chunked"
        });

        // Token: 0x04000558 RID: 1368
        public static readonly KnownHeader Upgrade = new KnownHeader("Upgrade", HttpHeaderType.General, GenericHeaderParser.MultipleValueProductParser, null);

        // Token: 0x04000559 RID: 1369
        public static readonly KnownHeader UpgradeInsecureRequests = new KnownHeader("Upgrade-Insecure-Requests");

        // Token: 0x0400055A RID: 1370
        public static readonly KnownHeader UserAgent = new KnownHeader("User-Agent", HttpHeaderType.Request, ProductInfoHeaderParser.MultipleValueParser, null);

        // Token: 0x0400055B RID: 1371
        public static readonly KnownHeader Vary = new KnownHeader("Vary", HttpHeaderType.Response, GenericHeaderParser.TokenListParser, null);

        // Token: 0x0400055C RID: 1372
        public static readonly KnownHeader Via = new KnownHeader("Via", HttpHeaderType.General, GenericHeaderParser.MultipleValueViaParser, null);

        // Token: 0x0400055D RID: 1373
        public static readonly KnownHeader WWWAuthenticate = new KnownHeader("WWW-Authenticate", HttpHeaderType.Response, GenericHeaderParser.MultipleValueAuthenticationParser, null);

        // Token: 0x0400055E RID: 1374
        public static readonly KnownHeader Warning = new KnownHeader("Warning", HttpHeaderType.General, GenericHeaderParser.MultipleValueWarningParser, null);

        // Token: 0x0400055F RID: 1375
        public static readonly KnownHeader XAspNetVersion = new KnownHeader("X-AspNet-Version");

        // Token: 0x04000560 RID: 1376
        public static readonly KnownHeader XContentDuration = new KnownHeader("X-Content-Duration");

        // Token: 0x04000561 RID: 1377
        public static readonly KnownHeader XContentTypeOptions = new KnownHeader("X-Content-Type-Options");

        // Token: 0x04000562 RID: 1378
        public static readonly KnownHeader XFrameOptions = new KnownHeader("X-Frame-Options");

        // Token: 0x04000563 RID: 1379
        public static readonly KnownHeader XMSEdgeRef = new KnownHeader("X-MSEdge-Ref");

        // Token: 0x04000564 RID: 1380
        public static readonly KnownHeader XPoweredBy = new KnownHeader("X-Powered-By");

        // Token: 0x04000565 RID: 1381
        public static readonly KnownHeader XRequestID = new KnownHeader("X-Request-ID");

        // Token: 0x04000566 RID: 1382
        public static readonly KnownHeader XUACompatible = new KnownHeader("X-UA-Compatible");

        // Token: 0x0200011B RID: 283
        private interface IHeaderNameAccessor
        {
            // Token: 0x17000146 RID: 326
            // (get) Token: 0x060006CD RID: 1741
            int Length { get; }

            // Token: 0x17000147 RID: 327
            char this[int index]
            {
                get;
            }
        }

        // Token: 0x0200011C RID: 284
        private readonly struct StringAccessor : KnownHeaders.IHeaderNameAccessor
        {
            // Token: 0x060006CF RID: 1743 RVA: 0x00052FA9 File Offset: 0x00032FA9
            public StringAccessor(string s)
            {
                this._string = s;
            }

            // Token: 0x17000148 RID: 328
            // (get) Token: 0x060006D0 RID: 1744 RVA: 0x00052FB2 File Offset: 0x00032FB2
            public int Length
            {
                get
                {
                    return this._string.Length;
                }
            }

            // Token: 0x17000149 RID: 329
            public char this[int index]
            {
                get
                {
                    return this._string[index];
                }
            }

            // Token: 0x04000567 RID: 1383
            private readonly string _string;
        }

        // Token: 0x0200011D RID: 285
        private readonly struct BytePtrAccessor : KnownHeaders.IHeaderNameAccessor
        {
            // Token: 0x060006D2 RID: 1746 RVA: 0x00052FCD File Offset: 0x00032FCD
            public unsafe BytePtrAccessor(byte* p, int length)
            {
                this._p = p;
                this._length = length;
            }

            // Token: 0x1700014A RID: 330
            // (get) Token: 0x060006D3 RID: 1747 RVA: 0x00052FDD File Offset: 0x00032FDD
            public int Length
            {
                get
                {
                    return this._length;
                }
            }

            // Token: 0x1700014B RID: 331
            public unsafe char this[int index]
            {
                get
                {
                    return (char)this._p[index];
                }
            }

            // Token: 0x04000568 RID: 1384
            private unsafe readonly byte* _p;

            // Token: 0x04000569 RID: 1385
            private readonly int _length;
        }
    }


    // Token: 0x0200013C RID: 316
    internal class MediaTypeHeaderParser : BaseHeaderParser
    {
        // Token: 0x060008B8 RID: 2232 RVA: 0x00059133 File Offset: 0x00039133
        private MediaTypeHeaderParser(bool supportsMultipleValues, Func<MediaTypeHeaderValue> mediaTypeCreator) : base(supportsMultipleValues)
        {
            this._supportsMultipleValues = supportsMultipleValues;
            this._mediaTypeCreator = mediaTypeCreator;
        }

        // Token: 0x060008B9 RID: 2233 RVA: 0x0005914C File Offset: 0x0003914C
        protected override int GetParsedValueLength(string value, int startIndex, object storeValue, out object parsedValue)
        {
            MediaTypeHeaderValue mediaTypeHeaderValue = null;
            int mediaTypeLength = MediaTypeHeaderValue.GetMediaTypeLength(value, startIndex, this._mediaTypeCreator, out mediaTypeHeaderValue);
            parsedValue = mediaTypeHeaderValue;
            return mediaTypeLength;
        }

        // Token: 0x060008BA RID: 2234 RVA: 0x00059170 File Offset: 0x00039170
        private static MediaTypeHeaderValue CreateMediaType()
        {
            return new MediaTypeHeaderValue();
        }

        // Token: 0x060008BB RID: 2235 RVA: 0x00059177 File Offset: 0x00039177
        private static MediaTypeHeaderValue CreateMediaTypeWithQuality()
        {
            return new MediaTypeWithQualityHeaderValue();
        }

        // Token: 0x040005F4 RID: 1524
        private bool _supportsMultipleValues;

        // Token: 0x040005F5 RID: 1525
        private Func<MediaTypeHeaderValue> _mediaTypeCreator;

        // Token: 0x040005F6 RID: 1526
        internal static readonly MediaTypeHeaderParser SingleValueParser = new MediaTypeHeaderParser(false, new Func<MediaTypeHeaderValue>(MediaTypeHeaderParser.CreateMediaType));

        // Token: 0x040005F7 RID: 1527
        internal static readonly MediaTypeHeaderParser SingleValueWithQualityParser = new MediaTypeHeaderParser(false, new Func<MediaTypeHeaderValue>(MediaTypeHeaderParser.CreateMediaTypeWithQuality));

        // Token: 0x040005F8 RID: 1528
        internal static readonly MediaTypeHeaderParser MultipleValuesParser = new MediaTypeHeaderParser(true, new Func<MediaTypeHeaderValue>(MediaTypeHeaderParser.CreateMediaTypeWithQuality));
    }

    /// <summary>
    ///         RFC 2616 で定義されているコンテンツ タイプ ヘッダーで使用されるメディアの種類を表します。
    ///       </summary>
    // Token: 0x0200013D RID: 317
    class MediaTypeHeaderValue : ICloneable
    {
        /// <summary>
        ///         文字セットを取得または設定します。
        ///       </summary>
        /// <returns>
        ///         文字セット。
        ///       </returns>
        // Token: 0x170001D5 RID: 469
        // (get) Token: 0x060008BD RID: 2237 RVA: 0x000591D4 File Offset: 0x000391D4
        // (set) Token: 0x060008BE RID: 2238 RVA: 0x00059200 File Offset: 0x00039200
        public string CharSet
        {
            get
            {
                NameValueHeaderValue nameValueHeaderValue = NameValueHeaderValue.Find(this._parameters, "charset");
                if (nameValueHeaderValue != null)
                {
                    return nameValueHeaderValue.Value;
                }
                return null;
            }
            set
            {
                NameValueHeaderValue nameValueHeaderValue = NameValueHeaderValue.Find(this._parameters, "charset");
                if (string.IsNullOrEmpty(value))
                {
                    if (nameValueHeaderValue != null)
                    {
                        this._parameters.Remove(nameValueHeaderValue);
                        return;
                    }
                }
                else
                {
                    if (nameValueHeaderValue != null)
                    {
                        nameValueHeaderValue.Value = value;
                        return;
                    }
                    this.Parameters.Add(new NameValueHeaderValue("charset", value));
                }
            }
        }

        /// <summary>
        ///         media-type ヘッダー値のパラメーターを取得または設定します。
        ///       </summary>
        /// <returns>
        ///         media-type ヘッダー値のパラメーター。
        ///       </returns>
        // Token: 0x170001D6 RID: 470
        // (get) Token: 0x060008BF RID: 2239 RVA: 0x00059258 File Offset: 0x00039258
        public ICollection<NameValueHeaderValue> Parameters
        {
            get
            {
                if (this._parameters == null)
                {
                    this._parameters = new ObjectCollection<NameValueHeaderValue>();
                }
                return this._parameters;
            }
        }

        /// <summary>
        ///         media-type のヘッダー値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         media-type のヘッダー値。
        ///       </returns>
        // Token: 0x170001D7 RID: 471
        // (get) Token: 0x060008C0 RID: 2240 RVA: 0x00059273 File Offset: 0x00039273
        // (set) Token: 0x060008C1 RID: 2241 RVA: 0x0005927B File Offset: 0x0003927B
        public string MediaType
        {
            get
            {
                return this._mediaType;
            }
            set
            {
                MediaTypeHeaderValue.CheckMediaTypeFormat(value, "value");
                this._mediaType = value;
            }
        }

        // Token: 0x060008C2 RID: 2242 RVA: 0x00035094 File Offset: 0x00015094
        internal MediaTypeHeaderValue()
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="source">
        ///            A <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> オブジェクトの新しいインスタンスを初期化するために使用します。
        ///         </param>
        // Token: 0x060008C3 RID: 2243 RVA: 0x00059290 File Offset: 0x00039290
        protected MediaTypeHeaderValue(MediaTypeHeaderValue source)
        {
            this._mediaType = source._mediaType;
            if (source._parameters != null)
            {
                foreach (NameValueHeaderValue nameValueHeaderValue in source._parameters)
                {
                    this.Parameters.Add((NameValueHeaderValue)((ICloneable)nameValueHeaderValue).Clone());
                }
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="mediaType">
        ///           新しいインスタンスを初期化するために、文字列として表現されるソース。
        ///         </param>
        // Token: 0x060008C4 RID: 2244 RVA: 0x0005930C File Offset: 0x0003930C
        public MediaTypeHeaderValue(string mediaType)
        {
            MediaTypeHeaderValue.CheckMediaTypeFormat(mediaType, "mediaType");
            this._mediaType = mediaType;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x060008C5 RID: 2245 RVA: 0x00059328 File Offset: 0x00039328
        public override string ToString()
        {
            StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
            stringBuilder.Append(this._mediaType);
            NameValueHeaderValue.ToString(this._parameters, ';', true, stringBuilder);
            return StringBuilderCache.GetStringAndRelease(stringBuilder);
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060008C6 RID: 2246 RVA: 0x00059360 File Offset: 0x00039360
        public override bool Equals(object obj)
        {
            MediaTypeHeaderValue mediaTypeHeaderValue = obj as MediaTypeHeaderValue;
            return mediaTypeHeaderValue != null && string.Equals(this._mediaType, mediaTypeHeaderValue._mediaType, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections<NameValueHeaderValue>(this._parameters, mediaTypeHeaderValue._parameters);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x060008C7 RID: 2247 RVA: 0x000593A0 File Offset: 0x000393A0
        public override int GetHashCode()
        {
            return StringComparer.OrdinalIgnoreCase.GetHashCode(this._mediaType) ^ NameValueHeaderValue.GetHashCode(this._parameters);
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           メディアの種類のヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は、有効なメディアの種類のヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x060008C8 RID: 2248 RVA: 0x000593C0 File Offset: 0x000393C0
        public static MediaTypeHeaderValue Parse(string input)
        {
            int num = 0;
            return (MediaTypeHeaderValue)MediaTypeHeaderParser.SingleValueParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060008C9 RID: 2249 RVA: 0x000593E4 File Offset: 0x000393E4
        public static bool TryParse(string input, out MediaTypeHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (MediaTypeHeaderParser.SingleValueParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (MediaTypeHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x060008CA RID: 2250 RVA: 0x00059414 File Offset: 0x00039414
        internal static int GetMediaTypeLength(string input, int startIndex, Func<MediaTypeHeaderValue> mediaTypeCreator, out MediaTypeHeaderValue parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            string mediaType = null;
            int mediaTypeExpressionLength = MediaTypeHeaderValue.GetMediaTypeExpressionLength(input, startIndex, out mediaType);
            if (mediaTypeExpressionLength == 0)
            {
                return 0;
            }
            int num = startIndex + mediaTypeExpressionLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            MediaTypeHeaderValue mediaTypeHeaderValue;
            if (num >= input.Length || input[num] != ';')
            {
                mediaTypeHeaderValue = mediaTypeCreator();
                mediaTypeHeaderValue._mediaType = mediaType;
                parsedValue = mediaTypeHeaderValue;
                return num - startIndex;
            }
            mediaTypeHeaderValue = mediaTypeCreator();
            mediaTypeHeaderValue._mediaType = mediaType;
            num++;
            int nameValueListLength = NameValueHeaderValue.GetNameValueListLength(input, num, ';', (ObjectCollection<NameValueHeaderValue>)mediaTypeHeaderValue.Parameters);
            if (nameValueListLength == 0)
            {
                return 0;
            }
            parsedValue = mediaTypeHeaderValue;
            return num + nameValueListLength - startIndex;
        }

        // Token: 0x060008CB RID: 2251 RVA: 0x000594B8 File Offset: 0x000394B8
        private static int GetMediaTypeExpressionLength(string input, int startIndex, out string mediaType)
        {
            mediaType = null;
            int tokenLength = HttpRuleParser.GetTokenLength(input, startIndex);
            if (tokenLength == 0)
            {
                return 0;
            }
            int num = startIndex + tokenLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            if (num >= input.Length || input[num] != '/')
            {
                return 0;
            }
            num++;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            int tokenLength2 = HttpRuleParser.GetTokenLength(input, num);
            if (tokenLength2 == 0)
            {
                return 0;
            }
            int num2 = num + tokenLength2 - startIndex;
            if (tokenLength + tokenLength2 + 1 == num2)
            {
                mediaType = input.Substring(startIndex, num2);
            }
            else
            {
                mediaType = input.Substring(startIndex, tokenLength) + "/" + input.Substring(num, tokenLength2);
            }
            return num2;
        }

        // Token: 0x060008CC RID: 2252 RVA: 0x0005954C File Offset: 0x0003954C
        private static void CheckMediaTypeFormat(string mediaType, string parameterName)
        {
            if (string.IsNullOrEmpty(mediaType))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, parameterName);
            }
            string text;
            int mediaTypeExpressionLength = MediaTypeHeaderValue.GetMediaTypeExpressionLength(mediaType, 0, out text);
            if (mediaTypeExpressionLength == 0 || text.Length != mediaType.Length)
            {
                throw new FormatException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, mediaType));
            }
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x060008CD RID: 2253 RVA: 0x0005959E File Offset: 0x0003959E
        object ICloneable.Clone()
        {
            return new MediaTypeHeaderValue(this);
        }

        // Token: 0x040005F9 RID: 1529
        private ObjectCollection<NameValueHeaderValue> _parameters;

        // Token: 0x040005FA RID: 1530
        private string _mediaType;
    }


    /// <summary>
    ///         Content-type ヘッダーで使用されるその他の品質係数でメディアの種類を表します。
    ///       </summary>
    // Token: 0x0200013E RID: 318
    sealed class MediaTypeWithQualityHeaderValue : MediaTypeHeaderValue, ICloneable
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> の品質の値を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> オブジェクトの品質の値。
        ///       </returns>
        // Token: 0x170001D8 RID: 472
        // (get) Token: 0x060008CE RID: 2254 RVA: 0x000595A6 File Offset: 0x000395A6
        // (set) Token: 0x060008CF RID: 2255 RVA: 0x000595B8 File Offset: 0x000395B8
        public double? Quality
        {
            get
            {
                return HeaderUtilities.GetQuality((ObjectCollection<NameValueHeaderValue>)base.Parameters);
            }
            set
            {
                HeaderUtilities.SetQuality((ObjectCollection<NameValueHeaderValue>)base.Parameters, value);
            }
        }

        // Token: 0x060008D0 RID: 2256 RVA: 0x000595CB File Offset: 0x000395CB
        internal MediaTypeWithQualityHeaderValue()
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="mediaType">
        ///           A <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> 新しいインスタンスを初期化するために文字列として表されます。
        ///         </param>
        // Token: 0x060008D1 RID: 2257 RVA: 0x000595D3 File Offset: 0x000395D3
        public MediaTypeWithQualityHeaderValue(string mediaType) : base(mediaType)
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="mediaType">
        ///           A <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> 新しいインスタンスを初期化するために文字列として表されます。
        ///         </param>
        /// <param name="quality">
        ///           このヘッダーの値に関連付けられている品質。
        ///         </param>
        // Token: 0x060008D2 RID: 2258 RVA: 0x000595DC File Offset: 0x000395DC
        public MediaTypeWithQualityHeaderValue(string mediaType, double quality) : base(mediaType)
        {
            this.Quality = new double?(quality);
        }

        // Token: 0x060008D3 RID: 2259 RVA: 0x000595F1 File Offset: 0x000395F1
        private MediaTypeWithQualityHeaderValue(MediaTypeWithQualityHeaderValue source) : base(source)
        {
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x060008D4 RID: 2260 RVA: 0x000595FA File Offset: 0x000395FA
        object ICloneable.Clone()
        {
            return new MediaTypeWithQualityHeaderValue(this);
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           品質のヘッダー値の情報を含む、メディアの種類を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は、品質のヘッダー値の情報を含む、有効なメディアの種類ではありません。
        ///           </exception>
        // Token: 0x060008D5 RID: 2261 RVA: 0x00059604 File Offset: 0x00039604
        public new static MediaTypeWithQualityHeaderValue Parse(string input)
        {
            int num = 0;
            return (MediaTypeWithQualityHeaderValue)MediaTypeHeaderParser.SingleValueWithQualityParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.MediaTypeWithQualityHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060008D6 RID: 2262 RVA: 0x00059628 File Offset: 0x00039628
        public static bool TryParse(string input, out MediaTypeWithQualityHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (MediaTypeHeaderParser.SingleValueWithQualityParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (MediaTypeWithQualityHeaderValue)obj;
                return true;
            }
            return false;
        }
    }



    /// <summary>
    ///         RFC 2616 で定義されているさまざまなヘッダーで使用される名前/値ペアを表します。
    ///       </summary>
    // Token: 0x0200013F RID: 319
    class NameValueHeaderValue : ICloneable
    {
        /// <summary>
        ///         ヘッダー名を取得します。
        ///       </summary>
        /// <returns>
        ///         ヘッダー名。
        ///       </returns>
        // Token: 0x170001D9 RID: 473
        // (get) Token: 0x060008D7 RID: 2263 RVA: 0x00059657 File Offset: 0x00039657
        public string Name
        {
            get
            {
                return this._name;
            }
        }

        /// <summary>
        ///         ヘッダーの値を取得します。
        ///       </summary>
        /// <returns>
        ///         ヘッダーの値。
        ///       </returns>
        // Token: 0x170001DA RID: 474
        // (get) Token: 0x060008D8 RID: 2264 RVA: 0x0005965F File Offset: 0x0003965F
        // (set) Token: 0x060008D9 RID: 2265 RVA: 0x00059667 File Offset: 0x00039667
        public string Value
        {
            get
            {
                return this._value;
            }
            set
            {
                NameValueHeaderValue.CheckValueFormat(value);
                this._value = value;
            }
        }

        // Token: 0x060008DA RID: 2266 RVA: 0x00035094 File Offset: 0x00015094
        internal NameValueHeaderValue()
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="name">
        ///           ヘッダーの名前です。
        ///         </param>
        // Token: 0x060008DB RID: 2267 RVA: 0x00059676 File Offset: 0x00039676
        public NameValueHeaderValue(string name) : this(name, null)
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="name">
        ///           ヘッダーの名前です。
        ///         </param>
        /// <param name="value">
        ///           ヘッダーの値。
        ///         </param>
        // Token: 0x060008DC RID: 2268 RVA: 0x00059680 File Offset: 0x00039680
        public NameValueHeaderValue(string name, string value)
        {
            NameValueHeaderValue.CheckNameValueFormat(name, value);
            this._name = name;
            this._value = value;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="source">
        ///           A <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> オブジェクトの新しいインスタンスを初期化するために使用します。
        ///         </param>
        // Token: 0x060008DD RID: 2269 RVA: 0x0005969D File Offset: 0x0003969D
        protected NameValueHeaderValue(NameValueHeaderValue source)
        {
            this._name = source._name;
            this._value = source._value;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x060008DE RID: 2270 RVA: 0x000596C0 File Offset: 0x000396C0
        public override int GetHashCode()
        {
            int hashCode = StringComparer.OrdinalIgnoreCase.GetHashCode(this._name);
            if (string.IsNullOrEmpty(this._value))
            {
                return hashCode;
            }
            if (this._value[0] == '"')
            {
                return hashCode ^ this._value.GetHashCode();
            }
            return hashCode ^ StringComparer.OrdinalIgnoreCase.GetHashCode(this._value);
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060008DF RID: 2271 RVA: 0x00059720 File Offset: 0x00039720
        public override bool Equals(object obj)
        {
            NameValueHeaderValue nameValueHeaderValue = obj as NameValueHeaderValue;
            if (nameValueHeaderValue == null)
            {
                return false;
            }
            if (!string.Equals(this._name, nameValueHeaderValue._name, StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }
            if (string.IsNullOrEmpty(this._value))
            {
                return string.IsNullOrEmpty(nameValueHeaderValue._value);
            }
            if (this._value[0] == '"')
            {
                return string.Equals(this._value, nameValueHeaderValue._value, StringComparison.Ordinal);
            }
            return string.Equals(this._value, nameValueHeaderValue._value, StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           名前の値のヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は有効な名前の値のヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x060008E0 RID: 2272 RVA: 0x000597A0 File Offset: 0x000397A0
        public static NameValueHeaderValue Parse(string input)
        {
            int num = 0;
            return (NameValueHeaderValue)GenericHeaderParser.SingleValueNameValueParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060008E1 RID: 2273 RVA: 0x000597C4 File Offset: 0x000397C4
        public static bool TryParse(string input, out NameValueHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.SingleValueNameValueParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (NameValueHeaderValue)obj;
                return true;
            }
            return false;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x060008E2 RID: 2274 RVA: 0x000597F3 File Offset: 0x000397F3
        public override string ToString()
        {
            if (!string.IsNullOrEmpty(this._value))
            {
                return this._name + "=" + this._value;
            }
            return this._name;
        }

        // Token: 0x060008E3 RID: 2275 RVA: 0x00059820 File Offset: 0x00039820
        private void AddToStringBuilder(StringBuilder sb)
        {
            if (base.GetType() != typeof(NameValueHeaderValue))
            {
                sb.Append(this.ToString());
                return;
            }
            sb.Append(this._name);
            if (!string.IsNullOrEmpty(this._value))
            {
                sb.Append('=');
                sb.Append(this._value);
            }
        }

        // Token: 0x060008E4 RID: 2276 RVA: 0x00059884 File Offset: 0x00039884
        internal static void ToString(ObjectCollection<NameValueHeaderValue> values, char separator, bool leadingSeparator, StringBuilder destination)
        {
            if (values == null || values.Count == 0)
            {
                return;
            }
            foreach (NameValueHeaderValue nameValueHeaderValue in values)
            {
                if (leadingSeparator || destination.Length > 0)
                {
                    destination.Append(separator);
                    destination.Append(' ');
                }
                nameValueHeaderValue.AddToStringBuilder(destination);
            }
        }

        // Token: 0x060008E5 RID: 2277 RVA: 0x000598FC File Offset: 0x000398FC
        internal static int GetHashCode(ObjectCollection<NameValueHeaderValue> values)
        {
            if (values == null || values.Count == 0)
            {
                return 0;
            }
            int num = 0;
            foreach (NameValueHeaderValue nameValueHeaderValue in values)
            {
                num ^= nameValueHeaderValue.GetHashCode();
            }
            return num;
        }

        // Token: 0x060008E6 RID: 2278 RVA: 0x0005995C File Offset: 0x0003995C
        internal static int GetNameValueLength(string input, int startIndex, out NameValueHeaderValue parsedValue)
        {
            return NameValueHeaderValue.GetNameValueLength(input, startIndex, NameValueHeaderValue.s_defaultNameValueCreator, out parsedValue);
        }

        // Token: 0x060008E7 RID: 2279 RVA: 0x0005996C File Offset: 0x0003996C
        internal static int GetNameValueLength(string input, int startIndex, Func<NameValueHeaderValue> nameValueCreator, out NameValueHeaderValue parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            int tokenLength = HttpRuleParser.GetTokenLength(input, startIndex);
            if (tokenLength == 0)
            {
                return 0;
            }
            string name = input.Substring(startIndex, tokenLength);
            int num = startIndex + tokenLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            if (num == input.Length || input[num] != '=')
            {
                parsedValue = nameValueCreator();
                parsedValue._name = name;
                num += HttpRuleParser.GetWhitespaceLength(input, num);
                return num - startIndex;
            }
            num++;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            int valueLength = NameValueHeaderValue.GetValueLength(input, num);
            if (valueLength == 0)
            {
                return 0;
            }
            parsedValue = nameValueCreator();
            parsedValue._name = name;
            parsedValue._value = input.Substring(num, valueLength);
            num += valueLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            return num - startIndex;
        }

        // Token: 0x060008E8 RID: 2280 RVA: 0x00059A30 File Offset: 0x00039A30
        internal static int GetNameValueListLength(string input, int startIndex, char delimiter, ObjectCollection<NameValueHeaderValue> nameValueCollection)
        {
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            int num = startIndex + HttpRuleParser.GetWhitespaceLength(input, startIndex);
            for (; ; )
            {
                NameValueHeaderValue item = null;
                int nameValueLength = NameValueHeaderValue.GetNameValueLength(input, num, NameValueHeaderValue.s_defaultNameValueCreator, out item);
                if (nameValueLength == 0)
                {
                    break;
                }
                nameValueCollection.Add(item);
                num += nameValueLength;
                num += HttpRuleParser.GetWhitespaceLength(input, num);
                if (num == input.Length || input[num] != delimiter)
                {
                    goto IL_5B;
                }
                num++;
                num += HttpRuleParser.GetWhitespaceLength(input, num);
            }
            return 0;
            IL_5B:
            return num - startIndex;
        }

        // Token: 0x060008E9 RID: 2281 RVA: 0x00059AAC File Offset: 0x00039AAC
        internal static NameValueHeaderValue Find(ObjectCollection<NameValueHeaderValue> values, string name)
        {
            if (values == null || values.Count == 0)
            {
                return null;
            }
            foreach (NameValueHeaderValue nameValueHeaderValue in values)
            {
                if (string.Equals(nameValueHeaderValue.Name, name, StringComparison.OrdinalIgnoreCase))
                {
                    return nameValueHeaderValue;
                }
            }
            return null;
        }

        // Token: 0x060008EA RID: 2282 RVA: 0x00059B18 File Offset: 0x00039B18
        internal static int GetValueLength(string input, int startIndex)
        {
            if (startIndex >= input.Length)
            {
                return 0;
            }
            int tokenLength = HttpRuleParser.GetTokenLength(input, startIndex);
            if (tokenLength == 0 && HttpRuleParser.GetQuotedStringLength(input, startIndex, out tokenLength) != HttpParseResult.Parsed)
            {
                return 0;
            }
            return tokenLength;
        }

        // Token: 0x060008EB RID: 2283 RVA: 0x00059B49 File Offset: 0x00039B49
        private static void CheckNameValueFormat(string name, string value)
        {
            HeaderUtilities.CheckValidToken(name, "name");
            NameValueHeaderValue.CheckValueFormat(value);
        }

        // Token: 0x060008EC RID: 2284 RVA: 0x00059B5C File Offset: 0x00039B5C
        private static void CheckValueFormat(string value)
        {
            if (!string.IsNullOrEmpty(value) && NameValueHeaderValue.GetValueLength(value, 0) != value.Length)
            {
                throw new FormatException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, value));
            }
        }

        // Token: 0x060008ED RID: 2285 RVA: 0x00059B8B File Offset: 0x00039B8B
        private static NameValueHeaderValue CreateNameValue()
        {
            return new NameValueHeaderValue();
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.NameValueHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x060008EE RID: 2286 RVA: 0x00059B92 File Offset: 0x00039B92
        object ICloneable.Clone()
        {
            return new NameValueHeaderValue(this);
        }

        // Token: 0x040005FB RID: 1531
        private static readonly Func<NameValueHeaderValue> s_defaultNameValueCreator = new Func<NameValueHeaderValue>(NameValueHeaderValue.CreateNameValue);

        // Token: 0x040005FC RID: 1532
        private string _name;

        // Token: 0x040005FD RID: 1533
        private string _value;
    }



    /// <summary>
    ///         RFC 2616 で定義されているさまざまなヘッダーで使用されるパラメーターを名前/値ペアを表します。
    ///       </summary>
    // Token: 0x02000140 RID: 320
    class NameValueWithParametersHeaderValue : NameValueHeaderValue, ICloneable
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> オブジェクトからパラメーターを取得します。
        ///       </summary>
        /// <returns>
        ///         パラメーターを格納しているコレクション。
        ///       </returns>
        // Token: 0x170001DB RID: 475
        // (get) Token: 0x060008F0 RID: 2288 RVA: 0x00059BAD File Offset: 0x00039BAD
        public ICollection<NameValueHeaderValue> Parameters
        {
            get
            {
                if (this._parameters == null)
                {
                    this._parameters = new ObjectCollection<NameValueHeaderValue>();
                }
                return this._parameters;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="name">
        ///           ヘッダーの名前です。
        ///         </param>
        // Token: 0x060008F1 RID: 2289 RVA: 0x00059BC8 File Offset: 0x00039BC8
        public NameValueWithParametersHeaderValue(string name) : base(name)
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="name">
        ///           ヘッダーの名前です。
        ///         </param>
        /// <param name="value">
        ///           ヘッダーの値。
        ///         </param>
        // Token: 0x060008F2 RID: 2290 RVA: 0x00059BD1 File Offset: 0x00039BD1
        public NameValueWithParametersHeaderValue(string name, string value) : base(name, value)
        {
        }

        // Token: 0x060008F3 RID: 2291 RVA: 0x00059BDB File Offset: 0x00039BDB
        internal NameValueWithParametersHeaderValue()
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="source">
        ///           A <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> オブジェクトの新しいインスタンスを初期化するために使用します。
        ///         </param>
        // Token: 0x060008F4 RID: 2292 RVA: 0x00059BE4 File Offset: 0x00039BE4
        protected NameValueWithParametersHeaderValue(NameValueWithParametersHeaderValue source) : base(source)
        {
            if (source._parameters != null)
            {
                foreach (NameValueHeaderValue nameValueHeaderValue in source._parameters)
                {
                    this.Parameters.Add((NameValueHeaderValue)((ICloneable)nameValueHeaderValue).Clone());
                }
            }
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060008F5 RID: 2293 RVA: 0x00059C58 File Offset: 0x00039C58
        public override bool Equals(object obj)
        {
            bool flag = base.Equals(obj);
            if (flag)
            {
                NameValueWithParametersHeaderValue nameValueWithParametersHeaderValue = obj as NameValueWithParametersHeaderValue;
                return nameValueWithParametersHeaderValue != null && HeaderUtilities.AreEqualCollections<NameValueHeaderValue>(this._parameters, nameValueWithParametersHeaderValue._parameters);
            }
            return false;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x060008F6 RID: 2294 RVA: 0x00059C8F File Offset: 0x00039C8F
        public override int GetHashCode()
        {
            return base.GetHashCode() ^ NameValueHeaderValue.GetHashCode(this._parameters);
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x060008F7 RID: 2295 RVA: 0x00059CA4 File Offset: 0x00039CA4
        public override string ToString()
        {
            string value = base.ToString();
            StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
            stringBuilder.Append(value);
            NameValueHeaderValue.ToString(this._parameters, ';', true, stringBuilder);
            return StringBuilderCache.GetStringAndRelease(stringBuilder);
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           パラメーターのヘッダー値の情報を含む名前の値を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> はパラメーターのヘッダー値の情報を含む有効な名前の値ではありません。
        ///           </exception>
        // Token: 0x060008F8 RID: 2296 RVA: 0x00059CE0 File Offset: 0x00039CE0
        public new static NameValueWithParametersHeaderValue Parse(string input)
        {
            int num = 0;
            return (NameValueWithParametersHeaderValue)GenericHeaderParser.SingleValueNameValueWithParametersParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060008F9 RID: 2297 RVA: 0x00059D04 File Offset: 0x00039D04
        public static bool TryParse(string input, out NameValueWithParametersHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.SingleValueNameValueWithParametersParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (NameValueWithParametersHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x060008FA RID: 2298 RVA: 0x00059D34 File Offset: 0x00039D34
        internal static int GetNameValueWithParametersLength(string input, int startIndex, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            NameValueHeaderValue nameValueHeaderValue = null;
            int nameValueLength = NameValueHeaderValue.GetNameValueLength(input, startIndex, NameValueWithParametersHeaderValue.s_nameValueCreator, out nameValueHeaderValue);
            if (nameValueLength == 0)
            {
                return 0;
            }
            int num = startIndex + nameValueLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            NameValueWithParametersHeaderValue nameValueWithParametersHeaderValue = nameValueHeaderValue as NameValueWithParametersHeaderValue;
            if (num >= input.Length || input[num] != ';')
            {
                parsedValue = nameValueWithParametersHeaderValue;
                return num - startIndex;
            }
            num++;
            int nameValueListLength = NameValueHeaderValue.GetNameValueListLength(input, num, ';', (ObjectCollection<NameValueHeaderValue>)nameValueWithParametersHeaderValue.Parameters);
            if (nameValueListLength == 0)
            {
                return 0;
            }
            parsedValue = nameValueWithParametersHeaderValue;
            return num + nameValueListLength - startIndex;
        }

        // Token: 0x060008FB RID: 2299 RVA: 0x00059DC6 File Offset: 0x00039DC6
        private static NameValueHeaderValue CreateNameValue()
        {
            return new NameValueWithParametersHeaderValue();
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.NameValueWithParametersHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x060008FC RID: 2300 RVA: 0x00059DCD File Offset: 0x00039DCD
        object ICloneable.Clone()
        {
            return new NameValueWithParametersHeaderValue(this);
        }

        // Token: 0x040005FE RID: 1534
        private static readonly Func<NameValueHeaderValue> s_nameValueCreator = new Func<NameValueHeaderValue>(NameValueWithParametersHeaderValue.CreateNameValue);

        // Token: 0x040005FF RID: 1535
        private ObjectCollection<NameValueHeaderValue> _parameters;
    }


    // Token: 0x02000141 RID: 321
    internal sealed class ObjectCollection<T> : Collection<T> where T : class
    {
        // Token: 0x060008FE RID: 2302 RVA: 0x00059DE8 File Offset: 0x00039DE8
        public ObjectCollection() : this(ObjectCollection<T>.s_defaultValidator)
        {
        }

        // Token: 0x060008FF RID: 2303 RVA: 0x00059DF5 File Offset: 0x00039DF5
        public ObjectCollection(Action<T> validator) : base(new List<T>())
        {
            this._validator = validator;
        }

        // Token: 0x06000900 RID: 2304 RVA: 0x00059E09 File Offset: 0x00039E09
        public new List<T>.Enumerator GetEnumerator()
        {
            return ((List<T>)base.Items).GetEnumerator();
        }

        // Token: 0x06000901 RID: 2305 RVA: 0x00059E1B File Offset: 0x00039E1B
        protected override void InsertItem(int index, T item)
        {
            this._validator(item);
            base.InsertItem(index, item);
        }

        // Token: 0x06000902 RID: 2306 RVA: 0x00059E31 File Offset: 0x00039E31
        protected override void SetItem(int index, T item)
        {
            this._validator(item);
            base.SetItem(index, item);
        }

        // Token: 0x06000903 RID: 2307 RVA: 0x00059E47 File Offset: 0x00039E47
        private static void CheckNotNull(T item)
        {
            if (item == null)
            {
                throw new ArgumentNullException("item");
            }
        }

        // Token: 0x04000600 RID: 1536
        private static readonly Action<T> s_defaultValidator = new Action<T>(ObjectCollection<T>.CheckNotNull);

        // Token: 0x04000601 RID: 1537
        private readonly Action<T> _validator;
    }


    /// <summary>
    ///         ユーザー エージェント ヘッダーに製品トークン値を表します。
    ///       </summary>
    // Token: 0x02000142 RID: 322
    class ProductHeaderValue : ICloneable
    {
        /// <summary>
        ///         製品トークンの名前を取得します。
        ///       </summary>
        /// <returns>
        ///         製品トークンの名前。
        ///       </returns>
        // Token: 0x170001DC RID: 476
        // (get) Token: 0x06000905 RID: 2309 RVA: 0x00059E6F File Offset: 0x00039E6F
        public string Name
        {
            get
            {
                return this._name;
            }
        }

        /// <summary>
        ///         製品トークンのバージョンを取得します。
        ///       </summary>
        /// <returns>
        ///         製品トークンのバージョン。
        ///       </returns>
        // Token: 0x170001DD RID: 477
        // (get) Token: 0x06000906 RID: 2310 RVA: 0x00059E77 File Offset: 0x00039E77
        public string Version
        {
            get
            {
                return this._version;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ProductHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="name">
        ///           製品名。
        ///         </param>
        // Token: 0x06000907 RID: 2311 RVA: 0x00059E7F File Offset: 0x00039E7F
        public ProductHeaderValue(string name) : this(name, null)
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ProductHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="name">
        ///           製品名の値。
        ///         </param>
        /// <param name="version">
        ///           製品バージョンの値。
        ///         </param>
        // Token: 0x06000908 RID: 2312 RVA: 0x00059E89 File Offset: 0x00039E89
        public ProductHeaderValue(string name, string version)
        {
            HeaderUtilities.CheckValidToken(name, "name");
            if (!string.IsNullOrEmpty(version))
            {
                HeaderUtilities.CheckValidToken(version, "version");
                this._version = version;
            }
            this._name = name;
        }

        // Token: 0x06000909 RID: 2313 RVA: 0x00059EBD File Offset: 0x00039EBD
        private ProductHeaderValue(ProductHeaderValue source)
        {
            this._name = source._name;
            this._version = source._version;
        }

        // Token: 0x0600090A RID: 2314 RVA: 0x00035094 File Offset: 0x00015094
        private ProductHeaderValue()
        {
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.ProductHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x0600090B RID: 2315 RVA: 0x00059EDD File Offset: 0x00039EDD
        public override string ToString()
        {
            if (string.IsNullOrEmpty(this._version))
            {
                return this._name;
            }
            return this._name + "/" + this._version;
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.ProductHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x0600090C RID: 2316 RVA: 0x00059F0C File Offset: 0x00039F0C
        public override bool Equals(object obj)
        {
            ProductHeaderValue productHeaderValue = obj as ProductHeaderValue;
            return productHeaderValue != null && string.Equals(this._name, productHeaderValue._name, StringComparison.OrdinalIgnoreCase) && string.Equals(this._version, productHeaderValue._version, StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ProductHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x0600090D RID: 2317 RVA: 0x00059F50 File Offset: 0x00039F50
        public override int GetHashCode()
        {
            int num = StringComparer.OrdinalIgnoreCase.GetHashCode(this._name);
            if (!string.IsNullOrEmpty(this._version))
            {
                num ^= StringComparer.OrdinalIgnoreCase.GetHashCode(this._version);
            }
            return num;
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.ProductHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           製品のヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.ProductHeaderValue" /> のインスタンス。
        ///       </returns>
        // Token: 0x0600090E RID: 2318 RVA: 0x00059F90 File Offset: 0x00039F90
        public static ProductHeaderValue Parse(string input)
        {
            int num = 0;
            return (ProductHeaderValue)GenericHeaderParser.SingleValueProductParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.ProductHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.ProductHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.ProductHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x0600090F RID: 2319 RVA: 0x00059FB4 File Offset: 0x00039FB4
        public static bool TryParse(string input, out ProductHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.SingleValueProductParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (ProductHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x06000910 RID: 2320 RVA: 0x00059FE4 File Offset: 0x00039FE4
        internal static int GetProductLength(string input, int startIndex, out ProductHeaderValue parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            int tokenLength = HttpRuleParser.GetTokenLength(input, startIndex);
            if (tokenLength == 0)
            {
                return 0;
            }
            ProductHeaderValue productHeaderValue = new ProductHeaderValue();
            productHeaderValue._name = input.Substring(startIndex, tokenLength);
            int num = startIndex + tokenLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            if (num == input.Length || input[num] != '/')
            {
                parsedValue = productHeaderValue;
                return num - startIndex;
            }
            num++;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            int tokenLength2 = HttpRuleParser.GetTokenLength(input, num);
            if (tokenLength2 == 0)
            {
                return 0;
            }
            productHeaderValue._version = input.Substring(num, tokenLength2);
            num += tokenLength2;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            parsedValue = productHeaderValue;
            return num - startIndex;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.ProductHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x06000911 RID: 2321 RVA: 0x0005A08E File Offset: 0x0003A08E
        object ICloneable.Clone()
        {
            return new ProductHeaderValue(this);
        }

        // Token: 0x04000602 RID: 1538
        private string _name;

        // Token: 0x04000603 RID: 1539
        private string _version;
    }


    // Token: 0x02000143 RID: 323
    internal class ProductInfoHeaderParser : HttpHeaderParser
    {
        // Token: 0x06000912 RID: 2322 RVA: 0x0005A096 File Offset: 0x0003A096
        private ProductInfoHeaderParser(bool supportsMultipleValues) : base(supportsMultipleValues, " ")
        {
        }

        // Token: 0x06000913 RID: 2323 RVA: 0x0005A0A4 File Offset: 0x0003A0A4
        public override bool TryParseValue(string value, object storeValue, ref int index, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(value) || index == value.Length)
            {
                return false;
            }
            int num = index + HttpRuleParser.GetWhitespaceLength(value, index);
            if (num == value.Length)
            {
                return false;
            }
            ProductInfoHeaderValue productInfoHeaderValue = null;
            int productInfoLength = ProductInfoHeaderValue.GetProductInfoLength(value, num, out productInfoHeaderValue);
            if (productInfoLength == 0)
            {
                return false;
            }
            num += productInfoLength;
            if (num < value.Length)
            {
                char c = value[num - 1];
                if (c != ' ' && c != '\t')
                {
                    return false;
                }
            }
            index = num;
            parsedValue = productInfoHeaderValue;
            return true;
        }

        // Token: 0x04000604 RID: 1540
        internal static readonly ProductInfoHeaderParser SingleValueParser = new ProductInfoHeaderParser(false);

        // Token: 0x04000605 RID: 1541
        internal static readonly ProductInfoHeaderParser MultipleValueParser = new ProductInfoHeaderParser(true);
    }


    /// <summary>
    ///         使用できる成果物または User-agent ヘッダー内のコメント値を表します。
    ///       </summary>
    // Token: 0x02000144 RID: 324
    class ProductInfoHeaderValue : ICloneable
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> オブジェクトから製品を取得します。
        ///       </summary>
        /// <returns>
        ///         この <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> からの製品の値。
        ///       </returns>
        // Token: 0x170001DE RID: 478
        // (get) Token: 0x06000915 RID: 2325 RVA: 0x0005A134 File Offset: 0x0003A134
        public ProductHeaderValue Product
        {
            get
            {
                return this._product;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> オブジェクトからコメントを取得します。
        ///       </summary>
        /// <returns>
        ///         この <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> のコメントの値。
        ///       </returns>
        // Token: 0x170001DF RID: 479
        // (get) Token: 0x06000916 RID: 2326 RVA: 0x0005A13C File Offset: 0x0003A13C
        public string Comment
        {
            get
            {
                return this._comment;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="productName">
        ///           製品名の値。
        ///         </param>
        /// <param name="productVersion">
        ///           製品バージョンの値。
        ///         </param>
        // Token: 0x06000917 RID: 2327 RVA: 0x0005A144 File Offset: 0x0003A144
        public ProductInfoHeaderValue(string productName, string productVersion) : this(new ProductHeaderValue(productName, productVersion))
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="product">
        ///           A <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> オブジェクトの新しいインスタンスを初期化するために使用します。
        ///         </param>
        // Token: 0x06000918 RID: 2328 RVA: 0x0005A153 File Offset: 0x0003A153
        public ProductInfoHeaderValue(ProductHeaderValue product)
        {
            if (product == null)
            {
                throw new ArgumentNullException("product");
            }
            this._product = product;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="comment">
        ///           コメントの値です。
        ///         </param>
        // Token: 0x06000919 RID: 2329 RVA: 0x0005A170 File Offset: 0x0003A170
        public ProductInfoHeaderValue(string comment)
        {
            HeaderUtilities.CheckValidComment(comment, "comment");
            this._comment = comment;
        }

        // Token: 0x0600091A RID: 2330 RVA: 0x0005A18A File Offset: 0x0003A18A
        private ProductInfoHeaderValue(ProductInfoHeaderValue source)
        {
            this._product = source._product;
            this._comment = source._comment;
        }

        // Token: 0x0600091B RID: 2331 RVA: 0x00035094 File Offset: 0x00015094
        private ProductInfoHeaderValue()
        {
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x0600091C RID: 2332 RVA: 0x0005A1AA File Offset: 0x0003A1AA
        public override string ToString()
        {
            if (this._product == null)
            {
                return this._comment;
            }
            return this._product.ToString();
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x0600091D RID: 2333 RVA: 0x0005A1C8 File Offset: 0x0003A1C8
        public override bool Equals(object obj)
        {
            ProductInfoHeaderValue productInfoHeaderValue = obj as ProductInfoHeaderValue;
            if (productInfoHeaderValue == null)
            {
                return false;
            }
            if (this._product == null)
            {
                return string.Equals(this._comment, productInfoHeaderValue._comment, StringComparison.Ordinal);
            }
            return this._product.Equals(productInfoHeaderValue._product);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x0600091E RID: 2334 RVA: 0x0005A20D File Offset: 0x0003A20D
        public override int GetHashCode()
        {
            if (this._product == null)
            {
                return this._comment.GetHashCode();
            }
            return this._product.GetHashCode();
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           製品情報のヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は、有効な製品情報のヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x0600091F RID: 2335 RVA: 0x0005A230 File Offset: 0x0003A230
        public static ProductInfoHeaderValue Parse(string input)
        {
            int num = 0;
            object obj = ProductInfoHeaderParser.SingleValueParser.ParseValue(input, null, ref num);
            if (num < input.Length)
            {
                throw new FormatException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, input.Substring(num)));
            }
            return (ProductInfoHeaderValue)obj;
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000920 RID: 2336 RVA: 0x0005A27C File Offset: 0x0003A27C
        public static bool TryParse(string input, out ProductInfoHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (!ProductInfoHeaderParser.SingleValueParser.TryParseValue(input, null, ref num, out obj))
            {
                return false;
            }
            if (num < input.Length)
            {
                return false;
            }
            parsedValue = (ProductInfoHeaderValue)obj;
            return true;
        }

        // Token: 0x06000921 RID: 2337 RVA: 0x0005A2B8 File Offset: 0x0003A2B8
        internal static int GetProductInfoLength(string input, int startIndex, out ProductInfoHeaderValue parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            string comment = null;
            ProductHeaderValue product = null;
            int num2;
            if (input[startIndex] == '(')
            {
                int num = 0;
                if (HttpRuleParser.GetCommentLength(input, startIndex, out num) != HttpParseResult.Parsed)
                {
                    return 0;
                }
                comment = input.Substring(startIndex, num);
                num2 = startIndex + num;
                num2 += HttpRuleParser.GetWhitespaceLength(input, num2);
            }
            else
            {
                int productLength = ProductHeaderValue.GetProductLength(input, startIndex, out product);
                if (productLength == 0)
                {
                    return 0;
                }
                num2 = startIndex + productLength;
            }
            parsedValue = new ProductInfoHeaderValue();
            parsedValue._product = product;
            parsedValue._comment = comment;
            return num2 - startIndex;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.ProductInfoHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x06000922 RID: 2338 RVA: 0x0005A344 File Offset: 0x0003A344
        object ICloneable.Clone()
        {
            return new ProductInfoHeaderValue(this);
        }

        // Token: 0x04000606 RID: 1542
        private ProductHeaderValue _product;

        // Token: 0x04000607 RID: 1543
        private string _comment;
    }


    /// <summary>
    ///         If 範囲ヘッダーの値になる可能性がか、日付/時刻またはエンティティ タグ値を表します。
    ///       </summary>
    // Token: 0x02000145 RID: 325
    class RangeConditionHeaderValue : ICloneable
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> オブジェクトから日付を取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> オブジェクトからの日付。
        ///       </returns>
        // Token: 0x170001E0 RID: 480
        // (get) Token: 0x06000923 RID: 2339 RVA: 0x0005A34C File Offset: 0x0003A34C
        public DateTimeOffset? Date
        {
            get
            {
                return this._date;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> オブジェクトからエンティティ タグを取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> オブジェクトからのエンティティ タグ。
        ///       </returns>
        // Token: 0x170001E1 RID: 481
        // (get) Token: 0x06000924 RID: 2340 RVA: 0x0005A354 File Offset: 0x0003A354
        public EntityTagHeaderValue EntityTag
        {
            get
            {
                return this._entityTag;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="date">
        ///           新しいインスタンスを初期化するために使用される日付の値。
        ///         </param>
        // Token: 0x06000925 RID: 2341 RVA: 0x0005A35C File Offset: 0x0003A35C
        public RangeConditionHeaderValue(DateTimeOffset date)
        {
            this._date = new DateTimeOffset?(date);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="entityTag">
        ///           <see cref="T:System.Net.Http.Headers.EntityTagHeaderValue" /> オブジェクトの新しいインスタンスを初期化するために使用します。
        ///         </param>
        // Token: 0x06000926 RID: 2342 RVA: 0x0005A370 File Offset: 0x0003A370
        public RangeConditionHeaderValue(EntityTagHeaderValue entityTag)
        {
            if (entityTag == null)
            {
                throw new ArgumentNullException("entityTag");
            }
            this._entityTag = entityTag;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="entityTag">
        ///           新しいインスタンスを初期化するために使用される文字列として表されるエンティティ タグ。
        ///         </param>
        // Token: 0x06000927 RID: 2343 RVA: 0x0005A38D File Offset: 0x0003A38D
        public RangeConditionHeaderValue(string entityTag) : this(new EntityTagHeaderValue(entityTag))
        {
        }

        // Token: 0x06000928 RID: 2344 RVA: 0x0005A39B File Offset: 0x0003A39B
        private RangeConditionHeaderValue(RangeConditionHeaderValue source)
        {
            this._entityTag = source._entityTag;
            this._date = source._date;
        }

        // Token: 0x06000929 RID: 2345 RVA: 0x00035094 File Offset: 0x00015094
        private RangeConditionHeaderValue()
        {
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x0600092A RID: 2346 RVA: 0x0005A3BB File Offset: 0x0003A3BB
        public override string ToString()
        {
            if (this._entityTag == null)
            {
                return HttpRuleParser.DateToString(this._date.Value);
            }
            return this._entityTag.ToString();
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x0600092B RID: 2347 RVA: 0x0005A3E4 File Offset: 0x0003A3E4
        public override bool Equals(object obj)
        {
            RangeConditionHeaderValue rangeConditionHeaderValue = obj as RangeConditionHeaderValue;
            if (rangeConditionHeaderValue == null)
            {
                return false;
            }
            if (this._entityTag == null)
            {
                return rangeConditionHeaderValue._date != null && this._date.Value == rangeConditionHeaderValue._date.Value;
            }
            return this._entityTag.Equals(rangeConditionHeaderValue._entityTag);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x0600092C RID: 2348 RVA: 0x0005A444 File Offset: 0x0003A444
        public override int GetHashCode()
        {
            if (this._entityTag == null)
            {
                return this._date.Value.GetHashCode();
            }
            return this._entityTag.GetHashCode();
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           範囲の条件ヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" />は有効な範囲の条件ヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x0600092D RID: 2349 RVA: 0x0005A480 File Offset: 0x0003A480
        public static RangeConditionHeaderValue Parse(string input)
        {
            int num = 0;
            return (RangeConditionHeaderValue)GenericHeaderParser.RangeConditionParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x0600092E RID: 2350 RVA: 0x0005A4A4 File Offset: 0x0003A4A4
        public static bool TryParse(string input, out RangeConditionHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.RangeConditionParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (RangeConditionHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x0600092F RID: 2351 RVA: 0x0005A4D4 File Offset: 0x0003A4D4
        internal static int GetRangeConditionLength(string input, int startIndex, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex + 1 >= input.Length)
            {
                return 0;
            }
            DateTimeOffset minValue = DateTimeOffset.MinValue;
            EntityTagHeaderValue entityTagHeaderValue = null;
            char c = input[startIndex];
            char c2 = input[startIndex + 1];
            int num;
            if (c == '"' || ((c == 'w' || c == 'W') && c2 == '/'))
            {
                int entityTagLength = EntityTagHeaderValue.GetEntityTagLength(input, startIndex, out entityTagHeaderValue);
                if (entityTagLength == 0)
                {
                    return 0;
                }
                num = startIndex + entityTagLength;
                if (num != input.Length)
                {
                    return 0;
                }
            }
            else
            {
                if (!HttpRuleParser.TryStringToDate(input.Substring(startIndex), out minValue))
                {
                    return 0;
                }
                num = input.Length;
            }
            RangeConditionHeaderValue rangeConditionHeaderValue = new RangeConditionHeaderValue();
            if (entityTagHeaderValue == null)
            {
                rangeConditionHeaderValue._date = new DateTimeOffset?(minValue);
            }
            else
            {
                rangeConditionHeaderValue._entityTag = entityTagHeaderValue;
            }
            parsedValue = rangeConditionHeaderValue;
            return num - startIndex;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.RangeConditionHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x06000930 RID: 2352 RVA: 0x0005A58D File Offset: 0x0003A58D
        object ICloneable.Clone()
        {
            return new RangeConditionHeaderValue(this);
        }

        // Token: 0x04000608 RID: 1544
        private DateTimeOffset? _date;

        // Token: 0x04000609 RID: 1545
        private EntityTagHeaderValue _entityTag;
    }


    /// <summary>
    ///         範囲ヘッダーの値を表します。
    ///       </summary>
    // Token: 0x02000146 RID: 326
    class RangeHeaderValue : ICloneable
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> オブジェクトから単位を取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> オブジェクトからの単位。
        ///       </returns>
        // Token: 0x170001E2 RID: 482
        // (get) Token: 0x06000931 RID: 2353 RVA: 0x0005A595 File Offset: 0x0003A595
        // (set) Token: 0x06000932 RID: 2354 RVA: 0x0005A59D File Offset: 0x0003A59D
        public string Unit
        {
            get
            {
                return this._unit;
            }
            set
            {
                HeaderUtilities.CheckValidToken(value, "value");
                this._unit = value;
            }
        }

        /// <summary>
        ///         指定された範囲を <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> オブジェクトから取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> オブジェクトからの範囲。
        ///       </returns>
        // Token: 0x170001E3 RID: 483
        // (get) Token: 0x06000933 RID: 2355 RVA: 0x0005A5B1 File Offset: 0x0003A5B1
        public ICollection<RangeItemHeaderValue> Ranges
        {
            get
            {
                if (this._ranges == null)
                {
                    this._ranges = new ObjectCollection<RangeItemHeaderValue>();
                }
                return this._ranges;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        // Token: 0x06000934 RID: 2356 RVA: 0x0005A5CC File Offset: 0x0003A5CC
        public RangeHeaderValue()
        {
            this._unit = "bytes";
        }

        /// <summary>
        ///         新しいインスタンスを初期化、 <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> バイトの範囲にしています。
        ///       </summary>
        /// <param name="from">
        ///           データの送信を開始する位置。
        ///         </param>
        /// <param name="to">
        ///           データの送信を終了する位置。
        ///         </param>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///             <paramref name="from" /> は <paramref name="to" /> より大きい
        ///
        ///             または 
        ///
        ///             <paramref name="from" /> または <paramref name="to" /> が 0 未満です。
        ///           </exception>
        // Token: 0x06000935 RID: 2357 RVA: 0x0005A5DF File Offset: 0x0003A5DF
        public RangeHeaderValue(long? from, long? to)
        {
            this._unit = "bytes";
            this.Ranges.Add(new RangeItemHeaderValue(from, to));
        }

        // Token: 0x06000936 RID: 2358 RVA: 0x0005A604 File Offset: 0x0003A604
        private RangeHeaderValue(RangeHeaderValue source)
        {
            this._unit = source._unit;
            if (source._ranges != null)
            {
                foreach (RangeItemHeaderValue rangeItemHeaderValue in source._ranges)
                {
                    this.Ranges.Add((RangeItemHeaderValue)((ICloneable)rangeItemHeaderValue).Clone());
                }
            }
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x06000937 RID: 2359 RVA: 0x0005A680 File Offset: 0x0003A680
        public override string ToString()
        {
            StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
            stringBuilder.Append(this._unit);
            stringBuilder.Append('=');
            if (this._ranges != null)
            {
                bool flag = true;
                foreach (RangeItemHeaderValue rangeItemHeaderValue in this._ranges)
                {
                    if (flag)
                    {
                        flag = false;
                    }
                    else
                    {
                        stringBuilder.Append(", ");
                    }
                    stringBuilder.Append(rangeItemHeaderValue.From);
                    stringBuilder.Append('-');
                    stringBuilder.Append(rangeItemHeaderValue.To);
                }
            }
            return StringBuilderCache.GetStringAndRelease(stringBuilder);
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000938 RID: 2360 RVA: 0x0005A73C File Offset: 0x0003A73C
        public override bool Equals(object obj)
        {
            RangeHeaderValue rangeHeaderValue = obj as RangeHeaderValue;
            return rangeHeaderValue != null && string.Equals(this._unit, rangeHeaderValue._unit, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections<RangeItemHeaderValue>(this._ranges, rangeHeaderValue._ranges);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x06000939 RID: 2361 RVA: 0x0005A77C File Offset: 0x0003A77C
        public override int GetHashCode()
        {
            int num = StringComparer.OrdinalIgnoreCase.GetHashCode(this._unit);
            if (this._ranges != null)
            {
                foreach (RangeItemHeaderValue rangeItemHeaderValue in this._ranges)
                {
                    num ^= rangeItemHeaderValue.GetHashCode();
                }
            }
            return num;
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           範囲のヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は有効な範囲のヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x0600093A RID: 2362 RVA: 0x0005A7EC File Offset: 0x0003A7EC
        public static RangeHeaderValue Parse(string input)
        {
            int num = 0;
            return (RangeHeaderValue)GenericHeaderParser.RangeParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x0600093B RID: 2363 RVA: 0x0005A810 File Offset: 0x0003A810
        public static bool TryParse(string input, out RangeHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.RangeParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (RangeHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x0600093C RID: 2364 RVA: 0x0005A840 File Offset: 0x0003A840
        internal static int GetRangeLength(string input, int startIndex, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            int tokenLength = HttpRuleParser.GetTokenLength(input, startIndex);
            if (tokenLength == 0)
            {
                return 0;
            }
            RangeHeaderValue rangeHeaderValue = new RangeHeaderValue();
            rangeHeaderValue._unit = input.Substring(startIndex, tokenLength);
            int num = startIndex + tokenLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            if (num == input.Length || input[num] != '=')
            {
                return 0;
            }
            num++;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            int rangeItemListLength = RangeItemHeaderValue.GetRangeItemListLength(input, num, rangeHeaderValue.Ranges);
            if (rangeItemListLength == 0)
            {
                return 0;
            }
            num += rangeItemListLength;
            parsedValue = rangeHeaderValue;
            return num - startIndex;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.RangeHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x0600093D RID: 2365 RVA: 0x0005A8D3 File Offset: 0x0003A8D3
        object ICloneable.Clone()
        {
            return new RangeHeaderValue(this);
        }

        // Token: 0x0400060A RID: 1546
        private string _unit;

        // Token: 0x0400060B RID: 1547
        private ObjectCollection<RangeItemHeaderValue> _ranges;
    }

    /// <summary>
    ///         バイトの範囲に範囲ヘッダーの値を表します。
    ///       </summary>
    // Token: 0x02000147 RID: 327
    class RangeItemHeaderValue : ICloneable
    {
        /// <summary>
        ///         データの送信を開始する位置を取得します。
        ///       </summary>
        /// <returns>
        ///         データの送信を開始する位置。
        ///       </returns>
        // Token: 0x170001E4 RID: 484
        // (get) Token: 0x0600093E RID: 2366 RVA: 0x0005A8DB File Offset: 0x0003A8DB
        public long? From
        {
            get
            {
                return this._from;
            }
        }

        /// <summary>
        ///         データの送信を終了する位置を取得します。
        ///       </summary>
        /// <returns>
        ///         データの送信を終了する位置。
        ///       </returns>
        // Token: 0x170001E5 RID: 485
        // (get) Token: 0x0600093F RID: 2367 RVA: 0x0005A8E3 File Offset: 0x0003A8E3
        public long? To
        {
            get
            {
                return this._to;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RangeItemHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="from">
        ///           データの送信を開始する位置。
        ///         </param>
        /// <param name="to">
        ///           データの送信を終了する位置。
        ///         </param>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///             <paramref name="from" /> は <paramref name="to" /> より大きい
        ///
        ///             または 
        ///
        ///             <paramref name="from" /> または <paramref name="to" /> が 0 未満です。
        ///           </exception>
        // Token: 0x06000940 RID: 2368 RVA: 0x0005A8EC File Offset: 0x0003A8EC
        public RangeItemHeaderValue(long? from, long? to)
        {
            if (from == null && to == null)
            {
                throw new ArgumentException(SR.net_http_headers_invalid_range);
            }
            if (from != null && from.Value < 0L)
            {
                throw new ArgumentOutOfRangeException("from");
            }
            if (to != null && to.Value < 0L)
            {
                throw new ArgumentOutOfRangeException("to");
            }
            if (from != null && to != null && from.Value > to.Value)
            {
                throw new ArgumentOutOfRangeException("from");
            }
            this._from = from;
            this._to = to;
        }

        // Token: 0x06000941 RID: 2369 RVA: 0x0005A995 File Offset: 0x0003A995
        private RangeItemHeaderValue(RangeItemHeaderValue source)
        {
            this._from = source._from;
            this._to = source._to;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.RangeItemHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x06000942 RID: 2370 RVA: 0x0005A9B8 File Offset: 0x0003A9B8
        public override string ToString()
        {
            if (this._from == null)
            {
                return "-" + this._to.Value.ToString(NumberFormatInfo.InvariantInfo);
            }
            if (this._to == null)
            {
                return this._from.Value.ToString(NumberFormatInfo.InvariantInfo) + "-";
            }
            return this._from.Value.ToString(NumberFormatInfo.InvariantInfo) + "-" + this._to.Value.ToString(NumberFormatInfo.InvariantInfo);
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.RangeItemHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000943 RID: 2371 RVA: 0x0005AA60 File Offset: 0x0003AA60
        public override bool Equals(object obj)
        {
            RangeItemHeaderValue rangeItemHeaderValue = obj as RangeItemHeaderValue;
            return rangeItemHeaderValue != null && this._from == rangeItemHeaderValue._from && this._to == rangeItemHeaderValue._to;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RangeItemHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x06000944 RID: 2372 RVA: 0x0005AAE0 File Offset: 0x0003AAE0
        public override int GetHashCode()
        {
            if (this._from == null)
            {
                return this._to.GetHashCode();
            }
            if (this._to == null)
            {
                return this._from.GetHashCode();
            }
            return this._from.GetHashCode() ^ this._to.GetHashCode();
        }

        // Token: 0x06000945 RID: 2373 RVA: 0x0005AB50 File Offset: 0x0003AB50
        internal static int GetRangeItemListLength(string input, int startIndex, ICollection<RangeItemHeaderValue> rangeCollection)
        {
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            bool flag = false;
            int num = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(input, startIndex, true, out flag);
            if (num == input.Length)
            {
                return 0;
            }
            RangeItemHeaderValue item = null;
            for (; ; )
            {
                int rangeItemLength = RangeItemHeaderValue.GetRangeItemLength(input, num, out item);
                if (rangeItemLength == 0)
                {
                    break;
                }
                rangeCollection.Add(item);
                num += rangeItemLength;
                num = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(input, num, true, out flag);
                if (num < input.Length && !flag)
                {
                    return 0;
                }
                if (num == input.Length)
                {
                    goto Block_6;
                }
            }
            return 0;
            Block_6:
            return num - startIndex;
        }

        // Token: 0x06000946 RID: 2374 RVA: 0x0005ABCC File Offset: 0x0003ABCC
        internal static int GetRangeItemLength(string input, int startIndex, out RangeItemHeaderValue parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            int numberLength = HttpRuleParser.GetNumberLength(input, startIndex, false);
            if (numberLength > 19)
            {
                return 0;
            }
            int num = startIndex + numberLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            if (num == input.Length || input[num] != '-')
            {
                return 0;
            }
            num++;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            int offset = num;
            int num2 = 0;
            if (num < input.Length)
            {
                num2 = HttpRuleParser.GetNumberLength(input, num, false);
                if (num2 > 19)
                {
                    return 0;
                }
                num += num2;
                num += HttpRuleParser.GetWhitespaceLength(input, num);
            }
            if (numberLength == 0 && num2 == 0)
            {
                return 0;
            }
            long num3 = 0L;
            if (numberLength > 0 && !HeaderUtilities.TryParseInt64(input, startIndex, numberLength, out num3))
            {
                return 0;
            }
            long num4 = 0L;
            if (num2 > 0 && !HeaderUtilities.TryParseInt64(input, offset, num2, out num4))
            {
                return 0;
            }
            if (numberLength > 0 && num2 > 0 && num3 > num4)
            {
                return 0;
            }
            parsedValue = new RangeItemHeaderValue((numberLength == 0) ? null : new long?(num3), (num2 == 0) ? null : new long?(num4));
            return num - startIndex;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.RangeItemHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x06000947 RID: 2375 RVA: 0x0005ACE3 File Offset: 0x0003ACE3
        object ICloneable.Clone()
        {
            return new RangeItemHeaderValue(this);
        }

        // Token: 0x0400060C RID: 1548
        private long? _from;

        // Token: 0x0400060D RID: 1549
        private long? _to;
    }


    /// <summary>
    ///         日付/時刻を指定できます Retry-after 後ヘッダー値か timespan の値を表します。
    ///       </summary>
    // Token: 0x02000148 RID: 328
    class RetryConditionHeaderValue : ICloneable
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> オブジェクトから日付と時刻のオフセットを取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> オブジェクトからの日付と時刻のオフセット。
        ///       </returns>
        // Token: 0x170001E6 RID: 486
        // (get) Token: 0x06000948 RID: 2376 RVA: 0x0005ACEB File Offset: 0x0003ACEB
        public DateTimeOffset? Date
        {
            get
            {
                return this._date;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> オブジェクトから秒単位のデルタを取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> オブジェクトからの秒単位のデルタ。
        ///       </returns>
        // Token: 0x170001E7 RID: 487
        // (get) Token: 0x06000949 RID: 2377 RVA: 0x0005ACF3 File Offset: 0x0003ACF3
        public TimeSpan? Delta
        {
            get
            {
                return this._delta;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="date">
        ///           日付と時刻のオフセットを新しいインスタンスを初期化するために使用します。
        ///         </param>
        // Token: 0x0600094A RID: 2378 RVA: 0x0005ACFB File Offset: 0x0003ACFB
        public RetryConditionHeaderValue(DateTimeOffset date)
        {
            this._date = new DateTimeOffset?(date);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="delta">
        ///           デルタを秒単位で新しいインスタンスを初期化するために使用します。
        ///         </param>
        // Token: 0x0600094B RID: 2379 RVA: 0x0005AD0F File Offset: 0x0003AD0F
        public RetryConditionHeaderValue(TimeSpan delta)
        {
            if (delta.TotalSeconds > 2147483647.0)
            {
                throw new ArgumentOutOfRangeException("delta");
            }
            this._delta = new TimeSpan?(delta);
        }

        // Token: 0x0600094C RID: 2380 RVA: 0x0005AD40 File Offset: 0x0003AD40
        private RetryConditionHeaderValue(RetryConditionHeaderValue source)
        {
            this._delta = source._delta;
            this._date = source._date;
        }

        // Token: 0x0600094D RID: 2381 RVA: 0x00035094 File Offset: 0x00015094
        private RetryConditionHeaderValue()
        {
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x0600094E RID: 2382 RVA: 0x0005AD60 File Offset: 0x0003AD60
        public override string ToString()
        {
            if (this._delta != null)
            {
                return ((int)this._delta.Value.TotalSeconds).ToString(NumberFormatInfo.InvariantInfo);
            }
            return HttpRuleParser.DateToString(this._date.Value);
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x0600094F RID: 2383 RVA: 0x0005ADAC File Offset: 0x0003ADAC
        public override bool Equals(object obj)
        {
            RetryConditionHeaderValue retryConditionHeaderValue = obj as RetryConditionHeaderValue;
            if (retryConditionHeaderValue == null)
            {
                return false;
            }
            if (this._delta != null)
            {
                return retryConditionHeaderValue._delta != null && this._delta.Value == retryConditionHeaderValue._delta.Value;
            }
            return retryConditionHeaderValue._date != null && this._date.Value == retryConditionHeaderValue._date.Value;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x06000950 RID: 2384 RVA: 0x0005AE28 File Offset: 0x0003AE28
        public override int GetHashCode()
        {
            if (this._delta == null)
            {
                return this._date.Value.GetHashCode();
            }
            return this._delta.Value.GetHashCode();
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           再試行の条件ヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は有効な再試行の条件ヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x06000951 RID: 2385 RVA: 0x0005AE78 File Offset: 0x0003AE78
        public static RetryConditionHeaderValue Parse(string input)
        {
            int num = 0;
            return (RetryConditionHeaderValue)GenericHeaderParser.RetryConditionParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000952 RID: 2386 RVA: 0x0005AE9C File Offset: 0x0003AE9C
        public static bool TryParse(string input, out RetryConditionHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.RetryConditionParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (RetryConditionHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x06000953 RID: 2387 RVA: 0x0005AECC File Offset: 0x0003AECC
        internal static int GetRetryConditionLength(string input, int startIndex, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            DateTimeOffset minValue = DateTimeOffset.MinValue;
            int num = -1;
            char c = input[startIndex];
            int num2;
            if (c >= '0' && c <= '9')
            {
                int numberLength = HttpRuleParser.GetNumberLength(input, startIndex, false);
                if (numberLength == 0 || numberLength > 10)
                {
                    return 0;
                }
                num2 = startIndex + numberLength;
                num2 += HttpRuleParser.GetWhitespaceLength(input, num2);
                if (num2 != input.Length)
                {
                    return 0;
                }
                if (!HeaderUtilities.TryParseInt32(input, startIndex, numberLength, out num))
                {
                    return 0;
                }
            }
            else
            {
                if (!HttpRuleParser.TryStringToDate(input.Substring(startIndex), out minValue))
                {
                    return 0;
                }
                num2 = input.Length;
            }
            RetryConditionHeaderValue retryConditionHeaderValue = new RetryConditionHeaderValue();
            if (num == -1)
            {
                retryConditionHeaderValue._date = new DateTimeOffset?(minValue);
            }
            else
            {
                retryConditionHeaderValue._delta = new TimeSpan?(new TimeSpan(0, 0, num));
            }
            parsedValue = retryConditionHeaderValue;
            return num2 - startIndex;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.RetryConditionHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x06000954 RID: 2388 RVA: 0x0005AF9C File Offset: 0x0003AF9C
        object ICloneable.Clone()
        {
            return new RetryConditionHeaderValue(this);
        }

        // Token: 0x0400060E RID: 1550
        private DateTimeOffset? _date;

        // Token: 0x0400060F RID: 1551
        private TimeSpan? _delta;
    }



    /// <summary>
    ///         品質に関する追加情報を持つ文字列ヘッダーの値を表します。
    ///       </summary>
    // Token: 0x02000149 RID: 329
    class StringWithQualityHeaderValue : ICloneable
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> オブジェクトから文字列値を取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> オブジェクトからの文字列値。
        ///       </returns>
        // Token: 0x170001E8 RID: 488
        // (get) Token: 0x06000955 RID: 2389 RVA: 0x0005AFA4 File Offset: 0x0003AFA4
        public string Value
        {
            get
            {
                return this._value;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> オブジェクトから品質要因を取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> オブジェクトからの品質要因。
        ///       </returns>
        // Token: 0x170001E9 RID: 489
        // (get) Token: 0x06000956 RID: 2390 RVA: 0x0005AFAC File Offset: 0x0003AFAC
        public double? Quality
        {
            get
            {
                return this._quality;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="value">
        ///           新しいインスタンスを初期化するために使用される文字列。
        ///         </param>
        // Token: 0x06000957 RID: 2391 RVA: 0x0005AFB4 File Offset: 0x0003AFB4
        public StringWithQualityHeaderValue(string value)
        {
            HeaderUtilities.CheckValidToken(value, "value");
            this._value = value;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="value">
        ///           新しいインスタンスを初期化するために使用される文字列。
        ///         </param>
        /// <param name="quality">
        ///           新しいインスタンスを初期化するために使用される品質係数。
        ///         </param>
        // Token: 0x06000958 RID: 2392 RVA: 0x0005AFD0 File Offset: 0x0003AFD0
        public StringWithQualityHeaderValue(string value, double quality)
        {
            HeaderUtilities.CheckValidToken(value, "value");
            if (quality < 0.0 || quality > 1.0)
            {
                throw new ArgumentOutOfRangeException("quality");
            }
            this._value = value;
            this._quality = new double?(quality);
        }

        // Token: 0x06000959 RID: 2393 RVA: 0x0005B024 File Offset: 0x0003B024
        private StringWithQualityHeaderValue(StringWithQualityHeaderValue source)
        {
            this._value = source._value;
            this._quality = source._quality;
        }

        // Token: 0x0600095A RID: 2394 RVA: 0x00035094 File Offset: 0x00015094
        private StringWithQualityHeaderValue()
        {
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x0600095B RID: 2395 RVA: 0x0005B044 File Offset: 0x0003B044
        public override string ToString()
        {
            if (this._quality != null)
            {
                return this._value + "; q=" + this._quality.Value.ToString("0.0##", NumberFormatInfo.InvariantInfo);
            }
            return this._value;
        }

        /// <summary>
        ///         指定したオブジェクトが、現在の <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x0600095C RID: 2396 RVA: 0x0005B094 File Offset: 0x0003B094
        public override bool Equals(object obj)
        {
            StringWithQualityHeaderValue stringWithQualityHeaderValue = obj as StringWithQualityHeaderValue;
            if (stringWithQualityHeaderValue == null)
            {
                return false;
            }
            if (!string.Equals(this._value, stringWithQualityHeaderValue._value, StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }
            if (this._quality != null)
            {
                return stringWithQualityHeaderValue._quality != null && this._quality.Value == stringWithQualityHeaderValue._quality.Value;
            }
            return stringWithQualityHeaderValue._quality == null;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x0600095D RID: 2397 RVA: 0x0005B108 File Offset: 0x0003B108
        public override int GetHashCode()
        {
            int num = StringComparer.OrdinalIgnoreCase.GetHashCode(this._value);
            if (this._quality != null)
            {
                num ^= this._quality.Value.GetHashCode();
            }
            return num;
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           品質のヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は、品質のヘッダー値の情報を含む、有効な文字列ではありません。
        ///           </exception>
        // Token: 0x0600095E RID: 2398 RVA: 0x0005B14C File Offset: 0x0003B14C
        public static StringWithQualityHeaderValue Parse(string input)
        {
            int num = 0;
            return (StringWithQualityHeaderValue)GenericHeaderParser.SingleValueStringWithQualityParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x0600095F RID: 2399 RVA: 0x0005B170 File Offset: 0x0003B170
        public static bool TryParse(string input, out StringWithQualityHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.SingleValueStringWithQualityParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (StringWithQualityHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x06000960 RID: 2400 RVA: 0x0005B1A0 File Offset: 0x0003B1A0
        internal static int GetStringWithQualityLength(string input, int startIndex, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            int tokenLength = HttpRuleParser.GetTokenLength(input, startIndex);
            if (tokenLength == 0)
            {
                return 0;
            }
            StringWithQualityHeaderValue stringWithQualityHeaderValue = new StringWithQualityHeaderValue();
            stringWithQualityHeaderValue._value = input.Substring(startIndex, tokenLength);
            int num = startIndex + tokenLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            if (num == input.Length || input[num] != ';')
            {
                parsedValue = stringWithQualityHeaderValue;
                return num - startIndex;
            }
            num++;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            if (!StringWithQualityHeaderValue.TryReadQuality(input, stringWithQualityHeaderValue, ref num))
            {
                return 0;
            }
            parsedValue = stringWithQualityHeaderValue;
            return num - startIndex;
        }

        // Token: 0x06000961 RID: 2401 RVA: 0x0005B230 File Offset: 0x0003B230
        private static bool TryReadQuality(string input, StringWithQualityHeaderValue result, ref int index)
        {
            int num = index;
            if (num == input.Length || (input[num] != 'q' && input[num] != 'Q'))
            {
                return false;
            }
            num++;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            if (num == input.Length || input[num] != '=')
            {
                return false;
            }
            num++;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            if (num == input.Length)
            {
                return false;
            }
            int numberLength = HttpRuleParser.GetNumberLength(input, num, true);
            if (numberLength == 0)
            {
                return false;
            }
            double num2 = 0.0;
            if (!double.TryParse(input.Substring(num, numberLength), NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out num2))
            {
                return false;
            }
            if (num2 < 0.0 || num2 > 1.0)
            {
                return false;
            }
            result._quality = new double?(num2);
            num += numberLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            index = num;
            return true;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.StringWithQualityHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x06000962 RID: 2402 RVA: 0x0005B308 File Offset: 0x0003B308
        object ICloneable.Clone()
        {
            return new StringWithQualityHeaderValue(this);
        }

        // Token: 0x04000610 RID: 1552
        private string _value;

        // Token: 0x04000611 RID: 1553
        private double? _quality;
    }


    // Token: 0x0200014A RID: 330
    internal class TimeSpanHeaderParser : BaseHeaderParser
    {
        // Token: 0x06000963 RID: 2403 RVA: 0x00059052 File Offset: 0x00039052
        private TimeSpanHeaderParser() : base(false)
        {
        }

        // Token: 0x06000964 RID: 2404 RVA: 0x0005B310 File Offset: 0x0003B310
        public override string ToString(object value)
        {
            return ((int)((TimeSpan)value).TotalSeconds).ToString(NumberFormatInfo.InvariantInfo);
        }

        // Token: 0x06000965 RID: 2405 RVA: 0x0005B33C File Offset: 0x0003B33C
        protected override int GetParsedValueLength(string value, int startIndex, object storeValue, out object parsedValue)
        {
            parsedValue = null;
            int numberLength = HttpRuleParser.GetNumberLength(value, startIndex, false);
            if (numberLength == 0 || numberLength > 10)
            {
                return 0;
            }
            int seconds = 0;
            if (!HeaderUtilities.TryParseInt32(value, startIndex, numberLength, out seconds))
            {
                return 0;
            }
            parsedValue = new TimeSpan(0, 0, seconds);
            return numberLength;
        }

        // Token: 0x04000612 RID: 1554
        internal static readonly TimeSpanHeaderParser Parser = new TimeSpanHeaderParser();
    }

    // Token: 0x0200014B RID: 331
    internal class TransferCodingHeaderParser : BaseHeaderParser
    {
        // Token: 0x06000967 RID: 2407 RVA: 0x0005B38D File Offset: 0x0003B38D
        private TransferCodingHeaderParser(bool supportsMultipleValues, Func<TransferCodingHeaderValue> transferCodingCreator) : base(supportsMultipleValues)
        {
            this._transferCodingCreator = transferCodingCreator;
        }

        // Token: 0x06000968 RID: 2408 RVA: 0x0005B3A0 File Offset: 0x0003B3A0
        protected override int GetParsedValueLength(string value, int startIndex, object storeValue, out object parsedValue)
        {
            TransferCodingHeaderValue transferCodingHeaderValue = null;
            int transferCodingLength = TransferCodingHeaderValue.GetTransferCodingLength(value, startIndex, this._transferCodingCreator, out transferCodingHeaderValue);
            parsedValue = transferCodingHeaderValue;
            return transferCodingLength;
        }

        // Token: 0x06000969 RID: 2409 RVA: 0x0005B3C4 File Offset: 0x0003B3C4
        private static TransferCodingHeaderValue CreateTransferCoding()
        {
            return new TransferCodingHeaderValue();
        }

        // Token: 0x0600096A RID: 2410 RVA: 0x0005B3CB File Offset: 0x0003B3CB
        private static TransferCodingHeaderValue CreateTransferCodingWithQuality()
        {
            return new TransferCodingWithQualityHeaderValue();
        }

        // Token: 0x04000613 RID: 1555
        private Func<TransferCodingHeaderValue> _transferCodingCreator;

        // Token: 0x04000614 RID: 1556
        internal static readonly TransferCodingHeaderParser SingleValueParser = new TransferCodingHeaderParser(false, new Func<TransferCodingHeaderValue>(TransferCodingHeaderParser.CreateTransferCoding));

        // Token: 0x04000615 RID: 1557
        internal static readonly TransferCodingHeaderParser MultipleValueParser = new TransferCodingHeaderParser(true, new Func<TransferCodingHeaderValue>(TransferCodingHeaderParser.CreateTransferCoding));

        // Token: 0x04000616 RID: 1558
        internal static readonly TransferCodingHeaderParser SingleValueWithQualityParser = new TransferCodingHeaderParser(false, new Func<TransferCodingHeaderValue>(TransferCodingHeaderParser.CreateTransferCodingWithQuality));

        // Token: 0x04000617 RID: 1559
        internal static readonly TransferCodingHeaderParser MultipleValueWithQualityParser = new TransferCodingHeaderParser(true, new Func<TransferCodingHeaderValue>(TransferCodingHeaderParser.CreateTransferCodingWithQuality));
    }

    /// <summary>
    ///         Accept-encoding ヘッダー値を表します。
    ///       </summary>
    // Token: 0x0200014C RID: 332
    class TransferCodingHeaderValue : ICloneable
    {
        /// <summary>
        ///         transfer-coding 値を取得します。
        ///       </summary>
        /// <returns>
        ///         transfer-coding 値。
        ///       </returns>
        // Token: 0x170001EA RID: 490
        // (get) Token: 0x0600096C RID: 2412 RVA: 0x0005B43D File Offset: 0x0003B43D
        public string Value
        {
            get
            {
                return this._value;
            }
        }

        /// <summary>
        ///         transfer-coding パラメーターを取得します。
        ///       </summary>
        /// <returns>
        ///         transfer-coding パラメーター。
        ///       </returns>
        // Token: 0x170001EB RID: 491
        // (get) Token: 0x0600096D RID: 2413 RVA: 0x0005B445 File Offset: 0x0003B445
        public ICollection<NameValueHeaderValue> Parameters
        {
            get
            {
                if (this._parameters == null)
                {
                    this._parameters = new ObjectCollection<NameValueHeaderValue>();
                }
                return this._parameters;
            }
        }

        // Token: 0x0600096E RID: 2414 RVA: 0x00035094 File Offset: 0x00015094
        internal TransferCodingHeaderValue()
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="source">
        ///           A <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> オブジェクトの新しいインスタンスを初期化するために使用します。
        ///         </param>
        // Token: 0x0600096F RID: 2415 RVA: 0x0005B460 File Offset: 0x0003B460
        protected TransferCodingHeaderValue(TransferCodingHeaderValue source)
        {
            this._value = source._value;
            if (source._parameters != null)
            {
                foreach (NameValueHeaderValue nameValueHeaderValue in source._parameters)
                {
                    this.Parameters.Add((NameValueHeaderValue)((ICloneable)nameValueHeaderValue).Clone());
                }
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="value">
        ///           新しいインスタンスを初期化するために使用される文字列。
        ///         </param>
        // Token: 0x06000970 RID: 2416 RVA: 0x0005B4DC File Offset: 0x0003B4DC
        public TransferCodingHeaderValue(string value)
        {
            HeaderUtilities.CheckValidToken(value, "value");
            this._value = value;
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           transfer-coding ヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は、有効な transfer-coding ヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x06000971 RID: 2417 RVA: 0x0005B4F8 File Offset: 0x0003B4F8
        public static TransferCodingHeaderValue Parse(string input)
        {
            int num = 0;
            return (TransferCodingHeaderValue)TransferCodingHeaderParser.SingleValueParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000972 RID: 2418 RVA: 0x0005B51C File Offset: 0x0003B51C
        public static bool TryParse(string input, out TransferCodingHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (TransferCodingHeaderParser.SingleValueParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (TransferCodingHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x06000973 RID: 2419 RVA: 0x0005B54C File Offset: 0x0003B54C
        internal static int GetTransferCodingLength(string input, int startIndex, Func<TransferCodingHeaderValue> transferCodingCreator, out TransferCodingHeaderValue parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            int tokenLength = HttpRuleParser.GetTokenLength(input, startIndex);
            if (tokenLength == 0)
            {
                return 0;
            }
            string value = input.Substring(startIndex, tokenLength);
            int num = startIndex + tokenLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            TransferCodingHeaderValue transferCodingHeaderValue;
            if (num >= input.Length || input[num] != ';')
            {
                transferCodingHeaderValue = transferCodingCreator();
                transferCodingHeaderValue._value = value;
                parsedValue = transferCodingHeaderValue;
                return num - startIndex;
            }
            transferCodingHeaderValue = transferCodingCreator();
            transferCodingHeaderValue._value = value;
            num++;
            int nameValueListLength = NameValueHeaderValue.GetNameValueListLength(input, num, ';', (ObjectCollection<NameValueHeaderValue>)transferCodingHeaderValue.Parameters);
            if (nameValueListLength == 0)
            {
                return 0;
            }
            parsedValue = transferCodingHeaderValue;
            return num + nameValueListLength - startIndex;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x06000974 RID: 2420 RVA: 0x0005B5F8 File Offset: 0x0003B5F8
        public override string ToString()
        {
            StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
            stringBuilder.Append(this._value);
            NameValueHeaderValue.ToString(this._parameters, ';', true, stringBuilder);
            return StringBuilderCache.GetStringAndRelease(stringBuilder);
        }

        /// <summary>
        ///         指定したオブジェクトが、現在の <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000975 RID: 2421 RVA: 0x0005B630 File Offset: 0x0003B630
        public override bool Equals(object obj)
        {
            TransferCodingHeaderValue transferCodingHeaderValue = obj as TransferCodingHeaderValue;
            return transferCodingHeaderValue != null && string.Equals(this._value, transferCodingHeaderValue._value, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections<NameValueHeaderValue>(this._parameters, transferCodingHeaderValue._parameters);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x06000976 RID: 2422 RVA: 0x0005B670 File Offset: 0x0003B670
        public override int GetHashCode()
        {
            return StringComparer.OrdinalIgnoreCase.GetHashCode(this._value) ^ NameValueHeaderValue.GetHashCode(this._parameters);
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.TransferCodingHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x06000977 RID: 2423 RVA: 0x0005B68E File Offset: 0x0003B68E
        object ICloneable.Clone()
        {
            return new TransferCodingHeaderValue(this);
        }

        // Token: 0x04000618 RID: 1560
        private ObjectCollection<NameValueHeaderValue> _parameters;

        // Token: 0x04000619 RID: 1561
        private string _value;
    }


    /// <summary>
    ///         Accept-encoding ヘッダー value.with 省略可能な品質係数を表します。
    ///       </summary>
    // Token: 0x0200014D RID: 333
    sealed class TransferCodingWithQualityHeaderValue : TransferCodingHeaderValue, ICloneable
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.TransferCodingWithQualityHeaderValue" /> から品質要因を取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.TransferCodingWithQualityHeaderValue" /> からの品質要因。
        ///       </returns>
        // Token: 0x170001EC RID: 492
        // (get) Token: 0x06000978 RID: 2424 RVA: 0x0005B696 File Offset: 0x0003B696
        // (set) Token: 0x06000979 RID: 2425 RVA: 0x0005B6A8 File Offset: 0x0003B6A8
        public double? Quality
        {
            get
            {
                return HeaderUtilities.GetQuality((ObjectCollection<NameValueHeaderValue>)base.Parameters);
            }
            set
            {
                HeaderUtilities.SetQuality((ObjectCollection<NameValueHeaderValue>)base.Parameters, value);
            }
        }

        // Token: 0x0600097A RID: 2426 RVA: 0x0005B6BB File Offset: 0x0003B6BB
        internal TransferCodingWithQualityHeaderValue()
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.TransferCodingWithQualityHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="value">
        ///           新しいインスタンスを初期化するために使用される文字列。
        ///         </param>
        // Token: 0x0600097B RID: 2427 RVA: 0x0005B6C3 File Offset: 0x0003B6C3
        public TransferCodingWithQualityHeaderValue(string value) : base(value)
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.TransferCodingWithQualityHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="value">
        ///           新しいインスタンスを初期化するために使用される文字列。
        ///         </param>
        /// <param name="quality">
        ///           品質の係数の値です。
        ///         </param>
        // Token: 0x0600097C RID: 2428 RVA: 0x0005B6CC File Offset: 0x0003B6CC
        public TransferCodingWithQualityHeaderValue(string value, double quality) : base(value)
        {
            this.Quality = new double?(quality);
        }

        // Token: 0x0600097D RID: 2429 RVA: 0x0005B6E1 File Offset: 0x0003B6E1
        private TransferCodingWithQualityHeaderValue(TransferCodingWithQualityHeaderValue source) : base(source)
        {
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.TransferCodingWithQualityHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x0600097E RID: 2430 RVA: 0x0005B6EA File Offset: 0x0003B6EA
        object ICloneable.Clone()
        {
            return new TransferCodingWithQualityHeaderValue(this);
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.TransferCodingWithQualityHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           transfer-coding 値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.TransferCodingWithQualityHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は、品質ヘッダー値の情報を持つ有効な転送コーディングではありません。
        ///           </exception>
        // Token: 0x0600097F RID: 2431 RVA: 0x0005B6F4 File Offset: 0x0003B6F4
        public new static TransferCodingWithQualityHeaderValue Parse(string input)
        {
            int num = 0;
            return (TransferCodingWithQualityHeaderValue)TransferCodingHeaderParser.SingleValueWithQualityParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.TransferCodingWithQualityHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.TransferCodingWithQualityHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.TransferCodingWithQualityHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000980 RID: 2432 RVA: 0x0005B718 File Offset: 0x0003B718
        public static bool TryParse(string input, out TransferCodingWithQualityHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (TransferCodingHeaderParser.SingleValueWithQualityParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (TransferCodingWithQualityHeaderValue)obj;
                return true;
            }
            return false;
        }
    }

    // Token: 0x0200014E RID: 334
    internal class UriHeaderParser : HttpHeaderParser
    {
        // Token: 0x06000981 RID: 2433 RVA: 0x0005B747 File Offset: 0x0003B747
        private UriHeaderParser(UriKind uriKind) : base(false)
        {
            this._uriKind = uriKind;
        }

        // Token: 0x06000982 RID: 2434 RVA: 0x0005B758 File Offset: 0x0003B758
        public override bool TryParseValue(string value, object storeValue, ref int index, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(value) || index == value.Length)
            {
                return false;
            }
            string text = value;
            if (index > 0)
            {
                text = value.Substring(index);
            }
            Uri uri;
            if (!Uri.TryCreate(text, this._uriKind, out uri))
            {
                text = UriHeaderParser.DecodeUtf8FromString(text);
                if (!Uri.TryCreate(text, this._uriKind, out uri))
                {
                    return false;
                }
            }
            index = value.Length;
            parsedValue = uri;
            return true;
        }

        // Token: 0x06000983 RID: 2435 RVA: 0x0005B7C4 File Offset: 0x0003B7C4
        internal static string DecodeUtf8FromString(string input)
        {
            if (string.IsNullOrWhiteSpace(input))
            {
                return input;
            }
            bool flag = false;
            for (int i = 0; i < input.Length; i++)
            {
                if (input[i] > 'ÿ')
                {
                    return input;
                }
                if (input[i] > '\u007f')
                {
                    flag = true;
                    break;
                }
            }
            if (flag)
            {
                byte[] array = new byte[input.Length];
                for (int j = 0; j < input.Length; j++)
                {
                    if (input[j] > 'ÿ')
                    {
                        return input;
                    }
                    array[j] = (byte)input[j];
                }
                try
                {
                    Encoding encoding = Encoding.GetEncoding("utf-8", EncoderFallback.ExceptionFallback, DecoderFallback.ExceptionFallback);
                    return encoding.GetString(array, 0, array.Length);
                }
                catch (ArgumentException)
                {
                }
                return input;
            }
            return input;
        }

        // Token: 0x06000984 RID: 2436 RVA: 0x0005B888 File Offset: 0x0003B888
        public override string ToString(object value)
        {
            Uri uri = (Uri)value;
            if (uri.IsAbsoluteUri)
            {
                return uri.AbsoluteUri;
            }
            return uri.GetComponents(UriComponents.SerializationInfoString, UriFormat.UriEscaped);
        }

        // Token: 0x0400061A RID: 1562
        private UriKind _uriKind;

        // Token: 0x0400061B RID: 1563
        internal static readonly UriHeaderParser RelativeOrAbsoluteUriParser = new UriHeaderParser(UriKind.RelativeOrAbsolute);
    }

    /// <summary>
    ///         Via ヘッダーの値を表します。
    ///       </summary>
    // Token: 0x0200014F RID: 335
    class ViaHeaderValue : ICloneable
    {
        /// <summary>
        ///         受信したプロトコルのプロトコル名を取得します。
        ///       </summary>
        /// <returns>
        ///         プロトコル名。
        ///       </returns>
        // Token: 0x170001ED RID: 493
        // (get) Token: 0x06000986 RID: 2438 RVA: 0x0005B8C4 File Offset: 0x0003B8C4
        public string ProtocolName
        {
            get
            {
                return this._protocolName;
            }
        }

        /// <summary>
        ///         受信したプロトコルのプロトコル バージョンを取得します。
        ///       </summary>
        /// <returns>
        ///         プロトコルのバージョン。
        ///       </returns>
        // Token: 0x170001EE RID: 494
        // (get) Token: 0x06000987 RID: 2439 RVA: 0x0005B8CC File Offset: 0x0003B8CC
        public string ProtocolVersion
        {
            get
            {
                return this._protocolVersion;
            }
        }

        /// <summary>
        ///         要求または応答を受信したホストとポートを取得します。
        ///       </summary>
        /// <returns>
        ///         要求または応答を受信したホストとポート。
        ///       </returns>
        // Token: 0x170001EF RID: 495
        // (get) Token: 0x06000988 RID: 2440 RVA: 0x0005B8D4 File Offset: 0x0003B8D4
        public string ReceivedBy
        {
            get
            {
                return this._receivedBy;
            }
        }

        /// <summary>
        ///         受信者のプロキシまたはゲートウェイのソフトウェアの識別に使用するコメント フィールドを取得します。
        ///       </summary>
        /// <returns>
        ///         受信者のプロキシまたはゲートウェイのソフトウェアの識別に使用するコメント フィールド。
        ///       </returns>
        // Token: 0x170001F0 RID: 496
        // (get) Token: 0x06000989 RID: 2441 RVA: 0x0005B8DC File Offset: 0x0003B8DC
        public string Comment
        {
            get
            {
                return this._comment;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="protocolVersion">
        ///           受信したプロトコルのプロトコルのバージョン。
        ///         </param>
        /// <param name="receivedBy">
        ///           ホストとポートによって受信された要求または応答をします。
        ///         </param>
        // Token: 0x0600098A RID: 2442 RVA: 0x0005B8E4 File Offset: 0x0003B8E4
        public ViaHeaderValue(string protocolVersion, string receivedBy) : this(protocolVersion, receivedBy, null, null)
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="protocolVersion">
        ///           受信したプロトコルのプロトコルのバージョン。
        ///         </param>
        /// <param name="receivedBy">
        ///           ホストとポートによって受信された要求または応答をします。
        ///         </param>
        /// <param name="protocolName">
        ///           受信したプロトコルのプロトコルの名前。
        ///         </param>
        // Token: 0x0600098B RID: 2443 RVA: 0x0005B8F0 File Offset: 0x0003B8F0
        public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName) : this(protocolVersion, receivedBy, protocolName, null)
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="protocolVersion">
        ///           受信したプロトコルのプロトコルのバージョン。
        ///         </param>
        /// <param name="receivedBy">
        ///           ホストとポートによって受信された要求または応答をします。
        ///         </param>
        /// <param name="protocolName">
        ///           受信したプロトコルのプロトコルの名前。
        ///         </param>
        /// <param name="comment">
        ///           コメント フィールドは、受信者のプロキシまたはゲートウェイのソフトウェアを識別するために使用します。
        ///         </param>
        // Token: 0x0600098C RID: 2444 RVA: 0x0005B8FC File Offset: 0x0003B8FC
        public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName, string comment)
        {
            HeaderUtilities.CheckValidToken(protocolVersion, "protocolVersion");
            ViaHeaderValue.CheckReceivedBy(receivedBy);
            if (!string.IsNullOrEmpty(protocolName))
            {
                HeaderUtilities.CheckValidToken(protocolName, "protocolName");
                this._protocolName = protocolName;
            }
            if (!string.IsNullOrEmpty(comment))
            {
                HeaderUtilities.CheckValidComment(comment, "comment");
                this._comment = comment;
            }
            this._protocolVersion = protocolVersion;
            this._receivedBy = receivedBy;
        }

        // Token: 0x0600098D RID: 2445 RVA: 0x00035094 File Offset: 0x00015094
        private ViaHeaderValue()
        {
        }

        // Token: 0x0600098E RID: 2446 RVA: 0x0005B965 File Offset: 0x0003B965
        private ViaHeaderValue(ViaHeaderValue source)
        {
            this._protocolName = source._protocolName;
            this._protocolVersion = source._protocolVersion;
            this._receivedBy = source._receivedBy;
            this._comment = source._comment;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x0600098F RID: 2447 RVA: 0x0005B9A0 File Offset: 0x0003B9A0
        public override string ToString()
        {
            StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
            if (!string.IsNullOrEmpty(this._protocolName))
            {
                stringBuilder.Append(this._protocolName);
                stringBuilder.Append('/');
            }
            stringBuilder.Append(this._protocolVersion);
            stringBuilder.Append(' ');
            stringBuilder.Append(this._receivedBy);
            if (!string.IsNullOrEmpty(this._comment))
            {
                stringBuilder.Append(' ');
                stringBuilder.Append(this._comment);
            }
            return StringBuilderCache.GetStringAndRelease(stringBuilder);
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000990 RID: 2448 RVA: 0x0005BA24 File Offset: 0x0003BA24
        public override bool Equals(object obj)
        {
            ViaHeaderValue viaHeaderValue = obj as ViaHeaderValue;
            return viaHeaderValue != null && (string.Equals(this._protocolVersion, viaHeaderValue._protocolVersion, StringComparison.OrdinalIgnoreCase) && string.Equals(this._receivedBy, viaHeaderValue._receivedBy, StringComparison.OrdinalIgnoreCase) && string.Equals(this._protocolName, viaHeaderValue._protocolName, StringComparison.OrdinalIgnoreCase)) && string.Equals(this._comment, viaHeaderValue._comment, StringComparison.Ordinal);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コードを返します。
        ///       </returns>
        // Token: 0x06000991 RID: 2449 RVA: 0x0005BA90 File Offset: 0x0003BA90
        public override int GetHashCode()
        {
            int num = StringComparer.OrdinalIgnoreCase.GetHashCode(this._protocolVersion) ^ StringComparer.OrdinalIgnoreCase.GetHashCode(this._receivedBy);
            if (!string.IsNullOrEmpty(this._protocolName))
            {
                num ^= StringComparer.OrdinalIgnoreCase.GetHashCode(this._protocolName);
            }
            if (!string.IsNullOrEmpty(this._comment))
            {
                num ^= this._comment.GetHashCode();
            }
            return num;
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           Via ヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> のインスタンス。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は有効な Via ヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x06000992 RID: 2450 RVA: 0x0005BAFC File Offset: 0x0003BAFC
        public static ViaHeaderValue Parse(string input)
        {
            int num = 0;
            return (ViaHeaderValue)GenericHeaderParser.SingleValueViaParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000993 RID: 2451 RVA: 0x0005BB20 File Offset: 0x0003BB20
        public static bool TryParse(string input, out ViaHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.SingleValueViaParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (ViaHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x06000994 RID: 2452 RVA: 0x0005BB50 File Offset: 0x0003BB50
        internal static int GetViaLength(string input, int startIndex, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            string protocolName = null;
            string protocolVersion = null;
            int num = ViaHeaderValue.GetProtocolEndIndex(input, startIndex, out protocolName, out protocolVersion);
            if (num == startIndex || num == input.Length)
            {
                return 0;
            }
            string receivedBy = null;
            int hostLength = HttpRuleParser.GetHostLength(input, num, true, out receivedBy);
            if (hostLength == 0)
            {
                return 0;
            }
            num += hostLength;
            num += HttpRuleParser.GetWhitespaceLength(input, num);
            string comment = null;
            if (num < input.Length && input[num] == '(')
            {
                int num2 = 0;
                if (HttpRuleParser.GetCommentLength(input, num, out num2) != HttpParseResult.Parsed)
                {
                    return 0;
                }
                comment = input.Substring(num, num2);
                num += num2;
                num += HttpRuleParser.GetWhitespaceLength(input, num);
            }
            parsedValue = new ViaHeaderValue
            {
                _protocolVersion = protocolVersion,
                _protocolName = protocolName,
                _receivedBy = receivedBy,
                _comment = comment
            };
            return num - startIndex;
        }

        // Token: 0x06000995 RID: 2453 RVA: 0x0005BC28 File Offset: 0x0003BC28
        private static int GetProtocolEndIndex(string input, int startIndex, out string protocolName, out string protocolVersion)
        {
            protocolName = null;
            protocolVersion = null;
            int tokenLength = HttpRuleParser.GetTokenLength(input, startIndex);
            if (tokenLength == 0)
            {
                return 0;
            }
            int num = startIndex + tokenLength;
            int whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, num);
            num += whitespaceLength;
            if (num == input.Length)
            {
                return 0;
            }
            if (input[num] == '/')
            {
                protocolName = input.Substring(startIndex, tokenLength);
                num++;
                num += HttpRuleParser.GetWhitespaceLength(input, num);
                tokenLength = HttpRuleParser.GetTokenLength(input, num);
                if (tokenLength == 0)
                {
                    return 0;
                }
                protocolVersion = input.Substring(num, tokenLength);
                num += tokenLength;
                whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, num);
                num += whitespaceLength;
            }
            else
            {
                protocolVersion = input.Substring(startIndex, tokenLength);
            }
            if (whitespaceLength == 0)
            {
                return 0;
            }
            return num;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.ViaHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピー。
        ///       </returns>
        // Token: 0x06000996 RID: 2454 RVA: 0x0005BCC1 File Offset: 0x0003BCC1
        object ICloneable.Clone()
        {
            return new ViaHeaderValue(this);
        }

        // Token: 0x06000997 RID: 2455 RVA: 0x0005BCCC File Offset: 0x0003BCCC
        private static void CheckReceivedBy(string receivedBy)
        {
            if (string.IsNullOrEmpty(receivedBy))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, "receivedBy");
            }
            string text = null;
            if (HttpRuleParser.GetHostLength(receivedBy, 0, true, out text) != receivedBy.Length)
            {
                throw new FormatException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, receivedBy));
            }
        }

        // Token: 0x0400061C RID: 1564
        private string _protocolName;

        // Token: 0x0400061D RID: 1565
        private string _protocolVersion;

        // Token: 0x0400061E RID: 1566
        private string _receivedBy;

        // Token: 0x0400061F RID: 1567
        private string _comment;
    }


    /// <summary>
    ///         Warning ヘッダーで使用される警告の値を表します。
    ///       </summary>
    // Token: 0x02000150 RID: 336
    class WarningHeaderValue : ICloneable
    {
        /// <summary>
        ///         特定の警告コードを取得します。
        ///       </summary>
        /// <returns>
        ///         特定の警告コード。
        ///       </returns>
        // Token: 0x170001F1 RID: 497
        // (get) Token: 0x06000998 RID: 2456 RVA: 0x0005BD1B File Offset: 0x0003BD1B
        public int Code
        {
            get
            {
                return this._code;
            }
        }

        /// <summary>
        ///         この警告をアタッチしたホストを取得します。
        ///       </summary>
        /// <returns>
        ///         この警告をアタッチしたホスト。
        ///       </returns>
        // Token: 0x170001F2 RID: 498
        // (get) Token: 0x06000999 RID: 2457 RVA: 0x0005BD23 File Offset: 0x0003BD23
        public string Agent
        {
            get
            {
                return this._agent;
            }
        }

        /// <summary>
        ///         警告テキストを含む、引用符で囲まれた文字列を取得します。
        ///       </summary>
        /// <returns>
        ///         警告テキストを含む、引用符で囲まれた文字列。
        ///       </returns>
        // Token: 0x170001F3 RID: 499
        // (get) Token: 0x0600099A RID: 2458 RVA: 0x0005BD2B File Offset: 0x0003BD2B
        public string Text
        {
            get
            {
                return this._text;
            }
        }

        /// <summary>
        ///         警告の日付/時刻スタンプを取得します。
        ///       </summary>
        /// <returns>
        ///         警告の日付/時刻スタンプ。
        ///       </returns>
        // Token: 0x170001F4 RID: 500
        // (get) Token: 0x0600099B RID: 2459 RVA: 0x0005BD33 File Offset: 0x0003BD33
        public DateTimeOffset? Date
        {
            get
            {
                return this._date;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.WarningHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="code">
        ///           特定の警告コード。
        ///         </param>
        /// <param name="agent">
        ///           警告を接続するホスト。
        ///         </param>
        /// <param name="text">
        ///           引用符で囲まれた-、警告テキストを含む文字列。
        ///         </param>
        // Token: 0x0600099C RID: 2460 RVA: 0x0005BD3B File Offset: 0x0003BD3B
        public WarningHeaderValue(int code, string agent, string text)
        {
            WarningHeaderValue.CheckCode(code);
            WarningHeaderValue.CheckAgent(agent);
            HeaderUtilities.CheckValidQuotedString(text, "text");
            this._code = code;
            this._agent = agent;
            this._text = text;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.WarningHeaderValue" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="code">
        ///           特定の警告コード。
        ///         </param>
        /// <param name="agent">
        ///           警告を接続するホスト。
        ///         </param>
        /// <param name="text">
        ///           引用符で囲まれた-、警告テキストを含む文字列。
        ///         </param>
        /// <param name="date">
        ///           警告の日付/時刻のタイムスタンプ。
        ///         </param>
        // Token: 0x0600099D RID: 2461 RVA: 0x0005BD70 File Offset: 0x0003BD70
        public WarningHeaderValue(int code, string agent, string text, DateTimeOffset date)
        {
            WarningHeaderValue.CheckCode(code);
            WarningHeaderValue.CheckAgent(agent);
            HeaderUtilities.CheckValidQuotedString(text, "text");
            this._code = code;
            this._agent = agent;
            this._text = text;
            this._date = new DateTimeOffset?(date);
        }

        // Token: 0x0600099E RID: 2462 RVA: 0x00035094 File Offset: 0x00015094
        private WarningHeaderValue()
        {
        }

        // Token: 0x0600099F RID: 2463 RVA: 0x0005BDBC File Offset: 0x0003BDBC
        private WarningHeaderValue(WarningHeaderValue source)
        {
            this._code = source._code;
            this._agent = source._agent;
            this._text = source._text;
            this._date = source._date;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.WarningHeaderValue" /> オブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトを表す文字列。
        ///       </returns>
        // Token: 0x060009A0 RID: 2464 RVA: 0x0005BDF4 File Offset: 0x0003BDF4
        public override string ToString()
        {
            StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
            stringBuilder.Append(this._code.ToString("000", NumberFormatInfo.InvariantInfo));
            stringBuilder.Append(' ');
            stringBuilder.Append(this._agent);
            stringBuilder.Append(' ');
            stringBuilder.Append(this._text);
            if (this._date != null)
            {
                stringBuilder.Append(" \"");
                stringBuilder.Append(HttpRuleParser.DateToString(this._date.Value));
                stringBuilder.Append('"');
            }
            return StringBuilderCache.GetStringAndRelease(stringBuilder);
        }

        /// <summary>
        ///         指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Net.Http.Headers.WarningHeaderValue" /> オブジェクトと等しいかどうかを判断します。
        ///       </summary>
        /// <param name="obj">
        ///           現在のオブジェクトと比較するオブジェクト。
        ///         </param>
        /// <returns>
        ///         指定した <see cref="T:System.Object" /> が現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060009A1 RID: 2465 RVA: 0x0005BE90 File Offset: 0x0003BE90
        public override bool Equals(object obj)
        {
            WarningHeaderValue warningHeaderValue = obj as WarningHeaderValue;
            if (warningHeaderValue == null)
            {
                return false;
            }
            if (this._code != warningHeaderValue._code || !string.Equals(this._agent, warningHeaderValue._agent, StringComparison.OrdinalIgnoreCase) || !string.Equals(this._text, warningHeaderValue._text, StringComparison.Ordinal))
            {
                return false;
            }
            if (this._date != null)
            {
                return warningHeaderValue._date != null && this._date.Value == warningHeaderValue._date.Value;
            }
            return warningHeaderValue._date == null;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.Headers.WarningHeaderValue" /> オブジェクトのハッシュ関数として機能します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトのハッシュ コード。
        ///       </returns>
        // Token: 0x060009A2 RID: 2466 RVA: 0x0005BF28 File Offset: 0x0003BF28
        public override int GetHashCode()
        {
            int num = this._code.GetHashCode() ^ StringComparer.OrdinalIgnoreCase.GetHashCode(this._agent) ^ this._text.GetHashCode();
            if (this._date != null)
            {
                num ^= this._date.Value.GetHashCode();
            }
            return num;
        }

        /// <summary>
        ///         文字列を <see cref="T:System.Net.Http.Headers.WarningHeaderValue" /> インスタンスに変換します。
        ///       </summary>
        /// <param name="input">
        ///           認証ヘッダー値の情報を表す文字列。
        ///         </param>
        /// <returns>
        ///         <see cref="T:System.Net.Http.Headers.WarningHeaderValue" /> インスタンスを返します。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="input" /> は <see langword="null" /> の参照です。
        ///           </exception>
        /// <exception cref="T:System.FormatException">
        ///             <paramref name="input" /> は有効な認証ヘッダー値の情報ではありません。
        ///           </exception>
        // Token: 0x060009A3 RID: 2467 RVA: 0x0005BF88 File Offset: 0x0003BF88
        public static WarningHeaderValue Parse(string input)
        {
            int num = 0;
            return (WarningHeaderValue)GenericHeaderParser.SingleValueWarningParser.ParseValue(input, null, ref num);
        }

        /// <summary>
        ///         文字列が有効な <see cref="T:System.Net.Http.Headers.WarningHeaderValue" /> 情報かどうかを判断します。
        ///       </summary>
        /// <param name="input">
        ///           検証対象の文字列。
        ///         </param>
        /// <param name="parsedValue">
        ///           文字列の <see cref="T:System.Net.Http.Headers.WarningHeaderValue" /> バージョン。
        ///         </param>
        /// <returns>
        ///         <paramref name="input" /> が有効な <see cref="T:System.Net.Http.Headers.WarningHeaderValue" /> 情報の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060009A4 RID: 2468 RVA: 0x0005BFAC File Offset: 0x0003BFAC
        public static bool TryParse(string input, out WarningHeaderValue parsedValue)
        {
            int num = 0;
            parsedValue = null;
            object obj;
            if (GenericHeaderParser.SingleValueWarningParser.TryParseValue(input, null, ref num, out obj))
            {
                parsedValue = (WarningHeaderValue)obj;
                return true;
            }
            return false;
        }

        // Token: 0x060009A5 RID: 2469 RVA: 0x0005BFDC File Offset: 0x0003BFDC
        internal static int GetWarningLength(string input, int startIndex, out object parsedValue)
        {
            parsedValue = null;
            if (string.IsNullOrEmpty(input) || startIndex >= input.Length)
            {
                return 0;
            }
            int num = startIndex;
            int code;
            if (!WarningHeaderValue.TryReadCode(input, ref num, out code))
            {
                return 0;
            }
            string agent;
            if (!WarningHeaderValue.TryReadAgent(input, num, ref num, out agent))
            {
                return 0;
            }
            int num2 = 0;
            int startIndex2 = num;
            if (HttpRuleParser.GetQuotedStringLength(input, num, out num2) != HttpParseResult.Parsed)
            {
                return 0;
            }
            num += num2;
            DateTimeOffset? date = null;
            if (!WarningHeaderValue.TryReadDate(input, ref num, out date))
            {
                return 0;
            }
            parsedValue = new WarningHeaderValue
            {
                _code = code,
                _agent = agent,
                _text = input.Substring(startIndex2, num2),
                _date = date
            };
            return num - startIndex;
        }

        // Token: 0x060009A6 RID: 2470 RVA: 0x0005C084 File Offset: 0x0003C084
        private static bool TryReadAgent(string input, int startIndex, ref int current, out string agent)
        {
            agent = null;
            int hostLength = HttpRuleParser.GetHostLength(input, startIndex, true, out agent);
            if (hostLength == 0)
            {
                return false;
            }
            current += hostLength;
            int whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
            current += whitespaceLength;
            return whitespaceLength != 0 && current != input.Length;
        }

        // Token: 0x060009A7 RID: 2471 RVA: 0x0005C0C8 File Offset: 0x0003C0C8
        private static bool TryReadCode(string input, ref int current, out int code)
        {
            code = 0;
            int numberLength = HttpRuleParser.GetNumberLength(input, current, false);
            if (numberLength == 0 || numberLength > 3)
            {
                return false;
            }
            if (!HeaderUtilities.TryParseInt32(input, current, numberLength, out code))
            {
                return false;
            }
            current += numberLength;
            int whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
            current += whitespaceLength;
            return whitespaceLength != 0 && current != input.Length;
        }

        // Token: 0x060009A8 RID: 2472 RVA: 0x0005C120 File Offset: 0x0003C120
        private static bool TryReadDate(string input, ref int current, out DateTimeOffset? date)
        {
            date = null;
            int whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
            current += whitespaceLength;
            if (current < input.Length && input[current] == '"')
            {
                if (whitespaceLength == 0)
                {
                    return false;
                }
                current++;
                int num = current;
                while (current < input.Length && input[current] != '"')
                {
                    current++;
                }
                if (current == input.Length || current == num)
                {
                    return false;
                }
                DateTimeOffset value;
                if (!HttpRuleParser.TryStringToDate(input.Substring(num, current - num), out value))
                {
                    return false;
                }
                date = new DateTimeOffset?(value);
                current++;
                current += HttpRuleParser.GetWhitespaceLength(input, current);
            }
            return true;
        }

        /// <summary>
        ///         現在の <see cref="T:System.Net.Http.Headers.WarningHeaderValue" /> インスタンスのコピーである新しいオブジェクトを作成します。
        ///       </summary>
        /// <returns>
        ///         現在のインスタンスのコピーを返します。
        ///       </returns>
        // Token: 0x060009A9 RID: 2473 RVA: 0x0005C1CC File Offset: 0x0003C1CC
        object ICloneable.Clone()
        {
            return new WarningHeaderValue(this);
        }

        // Token: 0x060009AA RID: 2474 RVA: 0x0005C1D4 File Offset: 0x0003C1D4
        private static void CheckCode(int code)
        {
            if (code < 0 || code > 999)
            {
                throw new ArgumentOutOfRangeException("code");
            }
        }

        // Token: 0x060009AB RID: 2475 RVA: 0x0005C1F0 File Offset: 0x0003C1F0
        private static void CheckAgent(string agent)
        {
            if (string.IsNullOrEmpty(agent))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, "agent");
            }
            string text = null;
            if (HttpRuleParser.GetHostLength(agent, 0, true, out text) != agent.Length)
            {
                throw new FormatException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, agent));
            }
        }

        // Token: 0x04000620 RID: 1568
        private int _code;

        // Token: 0x04000621 RID: 1569
        private string _agent;

        // Token: 0x04000622 RID: 1570
        private string _text;

        // Token: 0x04000623 RID: 1571
        private DateTimeOffset? _date;
    }

    // Token: 0x02000042 RID: 66
    internal static class StringExtensions
    {
        // Token: 0x060000F3 RID: 243 RVA: 0x00035638 File Offset: 0x00015638
        internal static string _SubstringTrim(this string value, int startIndex, int length)
        {
            if (length == 0)
            {
                return string.Empty;
            }
            int num = startIndex + length - 1;
            while (startIndex <= num)
            {
                if (!char.IsWhiteSpace(value[startIndex]))
                {
                    break;
                }
                startIndex++;
            }
            while (num >= startIndex && char.IsWhiteSpace(value[num]))
            {
                num--;
            }
            int num2 = num - startIndex + 1;
            if (num2 == 0)
            {
                return string.Empty;
            }
            if (num2 != value.Length)
            {
                return value.Substring(startIndex, num2);
            }
            return value;
        }
    }

    // Token: 0x02000040 RID: 64
    internal static class ByteArrayHelpers
    {
        // Token: 0x060000ED RID: 237 RVA: 0x0003557C File Offset: 0x0001557C
        internal unsafe static bool EqualsOrdinalAsciiIgnoreCase(string left, ReadOnlySpan<byte> right)
        {
            if (left.Length != right.Length)
            {
                return false;
            }
            for (int i = 0; i < left.Length; i++)
            {
                uint num = (uint)left[i];
                uint num2 = (uint)(right[i]);
                if (num - 97u <= 25u)
                {
                    num -= 32u;
                }
                if (num2 - 97u <= 25u)
                {
                    num2 -= 32u;
                }
                if (num != num2)
                {
                    return false;
                }
            }
            return true;
        }
    }

    // Token: 0x02000041 RID: 65
    internal sealed class StrongToWeakReference<T> : WeakReference where T : class
    {
        // Token: 0x060000EE RID: 238 RVA: 0x000355DE File Offset: 0x000155DE
        public StrongToWeakReference(T obj) : base(obj)
        {
            this._strongRef = obj;
        }

        // Token: 0x060000EF RID: 239 RVA: 0x000355F3 File Offset: 0x000155F3
        public void MakeWeak()
        {
            this._strongRef = default(T);
        }

        // Token: 0x060000F0 RID: 240 RVA: 0x00035601 File Offset: 0x00015601
        public void MakeStrong()
        {
            this._strongRef = this.WeakTarget;
        }

        // Token: 0x1700001C RID: 28
        // (get) Token: 0x060000F1 RID: 241 RVA: 0x0003560F File Offset: 0x0001560F
        public new T Target
        {
            get
            {
                T result;
                if ((result = this._strongRef) == null)
                {
                    result = this.WeakTarget;
                }
                return result;
            }
        }

        // Token: 0x1700001D RID: 29
        // (get) Token: 0x060000F2 RID: 242 RVA: 0x00035626 File Offset: 0x00015626
        private T WeakTarget
        {
            get
            {
                return base.Target as T;
            }
        }

        // Token: 0x04000115 RID: 277
        private T _strongRef;
    }


    // Token: 0x02000047 RID: 71
    internal class ConcurrentQueue<T>
    {
        // Token: 0x02000048 RID: 72
        internal sealed class Segment
        {
            // Token: 0x0600015E RID: 350 RVA: 0x00035D8C File Offset: 0x00015D8C
            public Segment(int boundedLength)
            {
                this._slots = new ConcurrentQueue<T>.Segment.Slot[boundedLength];
                this._slotsMask = boundedLength - 1;
                for (int i = 0; i < this._slots.Length; i++)
                {
                    this._slots[i].SequenceNumber = i;
                }
            }

            // Token: 0x0600015F RID: 351 RVA: 0x00035DD9 File Offset: 0x00015DD9
            internal static int RoundUpToPowerOf2(int i)
            {
                i--;
                i |= i >> 1;
                i |= i >> 2;
                i |= i >> 4;
                i |= i >> 8;
                i |= i >> 16;
                return i + 1;
            }

            // Token: 0x1700007B RID: 123
            // (get) Token: 0x06000160 RID: 352 RVA: 0x00035E07 File Offset: 0x00015E07
            internal int Capacity
            {
                get
                {
                    return this._slots.Length;
                }
            }

            // Token: 0x1700007C RID: 124
            // (get) Token: 0x06000161 RID: 353 RVA: 0x00035E11 File Offset: 0x00015E11
            internal int FreezeOffset
            {
                get
                {
                    return this._slots.Length * 2;
                }
            }

            // Token: 0x06000162 RID: 354 RVA: 0x00035E20 File Offset: 0x00015E20
            public bool TryDequeue(out T item)
            {
                SpinWait spinWait = default(SpinWait);
                int num;
                int num2;
                for (; ; )
                {
                    num = Volatile.Read(ref this._headAndTail.Head);
                    num2 = (num & this._slotsMask);
                    int num3 = Volatile.Read(ref this._slots[num2].SequenceNumber);
                    int num4 = num3 - (num + 1);
                    if (num4 == 0)
                    {
                        if (Interlocked.CompareExchange(ref this._headAndTail.Head, num + 1, num) == num)
                        {
                            break;
                        }
                    }
                    else if (num4 < 0)
                    {
                        bool frozenForEnqueues = this._frozenForEnqueues;
                        int num5 = Volatile.Read(ref this._headAndTail.Tail);
                        if (num5 - num <= 0 || (frozenForEnqueues && num5 - this.FreezeOffset - num <= 0))
                        {
                            goto IL_F3;
                        }
                    }
                    spinWait.SpinOnce();
                }
                item = this._slots[num2].Item;
                if (!Volatile.Read(ref this._preservedForObservation))
                {
                    this._slots[num2].Item = default(T);
                    Volatile.Write(ref this._slots[num2].SequenceNumber, num + this._slots.Length);
                }
                return true;
                IL_F3:
                item = default(T);
                return false;
            }

            // Token: 0x06000163 RID: 355 RVA: 0x00035F34 File Offset: 0x00015F34
            public bool TryEnqueue(T item)
            {
                SpinWait spinWait = default(SpinWait);
                int num;
                int num2;
                for (; ; )
                {
                    num = Volatile.Read(ref this._headAndTail.Tail);
                    num2 = (num & this._slotsMask);
                    int num3 = Volatile.Read(ref this._slots[num2].SequenceNumber);
                    int num4 = num3 - num;
                    if (num4 == 0)
                    {
                        if (Interlocked.CompareExchange(ref this._headAndTail.Tail, num + 1, num) == num)
                        {
                            break;
                        }
                    }
                    else if (num4 < 0)
                    {
                        return false;
                    }
                    spinWait.SpinOnce();
                }
                this._slots[num2].Item = item;
                Volatile.Write(ref this._slots[num2].SequenceNumber, num + 1);
                return true;
            }

            // Token: 0x0400011D RID: 285
            internal readonly ConcurrentQueue<T>.Segment.Slot[] _slots;

            // Token: 0x0400011E RID: 286
            internal readonly int _slotsMask;

            // Token: 0x0400011F RID: 287
            internal PaddedHeadAndTail _headAndTail;

            // Token: 0x04000120 RID: 288
            internal bool _preservedForObservation;

            // Token: 0x04000121 RID: 289
            internal bool _frozenForEnqueues = false;

            // Token: 0x02000049 RID: 73
            internal struct Slot
            {
                // Token: 0x04000122 RID: 290
                public T Item;

                // Token: 0x04000123 RID: 291
                public int SequenceNumber;
            }
        }
    }

    // Token: 0x0200004A RID: 74
    [DebuggerDisplay("Head = {Head}, Tail = {Tail}")]
    [StructLayout(LayoutKind.Explicit, Size = 384)]
    internal struct PaddedHeadAndTail
    {
        // Token: 0x04000124 RID: 292
        [FieldOffset(128)]
        public int Head;

        // Token: 0x04000125 RID: 293
        [FieldOffset(256)]
        public int Tail;
    }


    // Token: 0x0200004C RID: 76
    internal sealed class ReadOnlyMemoryStream : Stream
    {
        // Token: 0x06000165 RID: 357 RVA: 0x0003606D File Offset: 0x0001606D
        public ReadOnlyMemoryStream(ReadOnlyMemory<byte> content)
        {
            this._content = content;
        }

        // Token: 0x1700007D RID: 125
        // (get) Token: 0x06000166 RID: 358 RVA: 0x0003607C File Offset: 0x0001607C
        public override bool CanRead
        {
            get
            {
                return true;
            }
        }

        // Token: 0x1700007E RID: 126
        // (get) Token: 0x06000167 RID: 359 RVA: 0x0003607C File Offset: 0x0001607C
        public override bool CanSeek
        {
            get
            {
                return true;
            }
        }

        // Token: 0x1700007F RID: 127
        // (get) Token: 0x06000168 RID: 360 RVA: 0x000356C2 File Offset: 0x000156C2
        public override bool CanWrite
        {
            get
            {
                return false;
            }
        }

        // Token: 0x17000080 RID: 128
        // (get) Token: 0x06000169 RID: 361 RVA: 0x0003607F File Offset: 0x0001607F
        public override long Length
        {
            get
            {
                return (long)this._content.Length;
            }
        }

        // Token: 0x17000081 RID: 129
        // (get) Token: 0x0600016A RID: 362 RVA: 0x0003608D File Offset: 0x0001608D
        // (set) Token: 0x0600016B RID: 363 RVA: 0x00036096 File Offset: 0x00016096
        public override long Position
        {
            get
            {
                return (long)this._position;
            }
            set
            {
                if (value < 0L || value > 2147483647L)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                this._position = (int)value;
            }
        }

        // Token: 0x0600016C RID: 364 RVA: 0x000360BC File Offset: 0x000160BC
        public override long Seek(long offset, SeekOrigin origin)
        {
            long num;
            if (origin != SeekOrigin.Begin)
            {
                if (origin != SeekOrigin.Current)
                {
                    if (origin != SeekOrigin.End)
                    {
                        throw new ArgumentOutOfRangeException("origin");
                    }
                    num = (long)this._content.Length + offset;
                }
                else
                {
                    num = (long)this._position + offset;
                }
            }
            else
            {
                num = offset;
            }
            long num2 = num;
            if (num2 > 2147483647L)
            {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (num2 < 0L)
            {
                throw new IOException(SR.IO_SeekBeforeBegin);
            }
            this._position = (int)num2;
            return (long)this._position;
        }

        // Token: 0x0600016D RID: 365 RVA: 0x00036130 File Offset: 0x00016130
        public unsafe override int ReadByte()
        {
            ReadOnlySpan<byte> span = this._content.Span;
            if (this._position >= span.Length)
            {
                return -1;
            }
            int position = this._position;
            this._position = position + 1;
            return (int)(span[position]);
        }

        // Token: 0x0600016E RID: 366 RVA: 0x00036173 File Offset: 0x00016173
        public override int Read(byte[] buffer, int offset, int count)
        {
            ReadOnlyMemoryStream.ValidateReadArrayArguments(buffer, offset, count);
            return this.Read(new Span<byte>(buffer, offset, count));
        }

        // Token: 0x0600016F RID: 367 RVA: 0x0003618C File Offset: 0x0001618C
        public override int Read(Span<byte> buffer)
        {
            int num = this._content.Length - this._position;
            if (num <= 0 || buffer.Length == 0)
            {
                return 0;
            }
            if (num <= buffer.Length)
            {
                this._content.Span.Slice(this._position).CopyTo(buffer);
                this._position = this._content.Length;
                return num;
            }
            this._content.Span.Slice(this._position, buffer.Length).CopyTo(buffer);
            this._position += buffer.Length;
            return buffer.Length;
        }

        // Token: 0x06000170 RID: 368 RVA: 0x0003623E File Offset: 0x0001623E
        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            ReadOnlyMemoryStream.ValidateReadArrayArguments(buffer, offset, count);
            if (!cancellationToken.IsCancellationRequested)
            {
                return Task.FromResult<int>(this.Read(new Span<byte>(buffer, offset, count)));
            }
            return Task.FromCanceled<int>(cancellationToken);
        }

        // Token: 0x06000171 RID: 369 RVA: 0x0003626C File Offset: 0x0001626C
        public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (!cancellationToken.IsCancellationRequested)
            {
                return new ValueTask<int>(this.Read(buffer.Span));
            }
            return new ValueTask<int>(Task.FromCanceled<int>(cancellationToken));
        }

        // Token: 0x06000172 RID: 370 RVA: 0x00036295 File Offset: 0x00016295
        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return TaskToApm.Begin(base.ReadAsync(buffer, offset, count), callback, state);
        }

        // Token: 0x06000173 RID: 371 RVA: 0x000362A9 File Offset: 0x000162A9
        public override int EndRead(IAsyncResult asyncResult)
        {
            return TaskToApm.End<int>(asyncResult);
        }

        // Token: 0x06000174 RID: 372 RVA: 0x000362B4 File Offset: 0x000162B4
        public override void CopyTo(Stream destination, int bufferSize)
        {
            StreamHelpers.ValidateCopyToArgs(this, destination, bufferSize);
            if (this._content.Length > this._position)
            {
                destination.Write(this._content.Span.Slice(this._position));
            }
        }

        // Token: 0x06000175 RID: 373 RVA: 0x000362FC File Offset: 0x000162FC
        public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
        {
            StreamHelpers.ValidateCopyToArgs(this, destination, bufferSize);
            if (this._content.Length <= this._position)
            {
                return Task.CompletedTask;
            }
            return destination.WriteAsync(this._content.Slice(this._position), cancellationToken).AsTask();
        }

        // Token: 0x06000176 RID: 374 RVA: 0x00034ED8 File Offset: 0x00014ED8
        public override void Flush()
        {
        }

        // Token: 0x06000177 RID: 375 RVA: 0x0003634A File Offset: 0x0001634A
        public override Task FlushAsync(CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }

        // Token: 0x06000178 RID: 376 RVA: 0x00036351 File Offset: 0x00016351
        public override void SetLength(long value)
        {
            throw new NotSupportedException();
        }

        // Token: 0x06000179 RID: 377 RVA: 0x00036351 File Offset: 0x00016351
        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException();
        }

        // Token: 0x0600017A RID: 378 RVA: 0x00036358 File Offset: 0x00016358
        private static void ValidateReadArrayArguments(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }
            if (offset < 0)
            {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (count < 0 || buffer.Length - offset < count)
            {
                throw new ArgumentOutOfRangeException("count");
            }
        }

        // Token: 0x04000126 RID: 294
        private readonly ReadOnlyMemory<byte> _content;

        // Token: 0x04000127 RID: 295
        private int _position;
    }

    // Token: 0x0200004B RID: 75
    internal static class StreamHelpers
    {
        // Token: 0x06000164 RID: 356 RVA: 0x00035FDC File Offset: 0x00015FDC
        public static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize)
        {
            if (destination == null)
            {
                throw new ArgumentNullException("destination");
            }
            if (bufferSize <= 0)
            {
                throw new ArgumentOutOfRangeException("bufferSize", bufferSize, SR.ArgumentOutOfRange_NeedPosNum);
            }
            bool canRead = source.CanRead;
            if (!canRead && !source.CanWrite)
            {
                throw new ObjectDisposedException(null, SR.ObjectDisposed_StreamClosed);
            }
            bool canWrite = destination.CanWrite;
            if (!canWrite && !destination.CanRead)
            {
                throw new ObjectDisposedException("destination", SR.ObjectDisposed_StreamClosed);
            }
            if (!canRead)
            {
                throw new NotSupportedException(SR.NotSupported_UnreadableStream);
            }
            if (!canWrite)
            {
                throw new NotSupportedException(SR.NotSupported_UnwritableStream);
            }
        }
    }

    // Token: 0x0200004D RID: 77
    internal static class StringBuilderCache
    {
        // Token: 0x0600017B RID: 379 RVA: 0x00036390 File Offset: 0x00016390
        public static StringBuilder Acquire(int capacity = 16)
        {
            if (capacity <= 260)
            {
                StringBuilder stringBuilder = StringBuilderCache.t_cachedInstance;
                if (stringBuilder != null && capacity <= stringBuilder.Capacity)
                {
                    StringBuilderCache.t_cachedInstance = null;
                    stringBuilder.Clear();
                    return stringBuilder;
                }
            }
            return new StringBuilder(capacity);
        }

        // Token: 0x0600017C RID: 380 RVA: 0x000363CC File Offset: 0x000163CC
        public static void Release(StringBuilder sb)
        {
            if (sb.Capacity <= 260)
            {
                StringBuilderCache.t_cachedInstance = sb;
            }
        }

        // Token: 0x0600017D RID: 381 RVA: 0x000363E4 File Offset: 0x000163E4
        public static string GetStringAndRelease(StringBuilder sb)
        {
            string result = sb.ToString();
            StringBuilderCache.Release(sb);
            return result;
        }

        // Token: 0x04000128 RID: 296
        [ThreadStatic]
        private static StringBuilder t_cachedInstance;
    }

    // Token: 0x02000044 RID: 68
    internal static class TaskToApm
    {
        // Token: 0x06000153 RID: 339 RVA: 0x00035C18 File Offset: 0x00015C18
        public static IAsyncResult Begin(Task task, AsyncCallback callback, object state)
        {
            IAsyncResult asyncResult;
            if (task.IsCompleted)
            {
                asyncResult = new TaskToApm.TaskWrapperAsyncResult(task, state, true);
                if (callback != null)
                {
                    callback(asyncResult);
                }
            }
            else
            {
                IAsyncResult asyncResult3;
                if (task.AsyncState != state)
                {
                    IAsyncResult asyncResult2 = new TaskToApm.TaskWrapperAsyncResult(task, state, false);
                    asyncResult3 = asyncResult2;
                }
                else
                {
                    asyncResult3 = task;
                }
                asyncResult = asyncResult3;
                if (callback != null)
                {
                    TaskToApm.InvokeCallbackWhenTaskCompletes(task, callback, asyncResult);
                }
            }
            return asyncResult;
        }

        // Token: 0x06000154 RID: 340 RVA: 0x00035C68 File Offset: 0x00015C68
        public static void End(IAsyncResult asyncResult)
        {
            TaskToApm.TaskWrapperAsyncResult taskWrapperAsyncResult = asyncResult as TaskToApm.TaskWrapperAsyncResult;
            Task task;
            if (taskWrapperAsyncResult != null)
            {
                task = taskWrapperAsyncResult.Task;
            }
            else
            {
                task = (asyncResult as Task);
            }
            if (task == null)
            {
                throw new ArgumentNullException();
            }
            task.GetAwaiter().GetResult();
        }

        // Token: 0x06000155 RID: 341 RVA: 0x00035CA8 File Offset: 0x00015CA8
        public static TResult End<TResult>(IAsyncResult asyncResult)
        {
            TaskToApm.TaskWrapperAsyncResult taskWrapperAsyncResult = asyncResult as TaskToApm.TaskWrapperAsyncResult;
            Task<TResult> task;
            if (taskWrapperAsyncResult != null)
            {
                task = (taskWrapperAsyncResult.Task as Task<TResult>);
            }
            else
            {
                task = (asyncResult as Task<TResult>);
            }
            if (task == null)
            {
                throw new ArgumentNullException();
            }
            return task.GetAwaiter().GetResult();
        }

        // Token: 0x06000156 RID: 342 RVA: 0x00035CEC File Offset: 0x00015CEC
        private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult)
        {
            antecedent.ConfigureAwait(false).GetAwaiter().OnCompleted(delegate
            {
                callback(asyncResult);
            });
        }

        // Token: 0x02000045 RID: 69
        private sealed class TaskWrapperAsyncResult : IAsyncResult
        {
            // Token: 0x06000157 RID: 343 RVA: 0x00035D30 File Offset: 0x00015D30
            internal TaskWrapperAsyncResult(Task task, object state, bool completedSynchronously)
            {
                this.Task = task;
                this._state = state;
                this._completedSynchronously = completedSynchronously;
            }

            // Token: 0x17000077 RID: 119
            // (get) Token: 0x06000158 RID: 344 RVA: 0x00035D4D File Offset: 0x00015D4D
            object IAsyncResult.AsyncState
            {
                get
                {
                    return this._state;
                }
            }

            // Token: 0x17000078 RID: 120
            // (get) Token: 0x06000159 RID: 345 RVA: 0x00035D55 File Offset: 0x00015D55
            bool IAsyncResult.CompletedSynchronously
            {
                get
                {
                    return this._completedSynchronously;
                }
            }

            // Token: 0x17000079 RID: 121
            // (get) Token: 0x0600015A RID: 346 RVA: 0x00035D5D File Offset: 0x00015D5D
            bool IAsyncResult.IsCompleted
            {
                get
                {
                    return this.Task.IsCompleted;
                }
            }

            // Token: 0x1700007A RID: 122
            // (get) Token: 0x0600015B RID: 347 RVA: 0x00035D6A File Offset: 0x00015D6A
            WaitHandle IAsyncResult.AsyncWaitHandle
            {
                get
                {
                    return ((IAsyncResult)this.Task).AsyncWaitHandle;
                }
            }

            // Token: 0x04000118 RID: 280
            internal readonly Task Task;

            // Token: 0x04000119 RID: 281
            private readonly object _state;

            // Token: 0x0400011A RID: 282
            private readonly bool _completedSynchronously;
        }
    }

    // Token: 0x02000055 RID: 85
    internal static class ExceptionCheck
    {
        // Token: 0x060001AE RID: 430 RVA: 0x000373E3 File Offset: 0x000173E3
        internal static bool IsFatal(Exception exception)
        {
            return exception is OutOfMemoryException;
        }
    }

    // Token: 0x02000058 RID: 88
    internal static class HttpKnownHeaderNames
    {
        // Token: 0x060001B3 RID: 435 RVA: 0x00037540 File Offset: 0x00017540
        public unsafe static bool TryGetHeaderName(IntPtr buffer, int length, out string name)
        {
            if (buffer == IntPtr.Zero)
            {
                name = null;
                return false;
            }
            return HttpKnownHeaderNames.TryGetHeaderName<IntPtr>(buffer, 0, length, (IntPtr buf, int index) => (char)((byte*)((void*)buf))[index], (string known, IntPtr buf, int start, int len) => HttpKnownHeaderNames.EqualsOrdinal(known, buf, len), out name);
        }

        // Token: 0x060001B4 RID: 436 RVA: 0x000375A8 File Offset: 0x000175A8
        private static bool TryGetHeaderName<T>(T key, int startIndex, int length, Func<T, int, char> charAt, Func<string, T, int, int, bool> equals, out string name)
        {
            string known;
            switch (length)
            {
                case 2:
                    known = "TE";
                    goto IL_714;
                case 3:
                    {
                        char c = charAt(key, startIndex);
                        if (c <= 'P')
                        {
                            if (c == 'A')
                            {
                                known = "Age";
                                goto IL_714;
                            }
                            if (c == 'P')
                            {
                                known = "P3P";
                                goto IL_714;
                            }
                        }
                        else
                        {
                            if (c == 'T')
                            {
                                known = "TSV";
                                goto IL_714;
                            }
                            if (c == 'V')
                            {
                                known = "Via";
                                goto IL_714;
                            }
                        }
                        break;
                    }
                case 4:
                    {
                        char c = charAt(key, startIndex);
                        switch (c)
                        {
                            case 'D':
                                known = "Date";
                                goto IL_714;
                            case 'E':
                                known = "ETag";
                                goto IL_714;
                            case 'F':
                                known = "From";
                                goto IL_714;
                            case 'G':
                            case 'I':
                            case 'J':
                            case 'K':
                                break;
                            case 'H':
                                known = "Host";
                                goto IL_714;
                            case 'L':
                                known = "Link";
                                goto IL_714;
                            default:
                                if (c == 'V')
                                {
                                    known = "Vary";
                                    goto IL_714;
                                }
                                break;
                        }
                        break;
                    }
                case 5:
                    {
                        char c = charAt(key, startIndex);
                        if (c == 'A')
                        {
                            known = "Allow";
                            goto IL_714;
                        }
                        if (c == 'R')
                        {
                            known = "Range";
                            goto IL_714;
                        }
                        break;
                    }
                case 6:
                    {
                        char c = charAt(key, startIndex);
                        switch (c)
                        {
                            case 'A':
                                known = "Accept";
                                goto IL_714;
                            case 'B':
                            case 'D':
                                break;
                            case 'C':
                                known = "Cookie";
                                goto IL_714;
                            case 'E':
                                known = "Expect";
                                goto IL_714;
                            default:
                                switch (c)
                                {
                                    case 'O':
                                        known = "Origin";
                                        goto IL_714;
                                    case 'P':
                                        known = "Pragma";
                                        goto IL_714;
                                    case 'S':
                                        known = "Server";
                                        goto IL_714;
                                }
                                break;
                        }
                        break;
                    }
                case 7:
                    {
                        char c = charAt(key, startIndex);
                        switch (c)
                        {
                            case 'A':
                                known = "Alt-Svc";
                                goto IL_714;
                            case 'B':
                            case 'D':
                                break;
                            case 'C':
                                known = "Cookie2";
                                goto IL_714;
                            case 'E':
                                known = "Expires";
                                goto IL_714;
                            default:
                                switch (c)
                                {
                                    case 'R':
                                        known = "Referer";
                                        goto IL_714;
                                    case 'T':
                                        known = "Trailer";
                                        goto IL_714;
                                    case 'U':
                                        known = "Upgrade";
                                        goto IL_714;
                                    case 'W':
                                        known = "Warning";
                                        goto IL_714;
                                }
                                break;
                        }
                        break;
                    }
                case 8:
                    {
                        char c = charAt(key, startIndex + 3);
                        if (c == 'M')
                        {
                            known = "If-Match";
                            goto IL_714;
                        }
                        if (c == 'R')
                        {
                            known = "If-Range";
                            goto IL_714;
                        }
                        if (c == 'a')
                        {
                            known = "Location";
                            goto IL_714;
                        }
                        break;
                    }
                case 10:
                    {
                        char c = charAt(key, startIndex);
                        if (c <= 'K')
                        {
                            if (c == 'C')
                            {
                                known = "Connection";
                                goto IL_714;
                            }
                            if (c == 'K')
                            {
                                known = "Keep-Alive";
                                goto IL_714;
                            }
                        }
                        else
                        {
                            if (c == 'S')
                            {
                                known = "Set-Cookie";
                                goto IL_714;
                            }
                            if (c == 'U')
                            {
                                known = "User-Agent";
                                goto IL_714;
                            }
                        }
                        break;
                    }
                case 11:
                    {
                        char c = charAt(key, startIndex);
                        if (c == 'C')
                        {
                            known = "Content-MD5";
                            goto IL_714;
                        }
                        if (c == 'R')
                        {
                            known = "Retry-After";
                            goto IL_714;
                        }
                        if (c == 'S')
                        {
                            known = "Set-Cookie2";
                            goto IL_714;
                        }
                        break;
                    }
                case 12:
                    {
                        char c = charAt(key, startIndex + 2);
                        if (c <= 'R')
                        {
                            if (c == 'M')
                            {
                                known = "X-MSEdge-Ref";
                                goto IL_714;
                            }
                            if (c == 'P')
                            {
                                known = "X-Powered-By";
                                goto IL_714;
                            }
                            if (c == 'R')
                            {
                                known = "X-Request-ID";
                                goto IL_714;
                            }
                        }
                        else
                        {
                            if (c == 'c')
                            {
                                known = "Accept-Patch";
                                goto IL_714;
                            }
                            if (c == 'n')
                            {
                                known = "Content-Type";
                                goto IL_714;
                            }
                            if (c == 'x')
                            {
                                known = "Max-Forwards";
                                goto IL_714;
                            }
                        }
                        break;
                    }
                case 13:
                    {
                        char c = charAt(key, startIndex + 6);
                        if (c <= 'e')
                        {
                            if (c == '-')
                            {
                                known = "Accept-Ranges";
                                goto IL_714;
                            }
                            if (c == 'C')
                            {
                                known = "Cache-Control";
                                goto IL_714;
                            }
                            if (c == 'e')
                            {
                                known = "If-None-Match";
                                goto IL_714;
                            }
                        }
                        else
                        {
                            if (c == 'i')
                            {
                                known = "Authorization";
                                goto IL_714;
                            }
                            if (c == 'o')
                            {
                                known = "Last-Modified";
                                goto IL_714;
                            }
                            if (c == 't')
                            {
                                known = "Content-Range";
                                goto IL_714;
                            }
                        }
                        break;
                    }
                case 14:
                    {
                        char c = charAt(key, startIndex);
                        if (c == 'A')
                        {
                            known = "Accept-Charset";
                            goto IL_714;
                        }
                        if (c == 'C')
                        {
                            known = "Content-Length";
                            goto IL_714;
                        }
                        break;
                    }
                case 15:
                    {
                        char c = charAt(key, startIndex + 7);
                        if (c <= 'E')
                        {
                            if (c == '-')
                            {
                                known = "X-Frame-Options";
                                goto IL_714;
                            }
                            if (c == 'E')
                            {
                                known = "Accept-Encoding";
                                goto IL_714;
                            }
                        }
                        else
                        {
                            if (c == 'K')
                            {
                                known = "Public-Key-Pins";
                                goto IL_714;
                            }
                            if (c == 'L')
                            {
                                known = "Accept-Language";
                                goto IL_714;
                            }
                            if (c == 'm')
                            {
                                known = "X-UA-Compatible";
                                goto IL_714;
                            }
                        }
                        break;
                    }
                case 16:
                    {
                        char c = charAt(key, startIndex + 11);
                        if (c <= 'g')
                        {
                            if (c == 'a')
                            {
                                known = "Content-Location";
                                goto IL_714;
                            }
                            if (c == 'c')
                            {
                                known = "Proxy-Connection";
                                goto IL_714;
                            }
                            if (c == 'g')
                            {
                                known = "Content-Language";
                                goto IL_714;
                            }
                        }
                        else
                        {
                            if (c == 'i')
                            {
                                known = "WWW-Authenticate";
                                goto IL_714;
                            }
                            if (c == 'o')
                            {
                                known = "Content-Encoding";
                                goto IL_714;
                            }
                            if (c == 'r')
                            {
                                known = "X-AspNet-Version";
                                goto IL_714;
                            }
                        }
                        break;
                    }
                case 17:
                    {
                        char c = charAt(key, startIndex);
                        if (c == 'I')
                        {
                            known = "If-Modified-Since";
                            goto IL_714;
                        }
                        if (c == 'S')
                        {
                            known = "Sec-WebSocket-Key";
                            goto IL_714;
                        }
                        if (c == 'T')
                        {
                            known = "Transfer-Encoding";
                            goto IL_714;
                        }
                        break;
                    }
                case 18:
                    {
                        char c = charAt(key, startIndex);
                        if (c == 'P')
                        {
                            known = "Proxy-Authenticate";
                            goto IL_714;
                        }
                        if (c == 'X')
                        {
                            known = "X-Content-Duration";
                            goto IL_714;
                        }
                        break;
                    }
                case 19:
                    {
                        char c = charAt(key, startIndex);
                        if (c == 'C')
                        {
                            known = "Content-Disposition";
                            goto IL_714;
                        }
                        if (c == 'I')
                        {
                            known = "If-Unmodified-Since";
                            goto IL_714;
                        }
                        if (c == 'P')
                        {
                            known = "Proxy-Authorization";
                            goto IL_714;
                        }
                        break;
                    }
                case 20:
                    known = "Sec-WebSocket-Accept";
                    goto IL_714;
                case 21:
                    known = "Sec-WebSocket-Version";
                    goto IL_714;
                case 22:
                    {
                        char c = charAt(key, startIndex);
                        if (c == 'A')
                        {
                            known = "Access-Control-Max-Age";
                            goto IL_714;
                        }
                        if (c == 'S')
                        {
                            known = "Sec-WebSocket-Protocol";
                            goto IL_714;
                        }
                        if (c == 'X')
                        {
                            known = "X-Content-Type-Options";
                            goto IL_714;
                        }
                        break;
                    }
                case 23:
                    known = "Content-Security-Policy";
                    goto IL_714;
                case 24:
                    known = "Sec-WebSocket-Extensions";
                    goto IL_714;
                case 25:
                    {
                        char c = charAt(key, startIndex);
                        if (c == 'S')
                        {
                            known = "Strict-Transport-Security";
                            goto IL_714;
                        }
                        if (c == 'U')
                        {
                            known = "Upgrade-Insecure-Requests";
                            goto IL_714;
                        }
                        break;
                    }
                case 27:
                    known = "Access-Control-Allow-Origin";
                    goto IL_714;
                case 28:
                    {
                        char c = charAt(key, startIndex + 21);
                        if (c == 'H')
                        {
                            known = "Access-Control-Allow-Headers";
                            goto IL_714;
                        }
                        if (c == 'M')
                        {
                            known = "Access-Control-Allow-Methods";
                            goto IL_714;
                        }
                        break;
                    }
                case 29:
                    known = "Access-Control-Expose-Headers";
                    goto IL_714;
                case 32:
                    known = "Access-Control-Allow-Credentials";
                    goto IL_714;
            }
            name = null;
            return false;
            IL_714:
            return HttpKnownHeaderNames.TryMatch<T>(known, key, startIndex, length, equals, out name);
        }

        // Token: 0x060001B5 RID: 437 RVA: 0x00037CD6 File Offset: 0x00017CD6
        private static bool TryMatch<T>(string known, T key, int startIndex, int length, Func<string, T, int, int, bool> equals, out string name)
        {
            if (equals(known, key, startIndex, length))
            {
                name = known;
                return true;
            }
            name = null;
            return false;
        }

        // Token: 0x060001B6 RID: 438 RVA: 0x00037CF0 File Offset: 0x00017CF0
        private unsafe static bool EqualsOrdinal(string left, IntPtr right, int rightLength)
        {
            byte* ptr = (byte*)((void*)right);
            for (int i = 0; i < left.Length; i++)
            {
                if (left[i] != (char)ptr[i])
                {
                    return false;
                }
            }
            return true;
        }
    }

    // Token: 0x0200005A RID: 90
    internal static class HttpStatusDescription
    {
        // Token: 0x060001BB RID: 443 RVA: 0x00037D47 File Offset: 0x00017D47
        internal static string Get(HttpStatusCode code)
        {
            return HttpStatusDescription.Get((int)code);
        }

        // Token: 0x060001BC RID: 444 RVA: 0x00037D50 File Offset: 0x00017D50
        internal static string Get(int code)
        {
            if (code <= 226)
            {
                switch (code)
                {
                    case 100:
                        return "Continue";
                    case 101:
                        return "Switching Protocols";
                    case 102:
                        return "Processing";
                    case 103:
                        return "Early Hints";
                    default:
                        switch (code)
                        {
                            case 200:
                                return "OK";
                            case 201:
                                return "Created";
                            case 202:
                                return "Accepted";
                            case 203:
                                return "Non-Authoritative Information";
                            case 204:
                                return "No Content";
                            case 205:
                                return "Reset Content";
                            case 206:
                                return "Partial Content";
                            case 207:
                                return "Multi-Status";
                            case 208:
                                return "Already Reported";
                            default:
                                if (code == 226)
                                {
                                    return "IM Used";
                                }
                                break;
                        }
                        break;
                }
            }
            else
            {
                switch (code)
                {
                    case 300:
                        return "Multiple Choices";
                    case 301:
                        return "Moved Permanently";
                    case 302:
                        return "Found";
                    case 303:
                        return "See Other";
                    case 304:
                        return "Not Modified";
                    case 305:
                        return "Use Proxy";
                    case 306:
                        break;
                    case 307:
                        return "Temporary Redirect";
                    case 308:
                        return "Permanent Redirect";
                    default:
                        switch (code)
                        {
                            case 400:
                                return "Bad Request";
                            case 401:
                                return "Unauthorized";
                            case 402:
                                return "Payment Required";
                            case 403:
                                return "Forbidden";
                            case 404:
                                return "Not Found";
                            case 405:
                                return "Method Not Allowed";
                            case 406:
                                return "Not Acceptable";
                            case 407:
                                return "Proxy Authentication Required";
                            case 408:
                                return "Request Timeout";
                            case 409:
                                return "Conflict";
                            case 410:
                                return "Gone";
                            case 411:
                                return "Length Required";
                            case 412:
                                return "Precondition Failed";
                            case 413:
                                return "Request Entity Too Large";
                            case 414:
                                return "Request-Uri Too Long";
                            case 415:
                                return "Unsupported Media Type";
                            case 416:
                                return "Requested Range Not Satisfiable";
                            case 417:
                                return "Expectation Failed";
                            case 418:
                            case 419:
                            case 420:
                            case 425:
                            case 427:
                            case 430:
                            case 432:
                            case 433:
                            case 434:
                            case 435:
                            case 436:
                            case 437:
                            case 438:
                            case 439:
                            case 440:
                            case 441:
                            case 442:
                            case 443:
                            case 444:
                            case 445:
                            case 446:
                            case 447:
                            case 448:
                            case 449:
                            case 450:
                                break;
                            case 421:
                                return "Misdirected Request";
                            case 422:
                                return "Unprocessable Entity";
                            case 423:
                                return "Locked";
                            case 424:
                                return "Failed Dependency";
                            case 426:
                                return "Upgrade Required";
                            case 428:
                                return "Precondition Required";
                            case 429:
                                return "Too Many Requests";
                            case 431:
                                return "Request Header Fields Too Large";
                            case 451:
                                return "Unavailable For Legal Reasons";
                            default:
                                switch (code)
                                {
                                    case 500:
                                        return "Internal Server Error";
                                    case 501:
                                        return "Not Implemented";
                                    case 502:
                                        return "Bad Gateway";
                                    case 503:
                                        return "Service Unavailable";
                                    case 504:
                                        return "Gateway Timeout";
                                    case 505:
                                        return "Http Version Not Supported";
                                    case 506:
                                        return "Variant Also Negotiates";
                                    case 507:
                                        return "Insufficient Storage";
                                    case 508:
                                        return "Loop Detected";
                                    case 510:
                                        return "Not Extended";
                                    case 511:
                                        return "Network Authentication Required";
                                }
                                break;
                        }
                        break;
                }
            }
            return null;
        }
    }


    // Token: 0x02000050 RID: 80
    internal static class HttpVersionInternal
    {
        // Token: 0x0400012D RID: 301
        public static readonly Version Unknown = new Version(0, 0);

        // Token: 0x0400012E RID: 302
        public static readonly Version Version10 = new Version(1, 0);

        // Token: 0x0400012F RID: 303
        public static readonly Version Version11 = new Version(1, 1);

        // Token: 0x04000130 RID: 304
        public static readonly Version Version20 = new Version(2, 0);
    }


    // Token: 0x0200009C RID: 156
    internal class AuthenticationHelper
    {
        // Token: 0x060003D3 RID: 979 RVA: 0x0003F0FC File Offset: 0x0001F0FC
        private static bool TryGetChallengeDataForScheme(string scheme, HttpHeaderValueCollection<AuthenticationHeaderValue> authenticationHeaderValues, out string challengeData)
        {
            foreach (AuthenticationHeaderValue authenticationHeaderValue in authenticationHeaderValues)
            {
                if (StringComparer.OrdinalIgnoreCase.Equals(scheme, authenticationHeaderValue.Scheme))
                {
                    challengeData = authenticationHeaderValue.Parameter;
                    return true;
                }
            }
            challengeData = null;
            return false;
        }

        // Token: 0x060003D4 RID: 980 RVA: 0x0003F164 File Offset: 0x0001F164
        private static bool TryGetValidAuthenticationChallengeForScheme(string scheme, AuthenticationHelper.AuthenticationType authenticationType, Uri uri, ICredentials credentials, HttpHeaderValueCollection<AuthenticationHeaderValue> authenticationHeaderValues, out AuthenticationHelper.AuthenticationChallenge challenge)
        {
            challenge = default(AuthenticationHelper.AuthenticationChallenge);
            string challenge2;
            if (!AuthenticationHelper.TryGetChallengeDataForScheme(scheme, authenticationHeaderValues, out challenge2))
            {
                return false;
            }
            NetworkCredential credential = credentials.GetCredential(uri, scheme);
            if (credential == null)
            {
                return false;
            }
            challenge = new AuthenticationHelper.AuthenticationChallenge(authenticationType, scheme, credential, challenge2);
            return true;
        }

        // Token: 0x060003D5 RID: 981 RVA: 0x0003F1A8 File Offset: 0x0001F1A8
        private static bool TryGetAuthenticationChallenge(HttpResponseMessage response, bool isProxyAuth, Uri authUri, ICredentials credentials, out AuthenticationHelper.AuthenticationChallenge challenge)
        {
            if (!AuthenticationHelper.IsAuthenticationChallenge(response, isProxyAuth))
            {
                challenge = default(AuthenticationHelper.AuthenticationChallenge);
                return false;
            }
            HttpHeaderValueCollection<AuthenticationHeaderValue> responseAuthenticationHeaderValues = AuthenticationHelper.GetResponseAuthenticationHeaderValues(response, isProxyAuth);
            return AuthenticationHelper.TryGetValidAuthenticationChallengeForScheme("Negotiate", AuthenticationHelper.AuthenticationType.Negotiate, authUri, credentials, responseAuthenticationHeaderValues, out challenge) || AuthenticationHelper.TryGetValidAuthenticationChallengeForScheme("NTLM", AuthenticationHelper.AuthenticationType.Ntlm, authUri, credentials, responseAuthenticationHeaderValues, out challenge) || AuthenticationHelper.TryGetValidAuthenticationChallengeForScheme("Digest", AuthenticationHelper.AuthenticationType.Digest, authUri, credentials, responseAuthenticationHeaderValues, out challenge) || AuthenticationHelper.TryGetValidAuthenticationChallengeForScheme("Basic", AuthenticationHelper.AuthenticationType.Basic, authUri, credentials, responseAuthenticationHeaderValues, out challenge);
        }

        // Token: 0x060003D6 RID: 982 RVA: 0x0003F218 File Offset: 0x0001F218
        private static bool TryGetRepeatedChallenge(HttpResponseMessage response, string scheme, bool isProxyAuth, out string challengeData)
        {
            challengeData = null;
            return AuthenticationHelper.IsAuthenticationChallenge(response, isProxyAuth) && AuthenticationHelper.TryGetChallengeDataForScheme(scheme, AuthenticationHelper.GetResponseAuthenticationHeaderValues(response, isProxyAuth), out challengeData);
        }

        // Token: 0x060003D7 RID: 983 RVA: 0x0003F23B File Offset: 0x0001F23B
        private static bool IsAuthenticationChallenge(HttpResponseMessage response, bool isProxyAuth)
        {
            if (!isProxyAuth)
            {
                return response.StatusCode == HttpStatusCode.Unauthorized;
            }
            return response.StatusCode == HttpStatusCode.ProxyAuthenticationRequired;
        }

        // Token: 0x060003D8 RID: 984 RVA: 0x0003F25B File Offset: 0x0001F25B
        private static HttpHeaderValueCollection<AuthenticationHeaderValue> GetResponseAuthenticationHeaderValues(HttpResponseMessage response, bool isProxyAuth)
        {
            if (!isProxyAuth)
            {
                return response.Headers.WwwAuthenticate;
            }
            return response.Headers.ProxyAuthenticate;
        }

        // Token: 0x060003D9 RID: 985 RVA: 0x0003F277 File Offset: 0x0001F277
        private static void SetRequestAuthenticationHeaderValue(HttpRequestMessage request, AuthenticationHeaderValue headerValue, bool isProxyAuth)
        {
            if (isProxyAuth)
            {
                request.Headers.ProxyAuthorization = headerValue;
                return;
            }
            request.Headers.Authorization = headerValue;
        }

        // Token: 0x060003DA RID: 986 RVA: 0x0003F298 File Offset: 0x0001F298
        private static void SetBasicAuthToken(HttpRequestMessage request, NetworkCredential credential, bool isProxyAuth)
        {
            string s = (!string.IsNullOrEmpty(credential.Domain)) ? string.Concat(new string[]
            {
                credential.Domain,
                "\\",
                credential.UserName,
                ":",
                credential.Password
            }) : (credential.UserName + ":" + credential.Password);
            string parameter = Convert.ToBase64String(Encoding.UTF8.GetBytes(s));
            AuthenticationHelper.SetRequestAuthenticationHeaderValue(request, new AuthenticationHeaderValue("Basic", parameter), isProxyAuth);
        }

        // Token: 0x060003DB RID: 987 RVA: 0x0003F324 File Offset: 0x0001F324
        private static async Task<bool> TrySetDigestAuthToken(HttpRequestMessage request, NetworkCredential credential, AuthenticationHelper.DigestResponse digestResponse, bool isProxyAuth)
        {
            string text = await AuthenticationHelper.GetDigestTokenForCredential(credential, request, digestResponse).ConfigureAwait(false);
            string text2 = text;
            bool result;
            if (string.IsNullOrEmpty(text2))
            {
                result = false;
            }
            else
            {
                AuthenticationHeaderValue headerValue = new AuthenticationHeaderValue("Digest", text2);
                AuthenticationHelper.SetRequestAuthenticationHeaderValue(request, headerValue, isProxyAuth);
                result = true;
            }
            return result;
        }

        // Token: 0x060003DC RID: 988 RVA: 0x0003F381 File Offset: 0x0001F381
        private static Task<HttpResponseMessage> InnerSendAsync(HttpRequestMessage request, bool isProxyAuth, bool doRequestAuth, HttpConnectionPool pool, CancellationToken cancellationToken)
        {
            if (!isProxyAuth)
            {
                return pool.SendWithProxyAuthAsync(request, doRequestAuth, cancellationToken);
            }
            return pool.SendWithRetryAsync(request, doRequestAuth, cancellationToken);
        }

        // Token: 0x060003DD RID: 989 RVA: 0x0003F39C File Offset: 0x0001F39C
        private static async Task<HttpResponseMessage> SendWithAuthAsync(HttpRequestMessage request, Uri authUri, ICredentials credentials, bool preAuthenticate, bool isProxyAuth, bool doRequestAuth, HttpConnectionPool pool, CancellationToken cancellationToken)
        {
            bool performedBasicPreauth = false;
            if (preAuthenticate)
            {
                CredentialCache preAuthCredentials = pool.PreAuthCredentials;
                NetworkCredential credential;
                lock (preAuthCredentials)
                {
                    credential = pool.PreAuthCredentials.GetCredential(authUri, "Basic");
                }
                if (credential != null)
                {
                    AuthenticationHelper.SetBasicAuthToken(request, credential, isProxyAuth);
                    performedBasicPreauth = true;
                }
            }
            HttpResponseMessage httpResponseMessage = await AuthenticationHelper.InnerSendAsync(request, isProxyAuth, doRequestAuth, pool, cancellationToken).ConfigureAwait(false);
            HttpResponseMessage response = httpResponseMessage;
            AuthenticationHelper.AuthenticationChallenge challenge;
            if (AuthenticationHelper.TryGetAuthenticationChallenge(response, isProxyAuth, authUri, credentials, out challenge))
            {
                AuthenticationHelper.AuthenticationType authenticationType = challenge.AuthenticationType;
                if (authenticationType != AuthenticationHelper.AuthenticationType.Basic)
                {
                    if (authenticationType == AuthenticationHelper.AuthenticationType.Digest)
                    {
                        AuthenticationHelper.DigestResponse digestResponse = new AuthenticationHelper.DigestResponse(challenge.ChallengeData);
                        if (await AuthenticationHelper.TrySetDigestAuthToken(request, challenge.Credential, digestResponse, isProxyAuth).ConfigureAwait(false))
                        {
                            response.Dispose();
                            response = await AuthenticationHelper.InnerSendAsync(request, isProxyAuth, doRequestAuth, pool, cancellationToken).ConfigureAwait(false);
                            string challenge2;
                            if (AuthenticationHelper.TryGetRepeatedChallenge(response, challenge.SchemeName, isProxyAuth, out challenge2))
                            {
                                digestResponse = new AuthenticationHelper.DigestResponse(challenge2);
                                bool flag2 = AuthenticationHelper.IsServerNonceStale(digestResponse);
                                if (flag2)
                                {
                                    flag2 = await AuthenticationHelper.TrySetDigestAuthToken(request, challenge.Credential, digestResponse, isProxyAuth).ConfigureAwait(false);
                                }
                                if (flag2)
                                {
                                    response.Dispose();
                                    response = await AuthenticationHelper.InnerSendAsync(request, isProxyAuth, doRequestAuth, pool, cancellationToken).ConfigureAwait(false);
                                }
                            }
                        }
                    }
                }
                else if (!performedBasicPreauth)
                {
                    response.Dispose();
                    AuthenticationHelper.SetBasicAuthToken(request, challenge.Credential, isProxyAuth);
                    response = await AuthenticationHelper.InnerSendAsync(request, isProxyAuth, doRequestAuth, pool, cancellationToken).ConfigureAwait(false);
                    if (preAuthenticate)
                    {
                        HttpStatusCode statusCode = response.StatusCode;
                        if (statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.ProxyAuthenticationRequired)
                        {
                            CredentialCache preAuthCredentials2 = pool.PreAuthCredentials;
                            lock (preAuthCredentials2)
                            {
                                try
                                {
                                    if (NetEventSource.IsEnabled)
                                    {
                                        NetEventSource.Info(pool.PreAuthCredentials, FormattableStringFactory.Create("Adding Basic credential to cache, uri={0}, username={1}", new object[]
                                        {
                                            authUri,
                                            challenge.Credential.UserName
                                        }), "SendWithAuthAsync");
                                    }
                                    pool.PreAuthCredentials.Add(authUri, "Basic", challenge.Credential);
                                }
                                catch (ArgumentException)
                                {
                                    if (NetEventSource.IsEnabled)
                                    {
                                        NetEventSource.Info(pool.PreAuthCredentials, FormattableStringFactory.Create("Basic credential present in cache, uri={0}, username={1}", new object[]
                                        {
                                            authUri,
                                            challenge.Credential.UserName
                                        }), "SendWithAuthAsync");
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return response;
        }

        // Token: 0x060003DE RID: 990 RVA: 0x0003F41D File Offset: 0x0001F41D
        public static Task<HttpResponseMessage> SendWithProxyAuthAsync(HttpRequestMessage request, Uri proxyUri, ICredentials proxyCredentials, bool doRequestAuth, HttpConnectionPool pool, CancellationToken cancellationToken)
        {
            return AuthenticationHelper.SendWithAuthAsync(request, proxyUri, proxyCredentials, false, true, doRequestAuth, pool, cancellationToken);
        }

        // Token: 0x060003DF RID: 991 RVA: 0x0003F42E File Offset: 0x0001F42E
        public static Task<HttpResponseMessage> SendWithRequestAuthAsync(HttpRequestMessage request, ICredentials credentials, bool preAuthenticate, HttpConnectionPool pool, CancellationToken cancellationToken)
        {
            return AuthenticationHelper.SendWithAuthAsync(request, request.RequestUri, credentials, preAuthenticate, false, true, pool, cancellationToken);
        }

        // Token: 0x060003E0 RID: 992 RVA: 0x0003F444 File Offset: 0x0001F444
        public static async Task<string> GetDigestTokenForCredential(NetworkCredential credential, HttpRequestMessage request, AuthenticationHelper.DigestResponse digestResponse)
        {
            StringBuilder sb = StringBuilderCache.Acquire(16);
            string algorithm;
            if (digestResponse.Parameters.TryGetValue("algorithm", out algorithm))
            {
                if (algorithm != "SHA-256" && algorithm != "MD5" && algorithm != "SHA-256-sess" && algorithm != "MD5-sess")
                {
                    if (NetEventSource.IsEnabled)
                    {
                        NetEventSource.Error(digestResponse, "Algorithm not supported: {algorithm}", "GetDigestTokenForCredential");
                    }
                    return null;
                }
            }
            else
            {
                algorithm = "MD5";
            }
            string nonce;
            string result;
            if (!digestResponse.Parameters.TryGetValue("nonce", out nonce))
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(digestResponse, "Nonce missing", "GetDigestTokenForCredential");
                }
                result = null;
            }
            else
            {
                string opaque;
                digestResponse.Parameters.TryGetValue("opaque", out opaque);
                string text;
                if (!digestResponse.Parameters.TryGetValue("realm", out text))
                {
                    if (NetEventSource.IsEnabled)
                    {
                        NetEventSource.Error(digestResponse, "Realm missing", "GetDigestTokenForCredential");
                    }
                    result = null;
                }
                else
                {
                    string text2;
                    string value;
                    if (digestResponse.Parameters.TryGetValue("userhash", out text2) && text2 == "true")
                    {
                        sb._AppendKeyValue("username", AuthenticationHelper.ComputeHash(credential.UserName + ":" + text, algorithm), true, true);
                        sb._AppendKeyValue("userhash", text2, false, true);
                    }
                    else if (HeaderUtilities.IsInputEncoded5987(credential.UserName, out value))
                    {
                        sb._AppendKeyValue("username*", value, false, true);
                    }
                    else
                    {
                        sb._AppendKeyValue("username", credential.UserName, true, true);
                    }
                    if (text != string.Empty)
                    {
                        sb._AppendKeyValue("realm", text, true, true);
                    }
                    sb._AppendKeyValue("nonce", nonce, true, true);
                    sb._AppendKeyValue("uri", request.RequestUri.PathAndQuery, true, true);
                    string qop = "auth";
                    if (digestResponse.Parameters.ContainsKey("qop"))
                    {
                        int num = digestResponse.Parameters["qop"].IndexOf("auth-int");
                        if (num != -1)
                        {
                            int num2 = digestResponse.Parameters["qop"].IndexOf("auth");
                            if (num2 == num)
                            {
                                num2 = digestResponse.Parameters["qop"].IndexOf("auth", num + "auth-int".Length);
                                if (num2 == -1)
                                {
                                    qop = "auth-int";
                                }
                            }
                        }
                    }
                    string cnonce = AuthenticationHelper.GetRandomAlphaNumericString();
                    string a = string.Concat(new string[]
                    {
                        credential.UserName,
                        ":",
                        text,
                        ":",
                        credential.Password
                    });
                    if (algorithm.IndexOf("sess") != -1)
                    {
                        a = string.Concat(new string[]
                        {
                            AuthenticationHelper.ComputeHash(a, algorithm),
                            ":",
                            nonce,
                            ":",
                            cnonce
                        });
                    }
                    string a2 = request.Method.Method + ":" + request.RequestUri.PathAndQuery;
                    if (qop == "auth-int")
                    {
                        string text3;
                        if (request.Content == null)
                        {
                            text3 = string.Empty;
                        }
                        else
                        {
                            string text4 = await request.Content.ReadAsStringAsync().ConfigureAwait(false);
                            text3 = text4;
                        }
                        string data = text3;
                        a2 = a2 + ":" + AuthenticationHelper.ComputeHash(data, algorithm);
                    }
                    string value2 = AuthenticationHelper.ComputeHash(string.Concat(new string[]
                    {
                        AuthenticationHelper.ComputeHash(a, algorithm),
                        ":",
                        nonce,
                        ":00000001:",
                        cnonce,
                        ":",
                        qop,
                        ":",
                        AuthenticationHelper.ComputeHash(a2, algorithm)
                    }), algorithm);
                    sb._AppendKeyValue("response", value2, true, true);
                    sb._AppendKeyValue("algorithm", algorithm, false, true);
                    if (opaque != null)
                    {
                        sb._AppendKeyValue("opaque", opaque, true, true);
                    }
                    sb._AppendKeyValue("qop", qop, false, true);
                    sb._AppendKeyValue("nc", "00000001", false, true);
                    sb._AppendKeyValue("cnonce", cnonce, true, false);
                    result = StringBuilderCache.GetStringAndRelease(sb);
                }
            }
            return result;
        }

        // Token: 0x060003E1 RID: 993 RVA: 0x0003F49C File Offset: 0x0001F49C
        public static bool IsServerNonceStale(AuthenticationHelper.DigestResponse digestResponse)
        {
            string a = null;
            return digestResponse.Parameters.TryGetValue("stale", out a) && a == "true";
        }

        // Token: 0x060003E2 RID: 994 RVA: 0x0003F4CC File Offset: 0x0001F4CC
        private unsafe static string GetRandomAlphaNumericString()
        {
            int num = 32;
            Span<byte> data = new Span<byte>(new byte[num]);
            RandomNumberGenerator.Fill(data);
            StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
            int i = 0;
            while (i < data.Length)
            {
                int num2 = (int)(data[i++] % 3);
                int num3 = (int)(data[i++] % ((num2 == 0) ? 10 : 26));
                stringBuilder.Append((char)(AuthenticationHelper.s_alphaNumChooser[num2] + num3));
            }
            return StringBuilderCache.GetStringAndRelease(stringBuilder);
        }

        // Token: 0x060003E3 RID: 995 RVA: 0x0003F548 File Offset: 0x0001F548
        private unsafe static string ComputeHash(string data, string algorithm)
        {
            string stringAndRelease;
            using (HashAlgorithm hashAlgorithm = algorithm.Contains("SHA-256") ? (HashAlgorithm)SHA256.Create() : (HashAlgorithm)MD5.Create())
            {
                int num = hashAlgorithm.HashSize / 8;
                Span<byte> destination = new Span<byte>(new byte[num]);
                int num2;
                bool flag = hashAlgorithm.TryComputeHash(Encoding.UTF8.GetBytes(data), destination, out num2);
                StringBuilder stringBuilder = StringBuilderCache.Acquire(destination.Length * 2);
                num = 2;
                Span<char> span = new Span<char>(new char[checked(unchecked(num) * 2)]);
                for (int i = 0; i < destination.Length; i++)
                {
                    int num3;
                    bool flag2 = destination[i].TryFormat(span, out num3, "x2", null);
                    stringBuilder.Append(span);
                }
                stringAndRelease = StringBuilderCache.GetStringAndRelease(stringBuilder);
            }
            return stringAndRelease;
        }

        // Token: 0x060003E4 RID: 996 RVA: 0x0003F630 File Offset: 0x0001F630
        private static Task<HttpResponseMessage> InnerSendAsync(HttpRequestMessage request, bool isProxyAuth, HttpConnection connection, CancellationToken cancellationToken)
        {
            if (!isProxyAuth)
            {
                return connection.SendWithNtProxyAuthAsync(request, cancellationToken);
            }
            return connection.SendAsyncCore(request, cancellationToken);
        }

        // Token: 0x060003E5 RID: 997 RVA: 0x0003F648 File Offset: 0x0001F648
        private static bool ProxySupportsConnectionAuth(HttpResponseMessage response)
        {
            IEnumerable<string> enumerable;
            if (!response.Headers.TryGetValues(KnownHeaders.ProxySupport.Descriptor, out enumerable))
            {
                return false;
            }
            foreach (string a in enumerable)
            {
                if (a == "Session-Based-Authentication")
                {
                    return true;
                }
            }
            return false;
        }

        // Token: 0x060003E6 RID: 998 RVA: 0x0003F6B8 File Offset: 0x0001F6B8
        private static async Task<HttpResponseMessage> SendWithNtAuthAsync(HttpRequestMessage request, Uri authUri, ICredentials credentials, bool isProxyAuth, HttpConnection connection, CancellationToken cancellationToken)
        {
            HttpResponseMessage httpResponseMessage = await AuthenticationHelper.InnerSendAsync(request, isProxyAuth, connection, cancellationToken).ConfigureAwait(false);
            HttpResponseMessage httpResponseMessage2 = httpResponseMessage;
            HttpResponseMessage result;
            if (!isProxyAuth && connection.Kind == HttpConnectionKind.Proxy && !AuthenticationHelper.ProxySupportsConnectionAuth(httpResponseMessage2))
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(connection, FormattableStringFactory.Create("Proxy doesn't support connection-based auth, uri={0}", new object[]
                    {
                        authUri
                    }), "SendWithNtAuthAsync");
                }
                result = httpResponseMessage2;
            }
            else
            {
                AuthenticationHelper.AuthenticationChallenge challenge;
                if (AuthenticationHelper.TryGetAuthenticationChallenge(httpResponseMessage2, isProxyAuth, authUri, credentials, out challenge) && (challenge.AuthenticationType == AuthenticationHelper.AuthenticationType.Negotiate || challenge.AuthenticationType == AuthenticationHelper.AuthenticationType.Ntlm))
                {
                    throw new NotImplementedException();

                    //string challengeData = challenge.ChallengeData;
                    //string spn = "HTTP/" + authUri.IdnHost;
                    //TransportContext transportContext = connection.TransportContext;
                    //ChannelBinding channelBinding = (transportContext != null) ? transportContext.GetChannelBinding(ChannelBindingKind.Endpoint) : null;
                    //NTAuthentication authContext = new NTAuthentication(false, challenge.SchemeName, challenge.Credential, spn, ContextFlagsPal.Connection, channelBinding);
                    //try
                    //{
                    //    for (; ; )
                    //    {
                    //        string challengeResponse = authContext.GetOutgoingBlob(challengeData);
                    //        if (challengeResponse == null)
                    //        {
                    //            break;
                    //        }
                    //        await connection.DrainResponseAsync(httpResponseMessage2).ConfigureAwait(false);
                    //        AuthenticationHelper.SetRequestAuthenticationHeaderValue(request, new AuthenticationHeaderValue(challenge.SchemeName, challengeResponse), isProxyAuth);
                    //        httpResponseMessage2 = await AuthenticationHelper.InnerSendAsync(request, isProxyAuth, connection, cancellationToken).ConfigureAwait(false);
                    //        if (authContext.IsCompleted || !AuthenticationHelper.TryGetRepeatedChallenge(httpResponseMessage2, challenge.SchemeName, isProxyAuth, out challengeData))
                    //        {
                    //            break;
                    //        }
                    //        challengeResponse = null;
                    //    }
                    //}
                    //finally
                    //{
                    //    authContext.CloseContext();
                    //}
                    //authContext = null;
                }
                result = httpResponseMessage2;
            }
            return result;
        }

        // Token: 0x060003E7 RID: 999 RVA: 0x0003F727 File Offset: 0x0001F727
        public static Task<HttpResponseMessage> SendWithNtProxyAuthAsync(HttpRequestMessage request, Uri proxyUri, ICredentials proxyCredentials, HttpConnection connection, CancellationToken cancellationToken)
        {
            return AuthenticationHelper.SendWithNtAuthAsync(request, proxyUri, proxyCredentials, true, connection, cancellationToken);
        }

        // Token: 0x060003E8 RID: 1000 RVA: 0x0003F735 File Offset: 0x0001F735
        public static Task<HttpResponseMessage> SendWithNtConnectionAuthAsync(HttpRequestMessage request, ICredentials credentials, HttpConnection connection, CancellationToken cancellationToken)
        {
            return AuthenticationHelper.SendWithNtAuthAsync(request, request.RequestUri, credentials, false, connection, cancellationToken);
        }

        // Token: 0x0400027C RID: 636
        private static int[] s_alphaNumChooser = new int[]
        {
            48,
            65,
            97
        };

        // Token: 0x0200009D RID: 157
        private enum AuthenticationType
        {
            // Token: 0x0400027E RID: 638
            Basic,
            // Token: 0x0400027F RID: 639
            Digest,
            // Token: 0x04000280 RID: 640
            Ntlm,
            // Token: 0x04000281 RID: 641
            Negotiate
        }

        // Token: 0x0200009E RID: 158
        private readonly struct AuthenticationChallenge
        {
            // Token: 0x170000DC RID: 220
            // (get) Token: 0x060003EA RID: 1002 RVA: 0x0003F75F File Offset: 0x0001F75F
            public AuthenticationHelper.AuthenticationType AuthenticationType { get; }

            // Token: 0x170000DD RID: 221
            // (get) Token: 0x060003EB RID: 1003 RVA: 0x0003F767 File Offset: 0x0001F767
            public string SchemeName { get; }

            // Token: 0x170000DE RID: 222
            // (get) Token: 0x060003EC RID: 1004 RVA: 0x0003F76F File Offset: 0x0001F76F
            public NetworkCredential Credential { get; }

            // Token: 0x170000DF RID: 223
            // (get) Token: 0x060003ED RID: 1005 RVA: 0x0003F777 File Offset: 0x0001F777
            public string ChallengeData { get; }

            // Token: 0x060003EE RID: 1006 RVA: 0x0003F77F File Offset: 0x0001F77F
            public AuthenticationChallenge(AuthenticationHelper.AuthenticationType authenticationType, string schemeName, NetworkCredential credential, string challenge)
            {
                this.AuthenticationType = authenticationType;
                this.SchemeName = schemeName;
                this.Credential = credential;
                this.ChallengeData = challenge;
            }
        }

        // Token: 0x0200009F RID: 159
        internal class DigestResponse
        {
            // Token: 0x060003EF RID: 1007 RVA: 0x0003F79E File Offset: 0x0001F79E
            internal DigestResponse(string challenge)
            {
                if (!string.IsNullOrEmpty(challenge))
                {
                    this.Parse(challenge);
                }
            }

            // Token: 0x060003F0 RID: 1008 RVA: 0x0003F7C5 File Offset: 0x0001F7C5
            private static bool CharIsSpaceOrTab(char ch)
            {
                return ch == ' ' || ch == '\t';
            }

            // Token: 0x060003F1 RID: 1009 RVA: 0x0003F7D3 File Offset: 0x0001F7D3
            private static bool MustValueBeQuoted(string key)
            {
                return key.Equals("realm", StringComparison.OrdinalIgnoreCase) || key.Equals("nonce", StringComparison.OrdinalIgnoreCase) || key.Equals("opaque", StringComparison.OrdinalIgnoreCase) || key.Equals("qop", StringComparison.OrdinalIgnoreCase);
            }

            // Token: 0x060003F2 RID: 1010 RVA: 0x0003F810 File Offset: 0x0001F810
            private string GetNextKey(string data, int currentIndex, out int parsedIndex)
            {
                while (currentIndex < data.Length && AuthenticationHelper.DigestResponse.CharIsSpaceOrTab(data[currentIndex]))
                {
                    currentIndex++;
                }
                int num = currentIndex;
                while (currentIndex < data.Length && data[currentIndex] != '=' && !AuthenticationHelper.DigestResponse.CharIsSpaceOrTab(data[currentIndex]))
                {
                    currentIndex++;
                }
                if (currentIndex == data.Length)
                {
                    parsedIndex = currentIndex;
                    return null;
                }
                int length = currentIndex - num;
                if (AuthenticationHelper.DigestResponse.CharIsSpaceOrTab(data[currentIndex]))
                {
                    while (currentIndex < data.Length && AuthenticationHelper.DigestResponse.CharIsSpaceOrTab(data[currentIndex]))
                    {
                        currentIndex++;
                    }
                    if (currentIndex == data.Length || data[currentIndex] != '=')
                    {
                        parsedIndex = currentIndex;
                        return null;
                    }
                }
                while (currentIndex < data.Length && (AuthenticationHelper.DigestResponse.CharIsSpaceOrTab(data[currentIndex]) || data[currentIndex] == '='))
                {
                    currentIndex++;
                }
                parsedIndex = currentIndex;
                return data.Substring(num, length);
            }

            // Token: 0x060003F3 RID: 1011 RVA: 0x0003F8F0 File Offset: 0x0001F8F0
            private string GetNextValue(string data, int currentIndex, bool expectQuotes, out int parsedIndex)
            {
                bool flag = false;
                if (data[currentIndex] == '"')
                {
                    flag = true;
                    currentIndex++;
                }
                if (expectQuotes && !flag)
                {
                    parsedIndex = currentIndex;
                    return null;
                }
                StringBuilder stringBuilder = StringBuilderCache.Acquire(16);
                while (currentIndex < data.Length && ((flag && data[currentIndex] != '"') || (!flag && data[currentIndex] != ',')))
                {
                    stringBuilder.Append(data[currentIndex]);
                    currentIndex++;
                    if (currentIndex == data.Length || (!flag && AuthenticationHelper.DigestResponse.CharIsSpaceOrTab(data[currentIndex])))
                    {
                        break;
                    }
                    if (flag && data[currentIndex] == '"' && data[currentIndex - 1] == '\\')
                    {
                        stringBuilder.Append(data[currentIndex]);
                        currentIndex++;
                    }
                }
                if (flag)
                {
                    currentIndex++;
                }
                while (currentIndex < data.Length && AuthenticationHelper.DigestResponse.CharIsSpaceOrTab(data[currentIndex]))
                {
                    currentIndex++;
                }
                if (currentIndex == data.Length)
                {
                    parsedIndex = currentIndex;
                    return StringBuilderCache.GetStringAndRelease(stringBuilder);
                }
                if (data[currentIndex++] != ',')
                {
                    parsedIndex = currentIndex;
                    return null;
                }
                while (currentIndex < data.Length && AuthenticationHelper.DigestResponse.CharIsSpaceOrTab(data[currentIndex]))
                {
                    currentIndex++;
                }
                parsedIndex = currentIndex;
                return StringBuilderCache.GetStringAndRelease(stringBuilder);
            }

            // Token: 0x060003F4 RID: 1012 RVA: 0x0003FA20 File Offset: 0x0001FA20
            private void Parse(string challenge)
            {
                int i = 0;
                while (i < challenge.Length)
                {
                    string nextKey = this.GetNextKey(challenge, i, out i);
                    if (string.IsNullOrEmpty(nextKey) || i >= challenge.Length)
                    {
                        break;
                    }
                    string nextValue = this.GetNextValue(challenge, i, AuthenticationHelper.DigestResponse.MustValueBeQuoted(nextKey), out i);
                    if (string.IsNullOrEmpty(nextValue))
                    {
                        break;
                    }
                    this.Parameters.Add(nextKey, nextValue);
                }
            }

            // Token: 0x04000286 RID: 646
            internal readonly Dictionary<string, string> Parameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        }
    }

    /// <summary>
    ///         バイト配列に基づく HTTP コンテンツを提供します。
    ///       </summary>
    // Token: 0x0200006F RID: 111
    class ByteArrayContent : HttpContent
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.ByteArrayContent" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="content">
        ///           初期化するために使用されるコンテンツ、 <see cref="T:System.Net.Http.ByteArrayContent" />です。
        ///         </param>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="content" /> パラメーターが <see langword="null" /> です。
        ///           </exception>
        // Token: 0x060001FF RID: 511 RVA: 0x00039564 File Offset: 0x00019564
        public ByteArrayContent(byte[] content)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            this._content = content;
            this._offset = 0;
            this._count = content.Length;
            base.SetBuffer(this._content, this._offset, this._count);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.ByteArrayContent" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="content">
        ///           初期化するために使用されるコンテンツ、 <see cref="T:System.Net.Http.ByteArrayContent" />です。
        ///         </param>
        /// <param name="offset">
        ///           オフセット (バイト単位) で、 <paramref name="content" />  初期化するために使用されるパラメーター、 <see cref="T:System.Net.Http.ByteArrayContent" />です。
        ///         </param>
        /// <param name="count">
        ///           バイト数、 <paramref name="content" /> から、 <paramref name="offset" /> 初期化するために使用されるパラメーター、 <see cref="T:System.Net.Http.ByteArrayContent" />です。
        ///         </param>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="content" /> パラメーターが <see langword="null" /> です。
        ///           </exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///             <paramref name="offset" /> パラメーターが 0 未満。
        ///
        ///             または
        ///
        ///             <paramref name="offset" /> パラメーターがで指定されたコンテンツの長さより大きい、 <paramref name="content" /> パラメーター。
        ///
        ///             または
        ///
        ///             <paramref name="count " /> パラメーターが 0 未満です。
        ///
        ///             または
        ///
        ///             <paramref name="count" /> パラメーターがで指定されたコンテンツの長さより大きい、 <paramref name="content" /> パラメーターに負符号、 <paramref name="offset" /> パラメーター。
        ///           </exception>
        // Token: 0x06000200 RID: 512 RVA: 0x000395B4 File Offset: 0x000195B4
        public ByteArrayContent(byte[] content, int offset, int count)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            if (offset < 0 || offset > content.Length)
            {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (count < 0 || count > content.Length - offset)
            {
                throw new ArgumentOutOfRangeException("count");
            }
            this._content = content;
            this._offset = offset;
            this._count = count;
            base.SetBuffer(this._content, this._offset, this._count);
        }

        /// <summary>
        ///         コンス トラクターで指定したバイト配列を、非同期操作として HTTP コンテンツ ストリームにシリアル化し書き込みます。
        ///       </summary>
        /// <param name="stream">
        ///           対象のストリーム。
        ///         </param>
        /// <param name="context">
        ///           トランスポートに関する情報 (チャネル バインディング トークンなど)。
        ///            このパラメーターは <see langword="null" /> でもかまいません。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x06000201 RID: 513 RVA: 0x0003962E File Offset: 0x0001962E
        protected override Task SerializeToStreamAsync(Stream stream, TransportContext context)
        {
            return stream.WriteAsync(this._content, this._offset, this._count);
        }

        /// <summary>
        ///         バイト配列が有効なバイト長であるかどうかを判断します。
        ///       </summary>
        /// <param name="length">
        ///           バイト配列の長さ (バイト単位)。
        ///         </param>
        /// <returns>
        ///         <paramref name="length" /> が有効な長さの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000202 RID: 514 RVA: 0x00039648 File Offset: 0x00019648
        protected internal override bool TryComputeLength(out long length)
        {
            length = (long)this._count;
            return true;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.ByteArrayContent" /> からのメモリであるバッキング ストアの読み取りの非同期操作として HTTP コンテンツ ストリームを作成します。
        ///       </summary>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x06000203 RID: 515 RVA: 0x00039654 File Offset: 0x00019654
        protected override Task<Stream> CreateContentReadStreamAsync()
        {
            return Task.FromResult<Stream>(this.CreateMemoryStreamForByteArray());
        }

        // Token: 0x06000204 RID: 516 RVA: 0x00039661 File Offset: 0x00019661
        internal override Stream TryCreateContentReadStream()
        {
            if (!(base.GetType() == typeof(ByteArrayContent)))
            {
                return null;
            }
            return this.CreateMemoryStreamForByteArray();
        }

        // Token: 0x06000205 RID: 517 RVA: 0x00039682 File Offset: 0x00019682
        internal MemoryStream CreateMemoryStreamForByteArray()
        {
            return new MemoryStream(this._content, this._offset, this._count, false);
        }

        // Token: 0x040001BF RID: 447
        private readonly byte[] _content;

        // Token: 0x040001C0 RID: 448
        private readonly int _offset;

        // Token: 0x040001C1 RID: 449
        private readonly int _count;
    }

    // Token: 0x020000A5 RID: 165
    internal static class CancellationHelper
    {
        // Token: 0x060003FE RID: 1022 RVA: 0x00040C48 File Offset: 0x00020C48
        internal static bool ShouldWrapInOperationCanceledException(Exception exception, CancellationToken cancellationToken)
        {
            return !(exception is OperationCanceledException) && cancellationToken.IsCancellationRequested;
        }

        // Token: 0x060003FF RID: 1023 RVA: 0x00040C5B File Offset: 0x00020C5B
        internal static Exception CreateOperationCanceledException(Exception innerException, CancellationToken cancellationToken)
        {
            return new TaskCanceledException(CancellationHelper.s_cancellationMessage, innerException, cancellationToken);
        }

        // Token: 0x06000400 RID: 1024 RVA: 0x00040C69 File Offset: 0x00020C69
        private static void ThrowOperationCanceledException(Exception innerException, CancellationToken cancellationToken)
        {
            throw CancellationHelper.CreateOperationCanceledException(innerException, cancellationToken);
        }

        // Token: 0x06000401 RID: 1025 RVA: 0x00040C72 File Offset: 0x00020C72
        internal static void ThrowIfCancellationRequested(CancellationToken cancellationToken)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                CancellationHelper.ThrowOperationCanceledException(null, cancellationToken);
            }
        }

        // Token: 0x040002B8 RID: 696
        private static readonly string s_cancellationMessage = new OperationCanceledException().Message;
    }

    /// <summary>
    ///         クライアント証明書の提供方法を指定します。
    ///       </summary>
    // Token: 0x02000070 RID: 112
    enum ClientCertificateOption
    {
        /// <summary>
        ///         アプリケーション手動でクライアント証明書を提供する、 <see cref="T:System.Net.Http.WebRequestHandler" />です。
        ///          この値は、既定値です。
        ///       </summary>
        // Token: 0x040001C3 RID: 451
        Manual,
        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpClientHandler" /> にすべての使用可能なクライアント証明書を自動的に提供されます。
        ///       </summary>
        // Token: 0x040001C4 RID: 452
        Automatic
    }

    // Token: 0x020000D8 RID: 216
    internal static class ConnectHelper
    {
        private static readonly System.Collections.Concurrent.ConcurrentQueue<ConnectHelper.ConnectEventArgs> s_connectEventArgs = new System.Collections.Concurrent.ConcurrentQueue<ConnectEventArgs>();

        // Token: 0x060004EC RID: 1260 RVA: 0x000486F4 File Offset: 0x000286F4
        public static async ValueTask<ValueTuple<Socket, Stream>> ConnectAsync(TcpIpSystem system, string host, int port, CancellationToken cancellationToken)
        {
            ConnectHelper.ConnectEventArgs saea = null;
            //if (!ConnectHelper.s_connectEventArgs.TryDequeue(out saea))
            //{
                saea = new ConnectHelper.ConnectEventArgs();
            //}
            ValueTuple<Socket, Stream> result;
            try
            {
                saea.Initialize(cancellationToken);
                saea.RemoteEndPoint = new DnsEndPoint(host, port);

                if (system == null)
                {
                    if (Socket.ConnectAsync(SocketType.Stream, ProtocolType.Tcp, saea))
                    {
                        using (cancellationToken.Register(delegate (object s)
                        {
                            Socket.CancelConnectAsync((SocketAsyncEventArgs)s);
                        }, saea))
                        {
                            await saea.Builder.Task.ConfigureAwait(false);
                        }
                        CancellationTokenRegistration cancellationTokenRegistration = default(CancellationTokenRegistration);
                    }
                    else if (saea.SocketError != SocketError.Success)
                    {
                        throw new SocketException((int)saea.SocketError);
                    }
                    Socket connectSocket = saea.ConnectSocket;
                    connectSocket.NoDelay = true;
                    result = new ValueTuple<Socket, Stream>(connectSocket, new NetworkStream(connectSocket, true));
                }
                else
                {
                    ConnSock connSock = await system.ConnectIPv4v6DualAsync(new TcpConnectParam(host, port), cancellationToken);
                    var networkStream = connSock.GetStream(true);
                    result = new ValueTuple<Socket, Stream>(null, networkStream);
                }
            }
            catch (Exception ex)
            {
                throw CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken) ? CancellationHelper.CreateOperationCanceledException(ex, cancellationToken) : new HttpRequestException(ex.Message, ex);
            }
            finally
            {
                saea.Clear();
                //if (!ConnectHelper.s_connectEventArgs.TryEnqueue(saea))
                {
                    saea.Dispose();
                }
            }
            return result;
        }

        // Token: 0x060004ED RID: 1261 RVA: 0x0004874C File Offset: 0x0002874C
        public static ValueTask<SslStream> EstablishSslConnectionAsync(SslClientAuthenticationOptions sslOptions, HttpRequestMessage request, Stream stream, CancellationToken cancellationToken)
        {
            RemoteCertificateValidationCallback remoteCertificateValidationCallback = sslOptions.RemoteCertificateValidationCallback;
            ConnectHelper.CertificateCallbackMapper certificateCallbackMapper;
            if (remoteCertificateValidationCallback != null && (certificateCallbackMapper = (remoteCertificateValidationCallback.Target as ConnectHelper.CertificateCallbackMapper)) != null)
            {
                sslOptions = sslOptions._ShallowClone();
                Func<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> localFromHttpClientHandler = certificateCallbackMapper.FromHttpClientHandler;
                HttpRequestMessage localRequest = request;
                sslOptions.RemoteCertificateValidationCallback = ((object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) => localFromHttpClientHandler(localRequest, certificate as X509Certificate2, chain, sslPolicyErrors));
            }
            return ConnectHelper.EstablishSslConnectionAsyncCore(stream, sslOptions, cancellationToken);
        }

        // Token: 0x060004EE RID: 1262 RVA: 0x000487B0 File Offset: 0x000287B0
        private static async ValueTask<SslStream> EstablishSslConnectionAsyncCore(Stream stream, SslClientAuthenticationOptions sslOptions, CancellationToken cancellationToken)
        {
            SslStream sslStream = new SslStream(stream);
            using (cancellationToken.Register(delegate (object s)
            {
                ((Stream)s).Dispose();
            }, stream))
            {
                try
                {
                    await sslStream.AuthenticateAsClientAsync(sslOptions, cancellationToken).ConfigureAwait(false);
                }
                catch (Exception ex)
                {
                    sslStream.Dispose();
                    if (CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken))
                    {
                        throw CancellationHelper.CreateOperationCanceledException(ex, cancellationToken);
                    }
                    throw new HttpRequestException(SR.net_http_ssl_connection_failed, ex);
                }
            }
            if (cancellationToken.IsCancellationRequested)
            {
                sslStream.Dispose();
                throw CancellationHelper.CreateOperationCanceledException(null, cancellationToken);
            }
            return sslStream;
        }

        // Token: 0x040003D2 RID: 978
        //private static readonly System.Collections.Concurrent.ConcurrentQueue<ConnectHelper.ConnectEventArgs>.Segment s_connectEventArgs = new System.Collections.Concurrent.ConcurrentQueue<ConnectHelper.ConnectEventArgs>.Segment(System.Collections.Concurrent.ConcurrentQueue<ConnectHelper.ConnectEventArgs>.Segment.RoundUpToPowerOf2(Math.Max(2, Environment.ProcessorCount)));

        // Token: 0x020000D9 RID: 217
        internal sealed class CertificateCallbackMapper
        {
            // Token: 0x060004F0 RID: 1264 RVA: 0x00048821 File Offset: 0x00028821
            public CertificateCallbackMapper(Func<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> fromHttpClientHandler)
            {
                this.FromHttpClientHandler = fromHttpClientHandler;
                this.ForSocketsHttpHandler = ((object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) => this.FromHttpClientHandler(sender as HttpRequestMessage, certificate as X509Certificate2, chain, sslPolicyErrors));
            }

            // Token: 0x040003D3 RID: 979
            public readonly Func<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> FromHttpClientHandler;

            // Token: 0x040003D4 RID: 980
            public readonly RemoteCertificateValidationCallback ForSocketsHttpHandler;
        }

        // Token: 0x020000DA RID: 218
        private sealed class ConnectEventArgs : SocketAsyncEventArgs
        {
            // Token: 0x170000EF RID: 239
            // (get) Token: 0x060004F2 RID: 1266 RVA: 0x0004885E File Offset: 0x0002885E
            // (set) Token: 0x060004F3 RID: 1267 RVA: 0x00048866 File Offset: 0x00028866
            public AsyncTaskMethodBuilder Builder { get; private set; }

            // Token: 0x170000F0 RID: 240
            // (get) Token: 0x060004F4 RID: 1268 RVA: 0x0004886F File Offset: 0x0002886F
            // (set) Token: 0x060004F5 RID: 1269 RVA: 0x00048877 File Offset: 0x00028877
            public CancellationToken CancellationToken { get; private set; }

            // Token: 0x060004F6 RID: 1270 RVA: 0x00048880 File Offset: 0x00028880
            public void Initialize(CancellationToken cancellationToken)
            {
                this.CancellationToken = cancellationToken;
                AsyncTaskMethodBuilder builder = default(AsyncTaskMethodBuilder);
                Task task = builder.Task;
                this.Builder = builder;
            }

            // Token: 0x060004F7 RID: 1271 RVA: 0x000488AC File Offset: 0x000288AC
            public void Clear()
            {
                this.CancellationToken = default(CancellationToken);
            }

            // Token: 0x060004F8 RID: 1272 RVA: 0x000488C8 File Offset: 0x000288C8
            protected override void OnCompleted(SocketAsyncEventArgs _)
            {
                SocketError socketError = base.SocketError;
                if (socketError != SocketError.Success)
                {
                    if (socketError == SocketError.OperationAborted || socketError == SocketError.ConnectionAborted)
                    {
                        if (this.CancellationToken.IsCancellationRequested)
                        {
                            this.Builder.SetException(CancellationHelper.CreateOperationCanceledException(null, this.CancellationToken));
                            return;
                        }
                    }
                    this.Builder.SetException(new SocketException((int)base.SocketError));
                    return;
                }
                this.Builder.SetResult();
            }
        }
    }

    // Token: 0x020000DF RID: 223
    internal static class CookieHelper
    {
        // Token: 0x06000504 RID: 1284 RVA: 0x00048DF4 File Offset: 0x00028DF4
        public static void ProcessReceivedCookies(HttpResponseMessage response, CookieContainer cookieContainer)
        {
            IEnumerable<string> enumerable;
            if (response.Headers.TryGetValues(KnownHeaders.SetCookie.Descriptor, out enumerable))
            {
                string[] array = (string[])enumerable;
                Uri requestUri = response.RequestMessage.RequestUri;
                for (int i = 0; i < array.Length; i++)
                {
                    try
                    {
                        cookieContainer.SetCookies(requestUri, array[i]);
                    }
                    catch (CookieException)
                    {
                        if (NetEventSource.IsEnabled)
                        {
                            NetEventSource.Error(response, FormattableStringFactory.Create("Invalid Set-Cookie '{0}' ignored.", new object[]
                            {
                                array[i]
                            }), "ProcessReceivedCookies");
                        }
                    }
                }
            }
        }
    }

    // Token: 0x020000E0 RID: 224
    internal sealed class DecompressionHandler : HttpMessageHandler
    {
        // Token: 0x06000505 RID: 1285 RVA: 0x00048E84 File Offset: 0x00028E84
        public DecompressionHandler(DecompressionMethods decompressionMethods, HttpMessageHandler innerHandler)
        {
            this._decompressionMethods = decompressionMethods;
            this._innerHandler = innerHandler;
        }

        // Token: 0x170000F1 RID: 241
        // (get) Token: 0x06000506 RID: 1286 RVA: 0x00048E9A File Offset: 0x00028E9A
        internal bool GZipEnabled
        {
            get
            {
                return (this._decompressionMethods & DecompressionMethods.GZip) > DecompressionMethods.None;
            }
        }

        // Token: 0x170000F2 RID: 242
        // (get) Token: 0x06000507 RID: 1287 RVA: 0x00048EA7 File Offset: 0x00028EA7
        internal bool DeflateEnabled
        {
            get
            {
                return (this._decompressionMethods & DecompressionMethods.Deflate) > DecompressionMethods.None;
            }
        }

        // Token: 0x06000508 RID: 1288 RVA: 0x00048EB4 File Offset: 0x00028EB4
        protected internal override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            if (this.GZipEnabled)
            {
                request.Headers.AcceptEncoding.Add(DecompressionHandler.s_gzipHeaderValue);
            }
            if (this.DeflateEnabled)
            {
                request.Headers.AcceptEncoding.Add(DecompressionHandler.s_deflateHeaderValue);
            }
            HttpResponseMessage httpResponseMessage = await this._innerHandler.SendAsync(request, cancellationToken).ConfigureAwait(false);
            HttpResponseMessage httpResponseMessage2 = httpResponseMessage;
            ICollection<string> contentEncoding = httpResponseMessage2.Content.Headers.ContentEncoding;
            if (contentEncoding.Count > 0)
            {
                string a = null;
                using (IEnumerator<string> enumerator = contentEncoding.GetEnumerator())
                {
                    while (enumerator.MoveNext())
                    {
                        a = enumerator.Current;
                    }
                }
                if (this.GZipEnabled && a == "gzip")
                {
                    httpResponseMessage2.Content = new DecompressionHandler.GZipDecompressedContent(httpResponseMessage2.Content);
                }
                else if (this.DeflateEnabled && a == "deflate")
                {
                    httpResponseMessage2.Content = new DecompressionHandler.DeflateDecompressedContent(httpResponseMessage2.Content);
                }
            }
            return httpResponseMessage2;
        }

        // Token: 0x06000509 RID: 1289 RVA: 0x00048F09 File Offset: 0x00028F09
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                this._innerHandler.Dispose();
            }
            base.Dispose(disposing);
        }

        // Token: 0x040003EC RID: 1004
        private readonly HttpMessageHandler _innerHandler;

        // Token: 0x040003ED RID: 1005
        private readonly DecompressionMethods _decompressionMethods;

        // Token: 0x040003EE RID: 1006
        private static readonly StringWithQualityHeaderValue s_gzipHeaderValue = new StringWithQualityHeaderValue("gzip");

        // Token: 0x040003EF RID: 1007
        private static readonly StringWithQualityHeaderValue s_deflateHeaderValue = new StringWithQualityHeaderValue("deflate");

        // Token: 0x020000E1 RID: 225
        private abstract class DecompressedContent : HttpContent
        {
            // Token: 0x0600050B RID: 1291 RVA: 0x00048F40 File Offset: 0x00028F40
            public DecompressedContent(HttpContent originalContent)
            {
                this._originalContent = originalContent;
                this._contentConsumed = false;
                base.Headers.AddHeaders(originalContent.Headers);
                base.Headers.ContentLength = null;
                base.Headers.ContentEncoding.Clear();
                string text = null;
                foreach (string text2 in originalContent.Headers.ContentEncoding)
                {
                    if (text != null)
                    {
                        base.Headers.ContentEncoding.Add(text);
                    }
                    text = text2;
                }
            }

            // Token: 0x0600050C RID: 1292
            protected abstract Stream GetDecompressedStream(Stream originalStream);

            // Token: 0x0600050D RID: 1293 RVA: 0x00043E9D File Offset: 0x00023E9D
            protected override Task SerializeToStreamAsync(Stream stream, TransportContext context)
            {
                return this.SerializeToStreamAsync(stream, context, CancellationToken.None);
            }

            // Token: 0x0600050E RID: 1294 RVA: 0x00048FEC File Offset: 0x00028FEC
            internal override async Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken)
            {
                Stream stream2 = await this.CreateContentReadStreamAsync().ConfigureAwait(false);
                using (Stream decompressedStream = stream2)
                {
                    await decompressedStream.CopyToAsync(stream, cancellationToken).ConfigureAwait(false);
                }
                //Stream decompressedStream = null;
            }

            // Token: 0x0600050F RID: 1295 RVA: 0x00049044 File Offset: 0x00029044
            protected override async Task<Stream> CreateContentReadStreamAsync()
            {
                if (this._contentConsumed)
                {
                    throw new InvalidOperationException(SR.net_http_content_stream_already_read);
                }
                this._contentConsumed = true;
                Stream stream = this._originalContent.TryReadAsStream();
                Stream stream2 = stream;
                if (stream2 == null)
                {
                    Stream stream3 = await this._originalContent.ReadAsStreamAsync().ConfigureAwait(false);
                    stream2 = stream3;
                }
                Stream originalStream = stream2;
                return this.GetDecompressedStream(originalStream);
            }

            // Token: 0x06000510 RID: 1296 RVA: 0x00043F01 File Offset: 0x00023F01
            protected internal override bool TryComputeLength(out long length)
            {
                length = 0L;
                return false;
            }

            // Token: 0x06000511 RID: 1297 RVA: 0x00049089 File Offset: 0x00029089
            protected override void Dispose(bool disposing)
            {
                if (disposing)
                {
                    this._originalContent.Dispose();
                }
                base.Dispose(disposing);
            }

            // Token: 0x040003F0 RID: 1008
            private HttpContent _originalContent;

            // Token: 0x040003F1 RID: 1009
            private bool _contentConsumed;
        }

        // Token: 0x020000E4 RID: 228
        private sealed class GZipDecompressedContent : DecompressionHandler.DecompressedContent
        {
            // Token: 0x06000516 RID: 1302 RVA: 0x00049356 File Offset: 0x00029356
            public GZipDecompressedContent(HttpContent originalContent) : base(originalContent)
            {
            }

            // Token: 0x06000517 RID: 1303 RVA: 0x0004935F File Offset: 0x0002935F
            protected override Stream GetDecompressedStream(Stream originalStream)
            {
                return new GZipStream(originalStream, CompressionMode.Decompress);
            }
        }

        // Token: 0x020000E5 RID: 229
        private sealed class DeflateDecompressedContent : DecompressionHandler.DecompressedContent
        {
            // Token: 0x06000518 RID: 1304 RVA: 0x00049356 File Offset: 0x00029356
            public DeflateDecompressedContent(HttpContent originalContent) : base(originalContent)
            {
            }

            // Token: 0x06000519 RID: 1305 RVA: 0x00049368 File Offset: 0x00029368
            protected override Stream GetDecompressedStream(Stream originalStream)
            {
                return new DeflateStream(originalStream, CompressionMode.Decompress);
            }
        }
    }

    /// <summary>
    ///         別のハンドラーでは、HTTP 応答メッセージの処理をデリゲートする HTTP ハンドラーの型には、内部のハンドラーが呼び出されます。
    ///       </summary>
    // Token: 0x02000071 RID: 113
    abstract class DelegatingHandler : HttpMessageHandler
    {
        /// <summary>
        ///         HTTP 応答メッセージを処理する内部ハンドラーを取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答メッセージの内部ハンドラー。
        ///       </returns>
        // Token: 0x1700008E RID: 142
        // (get) Token: 0x06000206 RID: 518 RVA: 0x0003969C File Offset: 0x0001969C
        // (set) Token: 0x06000207 RID: 519 RVA: 0x000396A4 File Offset: 0x000196A4
        public HttpMessageHandler InnerHandler
        {
            get
            {
                return this._innerHandler;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("value");
                }
                this.CheckDisposedOrStarted();
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Associate(this, value, "InnerHandler");
                }
                this._innerHandler = value;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.DelegatingHandler" /> クラスの新しいインスタンスを作成します。
        ///       </summary>
        // Token: 0x06000208 RID: 520 RVA: 0x000396D4 File Offset: 0x000196D4
        protected DelegatingHandler()
        {
        }

        /// <summary>
        ///         新しいインスタンスを作成、 <see cref="T:System.Net.Http.DelegatingHandler" /> を特定の内部ハンドラー クラス。
        ///       </summary>
        /// <param name="innerHandler">
        ///           HTTP 応答メッセージの処理を担当する内部ハンドラーです。
        ///         </param>
        // Token: 0x06000209 RID: 521 RVA: 0x000396DC File Offset: 0x000196DC
        protected DelegatingHandler(HttpMessageHandler innerHandler)
        {
            this.InnerHandler = innerHandler;
        }

        /// <summary>
        ///         非同期操作としてサーバーに送信するように HTTP 要求を内部ハンドラーに送信します。
        ///       </summary>
        /// <param name="request">
        ///           サーバーに送信する HTTP 要求メッセージ。
        ///         </param>
        /// <param name="cancellationToken">
        ///           操作をキャンセルするキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="request" /> が <see langword="null" />でした。
        ///           </exception>
        // Token: 0x0600020A RID: 522 RVA: 0x000396EB File Offset: 0x000196EB
        protected internal override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request", SR.net_http_handler_norequest);
            }
            this.SetOperationStarted();
            return this._innerHandler.SendAsync(request, cancellationToken);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.DelegatingHandler" /> が使用しているアンマネージ リソースを解放します。オプションでマネージ リソースも破棄します。
        ///       </summary>
        /// <param name="disposing">
        ///           マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。
        ///         </param>
        // Token: 0x0600020B RID: 523 RVA: 0x00039713 File Offset: 0x00019713
        protected override void Dispose(bool disposing)
        {
            if (disposing && !this._disposed)
            {
                this._disposed = true;
                if (this._innerHandler != null)
                {
                    this._innerHandler.Dispose();
                }
            }
            base.Dispose(disposing);
        }

        // Token: 0x0600020C RID: 524 RVA: 0x00039745 File Offset: 0x00019745
        private void CheckDisposed()
        {
            if (this._disposed)
            {
                throw new ObjectDisposedException(base.GetType().ToString());
            }
        }

        // Token: 0x0600020D RID: 525 RVA: 0x00039762 File Offset: 0x00019762
        private void CheckDisposedOrStarted()
        {
            this.CheckDisposed();
            if (this._operationStarted)
            {
                throw new InvalidOperationException(SR.net_http_operation_started);
            }
        }

        // Token: 0x0600020E RID: 526 RVA: 0x0003977F File Offset: 0x0001977F
        private void SetOperationStarted()
        {
            this.CheckDisposed();
            if (this._innerHandler == null)
            {
                throw new InvalidOperationException(SR.net_http_handler_not_assigned);
            }
            if (!this._operationStarted)
            {
                this._operationStarted = true;
            }
        }

        // Token: 0x040001C5 RID: 453
        private HttpMessageHandler _innerHandler;

        // Token: 0x040001C6 RID: 454
        private volatile bool _operationStarted;

        // Token: 0x040001C7 RID: 455
        private volatile bool _disposed;
    }


    // Token: 0x0200009B RID: 155
    internal abstract class DelegatingStream : Stream
    {
        // Token: 0x170000D4 RID: 212
        // (get) Token: 0x060003B3 RID: 947 RVA: 0x0003EF1C File Offset: 0x0001EF1C
        public override bool CanRead
        {
            get
            {
                return this._innerStream.CanRead;
            }
        }

        // Token: 0x170000D5 RID: 213
        // (get) Token: 0x060003B4 RID: 948 RVA: 0x0003EF29 File Offset: 0x0001EF29
        public override bool CanSeek
        {
            get
            {
                return this._innerStream.CanSeek;
            }
        }

        // Token: 0x170000D6 RID: 214
        // (get) Token: 0x060003B5 RID: 949 RVA: 0x0003EF36 File Offset: 0x0001EF36
        public override bool CanWrite
        {
            get
            {
                return this._innerStream.CanWrite;
            }
        }

        // Token: 0x170000D7 RID: 215
        // (get) Token: 0x060003B6 RID: 950 RVA: 0x0003EF43 File Offset: 0x0001EF43
        public override long Length
        {
            get
            {
                return this._innerStream.Length;
            }
        }

        // Token: 0x170000D8 RID: 216
        // (get) Token: 0x060003B7 RID: 951 RVA: 0x0003EF50 File Offset: 0x0001EF50
        // (set) Token: 0x060003B8 RID: 952 RVA: 0x0003EF5D File Offset: 0x0001EF5D
        public override long Position
        {
            get
            {
                return this._innerStream.Position;
            }
            set
            {
                this._innerStream.Position = value;
            }
        }

        // Token: 0x170000D9 RID: 217
        // (get) Token: 0x060003B9 RID: 953 RVA: 0x0003EF6B File Offset: 0x0001EF6B
        // (set) Token: 0x060003BA RID: 954 RVA: 0x0003EF78 File Offset: 0x0001EF78
        public override int ReadTimeout
        {
            get
            {
                return this._innerStream.ReadTimeout;
            }
            set
            {
                this._innerStream.ReadTimeout = value;
            }
        }

        // Token: 0x170000DA RID: 218
        // (get) Token: 0x060003BB RID: 955 RVA: 0x0003EF86 File Offset: 0x0001EF86
        public override bool CanTimeout
        {
            get
            {
                return this._innerStream.CanTimeout;
            }
        }

        // Token: 0x170000DB RID: 219
        // (get) Token: 0x060003BC RID: 956 RVA: 0x0003EF93 File Offset: 0x0001EF93
        // (set) Token: 0x060003BD RID: 957 RVA: 0x0003EFA0 File Offset: 0x0001EFA0
        public override int WriteTimeout
        {
            get
            {
                return this._innerStream.WriteTimeout;
            }
            set
            {
                this._innerStream.WriteTimeout = value;
            }
        }

        // Token: 0x060003BE RID: 958 RVA: 0x0003EFAE File Offset: 0x0001EFAE
        protected DelegatingStream(Stream innerStream)
        {
            this._innerStream = innerStream;
        }

        // Token: 0x060003BF RID: 959 RVA: 0x0003EFBD File Offset: 0x0001EFBD
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                this._innerStream.Dispose();
            }
            base.Dispose(disposing);
        }

        // Token: 0x060003C0 RID: 960 RVA: 0x0003EFD4 File Offset: 0x0001EFD4
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this._innerStream.Seek(offset, origin);
        }

        // Token: 0x060003C1 RID: 961 RVA: 0x0003EFE3 File Offset: 0x0001EFE3
        public override int Read(byte[] buffer, int offset, int count)
        {
            return this._innerStream.Read(buffer, offset, count);
        }

        // Token: 0x060003C2 RID: 962 RVA: 0x0003EFF3 File Offset: 0x0001EFF3
        public override int Read(Span<byte> buffer)
        {
            return this._innerStream.Read(buffer);
        }

        // Token: 0x060003C3 RID: 963 RVA: 0x0003F001 File Offset: 0x0001F001
        public override int ReadByte()
        {
            return this._innerStream.ReadByte();
        }

        // Token: 0x060003C4 RID: 964 RVA: 0x0003F00E File Offset: 0x0001F00E
        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            return this._innerStream.ReadAsync(buffer, offset, count, cancellationToken);
        }

        // Token: 0x060003C5 RID: 965 RVA: 0x0003F020 File Offset: 0x0001F020
        public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this._innerStream.ReadAsync(buffer, cancellationToken);
        }

        // Token: 0x060003C6 RID: 966 RVA: 0x0003F02F File Offset: 0x0001F02F
        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return this._innerStream.BeginRead(buffer, offset, count, callback, state);
        }

        // Token: 0x060003C7 RID: 967 RVA: 0x0003F043 File Offset: 0x0001F043
        public override int EndRead(IAsyncResult asyncResult)
        {
            return this._innerStream.EndRead(asyncResult);
        }

        // Token: 0x060003C8 RID: 968 RVA: 0x0003F051 File Offset: 0x0001F051
        public override void Flush()
        {
            this._innerStream.Flush();
        }

        // Token: 0x060003C9 RID: 969 RVA: 0x0003F05E File Offset: 0x0001F05E
        public override Task FlushAsync(CancellationToken cancellationToken)
        {
            return this._innerStream.FlushAsync(cancellationToken);
        }

        // Token: 0x060003CA RID: 970 RVA: 0x0003F06C File Offset: 0x0001F06C
        public override void SetLength(long value)
        {
            this._innerStream.SetLength(value);
        }

        // Token: 0x060003CB RID: 971 RVA: 0x0003F07A File Offset: 0x0001F07A
        public override void Write(byte[] buffer, int offset, int count)
        {
            this._innerStream.Write(buffer, offset, count);
        }

        // Token: 0x060003CC RID: 972 RVA: 0x0003F08A File Offset: 0x0001F08A
        public override void Write(ReadOnlySpan<byte> buffer)
        {
            this._innerStream.Write(buffer);
        }

        // Token: 0x060003CD RID: 973 RVA: 0x0003F098 File Offset: 0x0001F098
        public override void WriteByte(byte value)
        {
            this._innerStream.WriteByte(value);
        }

        // Token: 0x060003CE RID: 974 RVA: 0x0003F0A6 File Offset: 0x0001F0A6
        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            return this._innerStream.WriteAsync(buffer, offset, count, cancellationToken);
        }

        // Token: 0x060003CF RID: 975 RVA: 0x0003F0B8 File Offset: 0x0001F0B8
        public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this._innerStream.WriteAsync(buffer, cancellationToken);
        }

        // Token: 0x060003D0 RID: 976 RVA: 0x0003F0C7 File Offset: 0x0001F0C7
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return this._innerStream.BeginWrite(buffer, offset, count, callback, state);
        }

        // Token: 0x060003D1 RID: 977 RVA: 0x0003F0DB File Offset: 0x0001F0DB
        public override void EndWrite(IAsyncResult asyncResult)
        {
            this._innerStream.EndWrite(asyncResult);
        }

        // Token: 0x060003D2 RID: 978 RVA: 0x0003F0E9 File Offset: 0x0001F0E9
        public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
        {
            return this._innerStream.CopyToAsync(destination, bufferSize, cancellationToken);
        }

        // Token: 0x0400027B RID: 635
        private readonly Stream _innerStream;
    }



    // Token: 0x020000FF RID: 255
    internal sealed class DiagnosticsHandler : DelegatingHandler
    {
        // Token: 0x060005C6 RID: 1478 RVA: 0x0003D72E File Offset: 0x0001D72E
        public DiagnosticsHandler(HttpMessageHandler innerHandler) : base(innerHandler)
        {
        }

        // Token: 0x060005C7 RID: 1479 RVA: 0x0004C9AE File Offset: 0x0002C9AE
        internal static bool IsEnabled()
        {
            return DiagnosticsHandler.s_diagnosticListener.IsEnabled();
        }

        // Token: 0x060005C8 RID: 1480 RVA: 0x0004C9BC File Offset: 0x0002C9BC
        protected internal override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            Activity activity = null;
            Guid loggingRequestId = Guid.Empty;
            if (DiagnosticsHandler.s_diagnosticListener.IsEnabled("System.Net.Http.HttpRequestOut", request, null))
            {
                activity = new Activity("System.Net.Http.HttpRequestOut");
                if (DiagnosticsHandler.s_diagnosticListener.IsEnabled("System.Net.Http.HttpRequestOut.Start"))
                {
                    DiagnosticsHandler.s_diagnosticListener.StartActivity(activity, new
                    {
                        Request = request
                    });
                }
                else
                {
                    activity.Start();
                }
            }
            if (DiagnosticsHandler.s_diagnosticListener.IsEnabled("System.Net.Http.Request"))
            {
                long timestamp = Stopwatch.GetTimestamp();
                loggingRequestId = Guid.NewGuid();
                DiagnosticsHandler.s_diagnosticListener.Write("System.Net.Http.Request", new
                {
                    Request = request,
                    LoggingRequestId = loggingRequestId,
                    Timestamp = timestamp
                });
            }
            Activity activity2 = Activity.Current;
            if (activity2 != null)
            {
                request.Headers.Add("Request-Id", activity2.Id);
                using (IEnumerator<KeyValuePair<string, string>> enumerator = activity2.Baggage.GetEnumerator())
                {
                    if (enumerator.MoveNext())
                    {
                        List<string> list = new List<string>();
                        do
                        {
                            KeyValuePair<string, string> keyValuePair = enumerator.Current;
                            list.Add(new NameValueHeaderValue(keyValuePair.Key, keyValuePair.Value).ToString());
                        }
                        while (enumerator.MoveNext());
                        request.Headers.Add("Correlation-Context", list);
                    }
                }
            }
            Task<HttpResponseMessage> responseTask = null;
            HttpResponseMessage result;
            try
            {
                responseTask = base.SendAsync(request, cancellationToken);
                HttpResponseMessage httpResponseMessage = await responseTask.ConfigureAwait(false);
                result = httpResponseMessage;
            }
            catch (TaskCanceledException)
            {
                throw;
            }
            catch (Exception exception)
            {
                if (DiagnosticsHandler.s_diagnosticListener.IsEnabled("System.Net.Http.Exception"))
                {
                    DiagnosticsHandler.s_diagnosticListener.Write("System.Net.Http.Exception", new
                    {
                        Exception = exception,
                        Request = request
                    });
                }
                throw;
            }
            finally
            {
                if (activity != null)
                {
                    DiagnosticSource diagnosticSource = DiagnosticsHandler.s_diagnosticListener;
                    Activity activity3 = activity;
                    Task<HttpResponseMessage> task = responseTask;
                    HttpResponseMessage response = (task != null && task.Status == TaskStatus.RanToCompletion) ? responseTask.Result : null;
                    Task<HttpResponseMessage> task2 = responseTask;
                    diagnosticSource.StopActivity(activity3, new
                    {
                        Response = response,
                        Request = request,
                        RequestTaskStatus = ((task2 != null) ? task2.Status : TaskStatus.Faulted)
                    });
                }
                if (DiagnosticsHandler.s_diagnosticListener.IsEnabled("System.Net.Http.Response"))
                {
                    long timestamp2 = Stopwatch.GetTimestamp();
                    DiagnosticSource diagnosticSource2 = DiagnosticsHandler.s_diagnosticListener;
                    string name = "System.Net.Http.Response";
                    Task<HttpResponseMessage> task3 = responseTask;
                    HttpResponseMessage response2 = (task3 != null && task3.Status == TaskStatus.RanToCompletion) ? responseTask.Result : null;
                    Guid loggingRequestId2 = loggingRequestId;
                    Task<HttpResponseMessage> task4 = responseTask;
                    diagnosticSource2.Write(name, new
                    {
                        Response = response2,
                        LoggingRequestId = loggingRequestId2,
                        TimeStamp = timestamp2,
                        RequestTaskStatus = ((task4 != null) ? task4.Status : TaskStatus.Faulted)
                    });
                }
            }
            return result;
        }

        // Token: 0x04000483 RID: 1155
        private static readonly DiagnosticListener s_diagnosticListener = new DiagnosticListener("HttpHandlerDiagnosticListener");
    }


    /// <summary>
    ///         MIME の種類 application/x-www-form-urlencoded を使用してエンコードされた名前と値のタプルのコンテナー。
    ///       </summary>
    // Token: 0x02000072 RID: 114
    class FormUrlEncodedContent : ByteArrayContent
    {
        /// <summary>
        ///         新しいインスタンスを初期化、 <see cref="T:System.Net.Http.FormUrlEncodedContent" /> 名前/値ペアのコレクションを指定しています。
        ///       </summary>
        /// <param name="nameValueCollection">
        ///           名前/値ペアのコレクション。
        ///         </param>
        // Token: 0x0600020F RID: 527 RVA: 0x000397AD File Offset: 0x000197AD
        public FormUrlEncodedContent(IEnumerable<KeyValuePair<string, string>> nameValueCollection) : base(FormUrlEncodedContent.GetContentByteArray(nameValueCollection))
        {
            base.Headers.ContentType = new MediaTypeHeaderValue("application/x-www-form-urlencoded");
        }

        // Token: 0x06000210 RID: 528 RVA: 0x000397D0 File Offset: 0x000197D0
        private static byte[] GetContentByteArray(IEnumerable<KeyValuePair<string, string>> nameValueCollection)
        {
            if (nameValueCollection == null)
            {
                throw new ArgumentNullException("nameValueCollection");
            }
            StringBuilder stringBuilder = new StringBuilder();
            foreach (KeyValuePair<string, string> keyValuePair in nameValueCollection)
            {
                if (stringBuilder.Length > 0)
                {
                    stringBuilder.Append('&');
                }
                stringBuilder.Append(FormUrlEncodedContent.Encode(keyValuePair.Key));
                stringBuilder.Append('=');
                stringBuilder.Append(FormUrlEncodedContent.Encode(keyValuePair.Value));
            }
            return HttpRuleParser.DefaultHttpEncoding.GetBytes(stringBuilder.ToString());
        }

        // Token: 0x06000211 RID: 529 RVA: 0x00039878 File Offset: 0x00019878
        private static string Encode(string data)
        {
            if (string.IsNullOrEmpty(data))
            {
                return string.Empty;
            }
            return Uri.EscapeDataString(data).Replace("%20", "+");
        }

        // Token: 0x06000212 RID: 530 RVA: 0x0003989D File Offset: 0x0001989D
        internal override Stream TryCreateContentReadStream()
        {
            if (!(base.GetType() == typeof(FormUrlEncodedContent)))
            {
                return null;
            }
            return base.CreateMemoryStreamForByteArray();
        }
    }

    // Token: 0x020000E7 RID: 231
    internal sealed class HttpAuthenticatedConnectionHandler : HttpMessageHandler
    {
        // Token: 0x0600051C RID: 1308 RVA: 0x00049572 File Offset: 0x00029572
        public HttpAuthenticatedConnectionHandler(HttpConnectionPoolManager poolManager)
        {
            this._poolManager = poolManager;
        }

        // Token: 0x0600051D RID: 1309 RVA: 0x00049581 File Offset: 0x00029581
        protected internal override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            return this._poolManager.SendAsync(request, true, cancellationToken);
        }

        // Token: 0x0600051E RID: 1310 RVA: 0x00049591 File Offset: 0x00029591
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                this._poolManager.Dispose();
            }
            base.Dispose(disposing);
        }

        // Token: 0x04000404 RID: 1028
        private readonly HttpConnectionPoolManager _poolManager;
    }



    /// <summary>
    ///         URI で識別されるリソースに HTTP 要求を送信し、そのリソースから HTTP 応答を受信するための基本クラスを提供します。
    ///       </summary>
    // Token: 0x02000073 RID: 115
    class HttpClient : HttpMessageInvoker
    {
        /// <summary>
        ///         各要求と一緒に送信する必要があるヘッダーを取得します。
        ///       </summary>
        /// <returns>
        ///         各要求と一緒に送信する必要があるヘッダー。
        ///       </returns>
        // Token: 0x1700008F RID: 143
        // (get) Token: 0x06000213 RID: 531 RVA: 0x000398BE File Offset: 0x000198BE
        public HttpRequestHeaders DefaultRequestHeaders
        {
            get
            {
                if (this._defaultRequestHeaders == null)
                {
                    this._defaultRequestHeaders = new HttpRequestHeaders();
                }
                return this._defaultRequestHeaders;
            }
        }

        /// <summary>
        ///         要求を送信するときに使用する、インターネット リソースの Uniform Resource Identifier (URI) のベース アドレスを取得または設定します。
        ///       </summary>
        /// <returns>
        ///         要求を送信するときに使用する、インターネット リソースの Uniform Resource Identifier (URI) のベース アドレス。
        ///       </returns>
        // Token: 0x17000090 RID: 144
        // (get) Token: 0x06000214 RID: 532 RVA: 0x000398D9 File Offset: 0x000198D9
        // (set) Token: 0x06000215 RID: 533 RVA: 0x000398E1 File Offset: 0x000198E1
        public Uri BaseAddress
        {
            get
            {
                return this._baseAddress;
            }
            set
            {
                HttpClient.CheckBaseAddress(value, "value");
                this.CheckDisposedOrStarted();
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.UriBaseAddress(this, value);
                }
                this._baseAddress = value;
            }
        }

        /// <summary>
        ///         要求がタイムアウトするまで待機する期間を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         要求がタイムアウトするまで待機する期間。
        ///       </returns>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///             指定されたタイムアウトは 0 以下であり、<see cref="F:System.Threading.Timeout.InfiniteTimeSpan" /> ではありません。
        ///           </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///             操作は現在のインスタンス上で既に開始されました。
        ///           </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///             現在のインスタンスは破棄されました。
        ///           </exception>
        // Token: 0x17000091 RID: 145
        // (get) Token: 0x06000216 RID: 534 RVA: 0x00039909 File Offset: 0x00019909
        // (set) Token: 0x06000217 RID: 535 RVA: 0x00039914 File Offset: 0x00019914
        public TimeSpan Timeout
        {
            get
            {
                return this._timeout;
            }
            set
            {
                if (value != HttpClient.s_infiniteTimeout && (value <= TimeSpan.Zero || value > HttpClient.s_maxTimeout))
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                this.CheckDisposedOrStarted();
                this._timeout = value;
            }
        }

        /// <summary>
        ///         応答の内容を読み取るときにバッファーに格納できる最大バイト数を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         応答コンテンツを読み取るときに、バッファーに格納できる最大バイト数。
        ///          このプロパティの既定値は 2 GB です。
        ///       </returns>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///             指定されたサイズが 0 以下です。
        ///           </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///             操作は現在のインスタンス上で既に開始されました。
        ///           </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///             現在のインスタンスは破棄されました。
        ///           </exception>
        // Token: 0x17000092 RID: 146
        // (get) Token: 0x06000218 RID: 536 RVA: 0x00039960 File Offset: 0x00019960
        // (set) Token: 0x06000219 RID: 537 RVA: 0x0003996C File Offset: 0x0001996C
        public long MaxResponseContentBufferSize
        {
            get
            {
                return (long)this._maxResponseContentBufferSize;
            }
            set
            {
                if (value <= 0L)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                if (value > 2147483647L)
                {
                    throw new ArgumentOutOfRangeException("value", value, string.Format(CultureInfo.InvariantCulture, SR.net_http_content_buffersize_limit, int.MaxValue));
                }
                this.CheckDisposedOrStarted();
                this._maxResponseContentBufferSize = (int)value;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpClient" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        // Token: 0x0600021A RID: 538 RVA: 0x000399CA File Offset: 0x000199CA
        //public HttpClient() : this(new SocketsHttpHandler())
        //{
        //}

        /// <summary>
        ///         指定したハンドラーを使用して、<see cref="T:System.Net.Http.HttpClient" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="handler">
        ///           要求の送信に使用する HTTP ハンドラー スタック。
        ///         </param>
        // Token: 0x0600021B RID: 539 RVA: 0x000399D7 File Offset: 0x000199D7
        public HttpClient(HttpMessageHandler handler) : this(handler, true)
        {
        }

        /// <summary>
        ///         指定したハンドラーを使用して、<see cref="T:System.Net.Http.HttpClient" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        /// <param name="handler">
        ///           HTTP 応答メッセージの処理を行う <see cref="T:System.Net.Http.HttpMessageHandler" />。
        ///         </param>
        /// <param name="disposeHandler">
        ///           内部ハンドラーを Dispose() で破棄する場合は <see langword="true" />。内部ハンドラーを再利用する場合は <see langword="false" />。
        ///         </param>
        // Token: 0x0600021C RID: 540 RVA: 0x000399E4 File Offset: 0x000199E4
        public HttpClient(HttpMessageHandler handler, bool disposeHandler) : base(handler, disposeHandler)
        {
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Enter(this, handler, ".ctor");
            }
            this._timeout = HttpClient.s_defaultTimeout;
            this._maxResponseContentBufferSize = int.MaxValue;
            this._pendingRequestsCts = new CancellationTokenSource();
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Exit(this, null, ".ctor");
            }
        }

        /// <summary>
        ///         指定 URI に GET 要求を送信し、非同期操作で応答本体を文字列として返します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600021D RID: 541 RVA: 0x00039A40 File Offset: 0x00019A40
        public Task<string> GetStringAsync(string requestUri)
        {
            return this.GetStringAsync(this.CreateUri(requestUri));
        }

        /// <summary>
        ///         指定 URI に GET 要求を送信し、非同期操作で応答本体を文字列として返します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600021E RID: 542 RVA: 0x00039A4F File Offset: 0x00019A4F
        public Task<string> GetStringAsync(Uri requestUri)
        {
            return this.GetStringAsyncCore(this.GetAsync(requestUri, HttpCompletionOption.ResponseHeadersRead));
        }

        // Token: 0x0600021F RID: 543 RVA: 0x00039A60 File Offset: 0x00019A60
        private async Task<string> GetStringAsyncCore(Task<HttpResponseMessage> getTask)
        {
            HttpResponseMessage httpResponseMessage = await getTask.ConfigureAwait(false);
            string empty;
            using (HttpResponseMessage responseMessage = httpResponseMessage)
            {
                responseMessage.EnsureSuccessStatusCode();
                HttpContent content = responseMessage.Content;
                if (content != null)
                {
                    HttpContentHeaders headers = content.Headers;
                    Stream stream = content.TryReadAsStream();
                    if (stream == null)
                    {
                        stream = await content.ReadAsStreamAsync().ConfigureAwait(false);
                    }
                    using (Stream responseStream = stream)
                    {
                        using (HttpContent.LimitArrayPoolWriteStream buffer = new HttpContent.LimitArrayPoolWriteStream(this._maxResponseContentBufferSize, (long)((int)headers.ContentLength.GetValueOrDefault())))
                        {
                            await responseStream.CopyToAsync(buffer).ConfigureAwait(false);
                            if (buffer.Length > 0L)
                            {
                                return HttpContent.ReadBufferAsString(buffer.GetBuffer(), headers);
                            }
                        }
                        //HttpContent.LimitArrayPoolWriteStream buffer = null;
                    }
                    //Stream responseStream = null;
                    headers = null;
                }
                empty = string.Empty;
            }
            return empty;
        }

        /// <summary>
        ///         指定 URI に GET 要求を送信し、非同期操作で応答本体をバイト配列として返します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000220 RID: 544 RVA: 0x00039AAD File Offset: 0x00019AAD
        public Task<byte[]> GetByteArrayAsync(string requestUri)
        {
            return this.GetByteArrayAsync(this.CreateUri(requestUri));
        }

        /// <summary>
        ///         指定 URI に GET 要求を送信し、非同期操作で応答本体をバイト配列として返します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000221 RID: 545 RVA: 0x00039ABC File Offset: 0x00019ABC
        public Task<byte[]> GetByteArrayAsync(Uri requestUri)
        {
            return this.GetByteArrayAsyncCore(this.GetAsync(requestUri, HttpCompletionOption.ResponseHeadersRead));
        }

        // Token: 0x06000222 RID: 546 RVA: 0x00039ACC File Offset: 0x00019ACC
        private async Task<byte[]> GetByteArrayAsyncCore(Task<HttpResponseMessage> getTask)
        {
            HttpResponseMessage httpResponseMessage = await getTask.ConfigureAwait(false);
            byte[] result;
            using (HttpResponseMessage responseMessage = httpResponseMessage)
            {
                responseMessage.EnsureSuccessStatusCode();
                HttpContent content = responseMessage.Content;
                if (content != null)
                {
                    HttpContentHeaders headers = content.Headers;
                    Stream stream = content.TryReadAsStream();
                    if (stream == null)
                    {
                        stream = await content.ReadAsStreamAsync().ConfigureAwait(false);
                    }
                    using (Stream responseStream = stream)
                    {
                        long? contentLength = headers.ContentLength;
                        Stream buffer;
                        if (contentLength != null)
                        {
                            buffer = new HttpContent.LimitMemoryStream(this._maxResponseContentBufferSize, (int)contentLength.GetValueOrDefault());
                            await responseStream.CopyToAsync(buffer).ConfigureAwait(false);
                            if (buffer.Length > 0L)
                            {
                                return ((HttpContent.LimitMemoryStream)buffer).GetSizedBuffer();
                            }
                        }
                        else
                        {
                            buffer = new HttpContent.LimitArrayPoolWriteStream(this._maxResponseContentBufferSize);
                            try
                            {
                                await responseStream.CopyToAsync(buffer).ConfigureAwait(false);
                                if (buffer.Length > 0L)
                                {
                                    return ((HttpContent.LimitArrayPoolWriteStream)buffer).ToArray();
                                }
                            }
                            finally
                            {
                                buffer.Dispose();
                            }
                        }
                        //buffer = null;
                    }
                    //Stream responseStream = null;
                    headers = null;
                }
                result = Array.Empty<byte>();
            }
            return result;
        }

        /// <summary>
        ///         指定 URI に GET 要求を送信し、非同期操作で応答本体をストリームとして返します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000223 RID: 547 RVA: 0x00039B19 File Offset: 0x00019B19
        public Task<Stream> GetStreamAsync(string requestUri)
        {
            return this.GetStreamAsync(this.CreateUri(requestUri));
        }

        /// <summary>
        ///         指定 URI に GET 要求を送信し、非同期操作で応答本体をストリームとして返します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000224 RID: 548 RVA: 0x00039B28 File Offset: 0x00019B28
        public Task<Stream> GetStreamAsync(Uri requestUri)
        {
            return this.FinishGetStreamAsync(this.GetAsync(requestUri, HttpCompletionOption.ResponseHeadersRead));
        }

        // Token: 0x06000225 RID: 549 RVA: 0x00039B38 File Offset: 0x00019B38
        private async Task<Stream> FinishGetStreamAsync(Task<HttpResponseMessage> getTask)
        {
            HttpResponseMessage httpResponseMessage = await getTask.ConfigureAwait(false);
            HttpResponseMessage httpResponseMessage2 = httpResponseMessage;
            httpResponseMessage2.EnsureSuccessStatusCode();
            HttpContent content = httpResponseMessage2.Content;
            Stream result;
            if (content != null)
            {
                Stream stream = content.TryReadAsStream();
                if (stream == null)
                {
                    stream = await content.ReadAsStreamAsync().ConfigureAwait(false);
                }
                result = stream;
            }
            else
            {
                result = Stream.Null;
            }
            return result;
        }

        /// <summary>
        ///         指定された URI に GET 要求を非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000226 RID: 550 RVA: 0x00039B7D File Offset: 0x00019B7D
        public Task<HttpResponseMessage> GetAsync(string requestUri)
        {
            return this.GetAsync(this.CreateUri(requestUri));
        }

        /// <summary>
        ///         指定された URI に GET 要求を非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000227 RID: 551 RVA: 0x00039B8C File Offset: 0x00019B8C
        public Task<HttpResponseMessage> GetAsync(Uri requestUri)
        {
            return this.GetAsync(requestUri, HttpCompletionOption.ResponseContentRead);
        }

        /// <summary>
        ///         非同期操作としてHTTP 完了オプションを使用して GET 要求を指定された Uri に送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="completionOption">
        ///           操作が完了したものと見なすタイミングを示す HTTP 完了オプション値。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000228 RID: 552 RVA: 0x00039B96 File Offset: 0x00019B96
        public Task<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption)
        {
            return this.GetAsync(this.CreateUri(requestUri), completionOption);
        }

        /// <summary>
        ///         非同期操作としてHTTP 完了オプションを使用して GET 要求を指定された Uri に送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="completionOption">
        ///           操作が完了したものと見なすタイミングを示す HTTP 完了オプション値。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000229 RID: 553 RVA: 0x00039BA6 File Offset: 0x00019BA6
        public Task<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption)
        {
            return this.GetAsync(requestUri, completionOption, CancellationToken.None);
        }

        /// <summary>
        ///         非同期操作としてキャンセル トークンを使用して GET 要求を指定された Uri に送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600022A RID: 554 RVA: 0x00039BB5 File Offset: 0x00019BB5
        public Task<HttpResponseMessage> GetAsync(string requestUri, CancellationToken cancellationToken)
        {
            return this.GetAsync(this.CreateUri(requestUri), cancellationToken);
        }

        /// <summary>
        ///         非同期操作としてキャンセル トークンを使用して GET 要求を指定された Uri に送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600022B RID: 555 RVA: 0x00039BC5 File Offset: 0x00019BC5
        public Task<HttpResponseMessage> GetAsync(Uri requestUri, CancellationToken cancellationToken)
        {
            return this.GetAsync(requestUri, HttpCompletionOption.ResponseContentRead, cancellationToken);
        }

        /// <summary>
        ///         非同期操作としてキャンセル トークンおよび HTTP 完了オプションを使用して GET 要求を指定された Uri に送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="completionOption">
        ///           操作が完了したものと見なすタイミングを示す HTTP 完了オプション値。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600022C RID: 556 RVA: 0x00039BD0 File Offset: 0x00019BD0
        public Task<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken)
        {
            return this.GetAsync(this.CreateUri(requestUri), completionOption, cancellationToken);
        }

        /// <summary>
        ///         非同期操作としてキャンセル トークンおよび HTTP 完了オプションを使用して GET 要求を指定された Uri に送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="completionOption">
        ///           操作が完了したものと見なすタイミングを示す HTTP 完了オプション値。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600022D RID: 557 RVA: 0x00039BE1 File Offset: 0x00019BE1
        public Task<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken)
        {
            return this.SendAsync(new HttpRequestMessage(HttpMethod.Get, requestUri), completionOption, cancellationToken);
        }

        /// <summary>
        ///         指定された URI に POST 要求を非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="content">
        ///           サーバーに送信される HTTP 要求の内容。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600022E RID: 558 RVA: 0x00039BF6 File Offset: 0x00019BF6
        public Task<HttpResponseMessage> PostAsync(string requestUri, HttpContent content)
        {
            return this.PostAsync(this.CreateUri(requestUri), content);
        }

        /// <summary>
        ///         指定された URI に POST 要求を非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="content">
        ///           サーバーに送信される HTTP 要求の内容。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600022F RID: 559 RVA: 0x00039C06 File Offset: 0x00019C06
        public Task<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content)
        {
            return this.PostAsync(requestUri, content, CancellationToken.None);
        }

        /// <summary>
        ///         POST 要求をキャンセル トークンとともに非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="content">
        ///           サーバーに送信される HTTP 要求の内容。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000230 RID: 560 RVA: 0x00039C15 File Offset: 0x00019C15
        public Task<HttpResponseMessage> PostAsync(string requestUri, HttpContent content, CancellationToken cancellationToken)
        {
            return this.PostAsync(this.CreateUri(requestUri), content, cancellationToken);
        }

        /// <summary>
        ///         POST 要求をキャンセル トークンとともに非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="content">
        ///           サーバーに送信される HTTP 要求の内容。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000231 RID: 561 RVA: 0x00039C28 File Offset: 0x00019C28
        public Task<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken)
        {
            return this.SendAsync(new HttpRequestMessage(HttpMethod.Post, requestUri)
            {
                Content = content
            }, cancellationToken);
        }

        /// <summary>
        ///         指定された URI に PUT 要求を非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="content">
        ///           サーバーに送信される HTTP 要求の内容。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000232 RID: 562 RVA: 0x00039C50 File Offset: 0x00019C50
        public Task<HttpResponseMessage> PutAsync(string requestUri, HttpContent content)
        {
            return this.PutAsync(this.CreateUri(requestUri), content);
        }

        /// <summary>
        ///         指定された URI に PUT 要求を非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="content">
        ///           サーバーに送信される HTTP 要求の内容。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000233 RID: 563 RVA: 0x00039C60 File Offset: 0x00019C60
        public Task<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content)
        {
            return this.PutAsync(requestUri, content, CancellationToken.None);
        }

        /// <summary>
        ///         PUT 要求をとキャンセル トークンと共に非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="content">
        ///           サーバーに送信される HTTP 要求の内容。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000234 RID: 564 RVA: 0x00039C6F File Offset: 0x00019C6F
        public Task<HttpResponseMessage> PutAsync(string requestUri, HttpContent content, CancellationToken cancellationToken)
        {
            return this.PutAsync(this.CreateUri(requestUri), content, cancellationToken);
        }

        /// <summary>
        ///         PUT 要求をとキャンセル トークンと共に非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="content">
        ///           サーバーに送信される HTTP 要求の内容。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" /> でした。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000235 RID: 565 RVA: 0x00039C80 File Offset: 0x00019C80
        public Task<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken)
        {
            return this.SendAsync(new HttpRequestMessage(HttpMethod.Put, requestUri)
            {
                Content = content
            }, cancellationToken);
        }

        // Token: 0x06000236 RID: 566 RVA: 0x00039CA8 File Offset: 0x00019CA8
        public Task<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content)
        {
            return this.PatchAsync(this.CreateUri(requestUri), content);
        }

        // Token: 0x06000237 RID: 567 RVA: 0x00039CB8 File Offset: 0x00019CB8
        public Task<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content)
        {
            return this.PatchAsync(requestUri, content, CancellationToken.None);
        }

        // Token: 0x06000238 RID: 568 RVA: 0x00039CC7 File Offset: 0x00019CC7
        public Task<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content, CancellationToken cancellationToken)
        {
            return this.PatchAsync(this.CreateUri(requestUri), content, cancellationToken);
        }

        // Token: 0x06000239 RID: 569 RVA: 0x00039CD8 File Offset: 0x00019CD8
        public Task<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken)
        {
            return this.SendAsync(new HttpRequestMessage(HttpMethod.Patch, requestUri)
            {
                Content = content
            }, cancellationToken);
        }

        /// <summary>
        ///         指定された URI に DELETE 要求を非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" />でした。
        ///           </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///             要求メッセージは <see cref="T:System.Net.Http.HttpClient" /> インスタンスによって既に送信されました。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600023A RID: 570 RVA: 0x00039D00 File Offset: 0x00019D00
        public Task<HttpResponseMessage> DeleteAsync(string requestUri)
        {
            return this.DeleteAsync(this.CreateUri(requestUri));
        }

        /// <summary>
        ///         指定された URI に DELETE 要求を非同期操作として送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" />でした。
        ///           </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///             要求メッセージは <see cref="T:System.Net.Http.HttpClient" /> インスタンスによって既に送信されました。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600023B RID: 571 RVA: 0x00039D0F File Offset: 0x00019D0F
        public Task<HttpResponseMessage> DeleteAsync(Uri requestUri)
        {
            return this.DeleteAsync(requestUri, CancellationToken.None);
        }

        /// <summary>
        ///         非同期操作としてキャンセル トークンを使用して削除要求を指定された Uri に送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" />でした。
        ///           </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///             要求メッセージは <see cref="T:System.Net.Http.HttpClient" /> インスタンスによって既に送信されました。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600023C RID: 572 RVA: 0x00039D1D File Offset: 0x00019D1D
        public Task<HttpResponseMessage> DeleteAsync(string requestUri, CancellationToken cancellationToken)
        {
            return this.DeleteAsync(this.CreateUri(requestUri), cancellationToken);
        }

        /// <summary>
        ///         非同期操作としてキャンセル トークンを使用して削除要求を指定された Uri に送信します。
        ///       </summary>
        /// <param name="requestUri">
        ///           要求の送信先 URI。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="requestUri" /> が <see langword="null" />でした。
        ///           </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///             要求メッセージは <see cref="T:System.Net.Http.HttpClient" /> インスタンスによって既に送信されました。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600023D RID: 573 RVA: 0x00039D2D File Offset: 0x00019D2D
        public Task<HttpResponseMessage> DeleteAsync(Uri requestUri, CancellationToken cancellationToken)
        {
            return this.SendAsync(new HttpRequestMessage(HttpMethod.Delete, requestUri), cancellationToken);
        }

        /// <summary>
        ///         非同期操作として HTTP 要求を送信します。
        ///       </summary>
        /// <param name="request">
        ///           送信する HTTP 要求メッセージ。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="request" /> が <see langword="null" />でした。
        ///           </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///             要求メッセージは <see cref="T:System.Net.Http.HttpClient" /> インスタンスによって既に送信されました。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600023E RID: 574 RVA: 0x00039D41 File Offset: 0x00019D41
        public Task<HttpResponseMessage> SendAsync(HttpRequestMessage request)
        {
            return this.SendAsync(request, HttpCompletionOption.ResponseContentRead, CancellationToken.None);
        }

        /// <summary>
        ///         非同期操作として HTTP 要求を送信します。
        ///       </summary>
        /// <param name="request">
        ///           送信する HTTP 要求メッセージ。
        ///         </param>
        /// <param name="cancellationToken">
        ///           操作をキャンセルするキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="request" /> が <see langword="null" />でした。
        ///           </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///             要求メッセージは <see cref="T:System.Net.Http.HttpClient" /> インスタンスによって既に送信されました。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x0600023F RID: 575 RVA: 0x00039D50 File Offset: 0x00019D50
        public override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            return this.SendAsync(request, HttpCompletionOption.ResponseContentRead, cancellationToken);
        }

        /// <summary>
        ///         非同期操作として HTTP 要求を送信します。
        ///       </summary>
        /// <param name="request">
        ///           送信する HTTP 要求メッセージ。
        ///         </param>
        /// <param name="completionOption">
        ///           操作が完了したとき (応答が使用できる状態になった後か、応答コンテンツ全体が読み取られた後)。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="request" /> が <see langword="null" />でした。
        ///           </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///             要求メッセージは <see cref="T:System.Net.Http.HttpClient" /> インスタンスによって既に送信されました。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000240 RID: 576 RVA: 0x00039D5B File Offset: 0x00019D5B
        public Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption)
        {
            return this.SendAsync(request, completionOption, CancellationToken.None);
        }

        /// <summary>
        ///         非同期操作として HTTP 要求を送信します。
        ///       </summary>
        /// <param name="request">
        ///           送信する HTTP 要求メッセージ。
        ///         </param>
        /// <param name="completionOption">
        ///           操作が完了したとき (応答が使用できる状態になった後か、応答コンテンツ全体が読み取られた後)。
        ///         </param>
        /// <param name="cancellationToken">
        ///           操作をキャンセルするキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="request" /> が <see langword="null" />でした。
        ///           </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///             要求メッセージは <see cref="T:System.Net.Http.HttpClient" /> インスタンスによって既に送信されました。
        ///           </exception>
        /// <exception cref="T:System.Net.Http.HttpRequestException">
        ///             ネットワーク接続、DNS エラー、サーバー証明書の検証またはタイムアウトなどの基になる問題のため、要求が失敗しました。
        ///           </exception>
        // Token: 0x06000241 RID: 577 RVA: 0x00039D6C File Offset: 0x00019D6C
        public Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            this.CheckDisposed();
            HttpClient.CheckRequestMessage(request);
            this.SetOperationStarted();
            this.PrepareRequestMessage(request);
            bool flag = this._timeout != HttpClient.s_infiniteTimeout;
            bool disposeCts;
            CancellationTokenSource cancellationTokenSource;
            if (flag || cancellationToken.CanBeCanceled)
            {
                disposeCts = true;
                cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, this._pendingRequestsCts.Token);
                if (flag)
                {
                    cancellationTokenSource.CancelAfter(this._timeout);
                }
            }
            else
            {
                disposeCts = false;
                cancellationTokenSource = this._pendingRequestsCts;
            }
            Task<HttpResponseMessage> sendTask;
            try
            {
                sendTask = base.SendAsync(request, cancellationTokenSource.Token);
            }
            catch
            {
                this.HandleFinishSendAsyncCleanup(cancellationTokenSource, disposeCts);
                throw;
            }
            if (completionOption != HttpCompletionOption.ResponseContentRead)
            {
                return this.FinishSendAsyncUnbuffered(sendTask, request, cancellationTokenSource, disposeCts);
            }
            return this.FinishSendAsyncBuffered(sendTask, request, cancellationTokenSource, disposeCts);
        }

        // Token: 0x06000242 RID: 578 RVA: 0x00039E30 File Offset: 0x00019E30
        private async Task<HttpResponseMessage> FinishSendAsyncBuffered(Task<HttpResponseMessage> sendTask, HttpRequestMessage request, CancellationTokenSource cts, bool disposeCts)
        {
            HttpResponseMessage response = null;
            HttpResponseMessage result;
            try
            {
                HttpResponseMessage httpResponseMessage = await sendTask.ConfigureAwait(false);
                response = httpResponseMessage;
                if (response == null)
                {
                    throw new InvalidOperationException(SR.net_http_handler_noresponse);
                }
                if (response.Content != null)
                {
                    await response.Content.LoadIntoBufferAsync((long)this._maxResponseContentBufferSize, cts.Token).ConfigureAwait(false);
                }
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.ClientSendCompleted(this, response, request);
                }
                result = response;
            }
            catch (Exception e)
            {
                HttpResponseMessage httpResponseMessage2 = response;
                if (httpResponseMessage2 != null)
                {
                    httpResponseMessage2.Dispose();
                }
                this.HandleFinishSendAsyncError(e, cts);
                throw;
            }
            finally
            {
                this.HandleFinishSendAsyncCleanup(cts, disposeCts);
            }
            return result;
        }

        // Token: 0x06000243 RID: 579 RVA: 0x00039E98 File Offset: 0x00019E98
        private async Task<HttpResponseMessage> FinishSendAsyncUnbuffered(Task<HttpResponseMessage> sendTask, HttpRequestMessage request, CancellationTokenSource cts, bool disposeCts)
        {
            HttpResponseMessage result;
            try
            {
                HttpResponseMessage httpResponseMessage = await sendTask.ConfigureAwait(false);
                HttpResponseMessage httpResponseMessage2 = httpResponseMessage;
                if (httpResponseMessage2 == null)
                {
                    throw new InvalidOperationException(SR.net_http_handler_noresponse);
                }
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.ClientSendCompleted(this, httpResponseMessage2, request);
                }
                result = httpResponseMessage2;
            }
            catch (Exception e)
            {
                this.HandleFinishSendAsyncError(e, cts);
                throw;
            }
            finally
            {
                this.HandleFinishSendAsyncCleanup(cts, disposeCts);
            }
            return result;
        }

        // Token: 0x06000244 RID: 580 RVA: 0x00039F00 File Offset: 0x00019F00
        private void HandleFinishSendAsyncError(Exception e, CancellationTokenSource cts)
        {
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Error(this, e, "HandleFinishSendAsyncError");
            }
            if (cts.IsCancellationRequested && e is HttpRequestException)
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(this, FormattableStringFactory.Create("Canceled", Array.Empty<object>()), "HandleFinishSendAsyncError");
                }
                throw new OperationCanceledException(cts.Token);
            }
        }

        // Token: 0x06000245 RID: 581 RVA: 0x00039F5D File Offset: 0x00019F5D
        private void HandleFinishSendAsyncCleanup(CancellationTokenSource cts, bool disposeCts)
        {
            if (disposeCts)
            {
                cts.Dispose();
            }
        }

        /// <summary>
        ///         このインスタンスの保留中の要求をすべてキャンセルします。
        ///       </summary>
        // Token: 0x06000246 RID: 582 RVA: 0x00039F68 File Offset: 0x00019F68
        public void CancelPendingRequests()
        {
            this.CheckDisposed();
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Enter(this, null, "CancelPendingRequests");
            }
            CancellationTokenSource cancellationTokenSource = Interlocked.Exchange<CancellationTokenSource>(ref this._pendingRequestsCts, new CancellationTokenSource());
            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Exit(this, null, "CancelPendingRequests");
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpClient" /> が使用しているアンマネージ リソースを解放します。オプションとして、マネージ リソースを破棄することもできます。
        ///       </summary>
        /// <param name="disposing">
        ///           マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。
        ///         </param>
        // Token: 0x06000247 RID: 583 RVA: 0x00039FBE File Offset: 0x00019FBE
        protected override void Dispose(bool disposing)
        {
            if (disposing && !this._disposed)
            {
                this._disposed = true;
                this._pendingRequestsCts.Cancel();
                this._pendingRequestsCts.Dispose();
            }
            base.Dispose(disposing);
        }

        // Token: 0x06000248 RID: 584 RVA: 0x00039FF3 File Offset: 0x00019FF3
        private void SetOperationStarted()
        {
            if (!this._operationStarted)
            {
                this._operationStarted = true;
            }
        }

        // Token: 0x06000249 RID: 585 RVA: 0x0003A008 File Offset: 0x0001A008
        private void CheckDisposedOrStarted()
        {
            this.CheckDisposed();
            if (this._operationStarted)
            {
                throw new InvalidOperationException(SR.net_http_operation_started);
            }
        }

        // Token: 0x0600024A RID: 586 RVA: 0x0003A025 File Offset: 0x0001A025
        private void CheckDisposed()
        {
            if (this._disposed)
            {
                throw new ObjectDisposedException(base.GetType().ToString());
            }
        }

        // Token: 0x0600024B RID: 587 RVA: 0x0003A042 File Offset: 0x0001A042
        private static void CheckRequestMessage(HttpRequestMessage request)
        {
            if (!request.MarkAsSent())
            {
                throw new InvalidOperationException(SR.net_http_client_request_already_sent);
            }
        }

        // Token: 0x0600024C RID: 588 RVA: 0x0003A058 File Offset: 0x0001A058
        private void PrepareRequestMessage(HttpRequestMessage request)
        {
            Uri uri = null;
            if (request.RequestUri == null && this._baseAddress == null)
            {
                throw new InvalidOperationException(SR.net_http_client_invalid_requesturi);
            }
            if (request.RequestUri == null)
            {
                uri = this._baseAddress;
            }
            else if (!request.RequestUri.IsAbsoluteUri)
            {
                if (this._baseAddress == null)
                {
                    throw new InvalidOperationException(SR.net_http_client_invalid_requesturi);
                }
                uri = new Uri(this._baseAddress, request.RequestUri);
            }
            if (uri != null)
            {
                request.RequestUri = uri;
            }
            if (this._defaultRequestHeaders != null)
            {
                request.Headers.AddHeaders(this._defaultRequestHeaders);
            }
        }

        // Token: 0x0600024D RID: 589 RVA: 0x0003A106 File Offset: 0x0001A106
        private static void CheckBaseAddress(Uri baseAddress, string parameterName)
        {
            if (baseAddress == null)
            {
                return;
            }
            if (!baseAddress.IsAbsoluteUri)
            {
                throw new ArgumentException(SR.net_http_client_absolute_baseaddress_required, parameterName);
            }
            if (!HttpUtilities.IsHttpUri(baseAddress))
            {
                throw new ArgumentException(SR.net_http_client_http_baseaddress_required, parameterName);
            }
        }

        // Token: 0x0600024E RID: 590 RVA: 0x0003A13A File Offset: 0x0001A13A
        private Uri CreateUri(string uri)
        {
            if (string.IsNullOrEmpty(uri))
            {
                return null;
            }
            return new Uri(uri, UriKind.RelativeOrAbsolute);
        }

        // Token: 0x040001C8 RID: 456
        private static readonly TimeSpan s_defaultTimeout = TimeSpan.FromSeconds(100.0);

        // Token: 0x040001C9 RID: 457
        private static readonly TimeSpan s_maxTimeout = TimeSpan.FromMilliseconds(2147483647.0);

        // Token: 0x040001CA RID: 458
        private static readonly TimeSpan s_infiniteTimeout = System.Threading.Timeout.InfiniteTimeSpan;

        // Token: 0x040001CB RID: 459
        private volatile bool _operationStarted;

        // Token: 0x040001CC RID: 460
        private volatile bool _disposed;

        // Token: 0x040001CD RID: 461
        private CancellationTokenSource _pendingRequestsCts;

        // Token: 0x040001CE RID: 462
        private HttpRequestHeaders _defaultRequestHeaders;

        // Token: 0x040001CF RID: 463
        private Uri _baseAddress;

        // Token: 0x040001D0 RID: 464
        private TimeSpan _timeout;

        // Token: 0x040001D1 RID: 465
        private int _maxResponseContentBufferSize;
    }



    /// <summary>
    ///         かどうか示す <see cref="T:System.Net.Http.HttpClient" /> 応答が利用可能なまたは、コンテンツを含む全体の応答メッセージを読んだ後に完了した操作を考慮する必要があります。
    ///       </summary>
    // Token: 0x0200007B RID: 123
    enum HttpCompletionOption
    {
        /// <summary>
        ///         内容を含む応答全体を読んだ後、操作が完了する必要があります。
        ///       </summary>
        // Token: 0x04000209 RID: 521
        ResponseContentRead,
        /// <summary>
        ///         応答があると、ヘッダーが読み取られるとすぐに操作が完了する必要があります。
        ///          コンテンツがまだ読み取られていません。
        ///       </summary>
        // Token: 0x0400020A RID: 522
        ResponseHeadersRead
    }


    // Token: 0x020000A6 RID: 166
    internal class HttpConnection : IDisposable
    {
        // Token: 0x06000403 RID: 1027 RVA: 0x00040C98 File Offset: 0x00020C98
        public HttpConnection(HttpConnectionPool pool, Socket socket, Stream stream, TransportContext transportContext)
        {
            this._pool = pool;
            this._socket = socket;
            this._stream = stream;
            this._transportContext = transportContext;
            this._writeBuffer = new byte[4096];
            this._readBuffer = new byte[4096];
            this._weakThisRef = new WeakReference<HttpConnection>(this);
            if (NetEventSource.IsEnabled)
            {
                if (pool.IsSecure)
                {
                    SslStream sslStream = (SslStream)this._stream;
                    this.Trace(string.Concat(new string[]
                    {
                        string.Format("Secure connection created to {0}. ", pool),
                        string.Format("SslProtocol:{0}, ", sslStream.SslProtocol),
                        string.Format("CipherAlgorithm:{0}, CipherStrength:{1}, ", sslStream.CipherAlgorithm, sslStream.CipherStrength),
                        string.Format("HashAlgorithm:{0}, HashStrength:{1}, ", sslStream.HashAlgorithm, sslStream.HashStrength),
                        string.Format("KeyExchangeAlgorithm:{0}, KeyExchangeStrength:{1}, ", sslStream.KeyExchangeAlgorithm, sslStream.KeyExchangeStrength),
                        string.Format("LocalCert:{0}, RemoteCert:{1}", sslStream.LocalCertificate, sslStream.RemoteCertificate)
                    }), ".ctor");
                    return;
                }
                this.Trace(string.Format("Connection created to {0}.", pool), ".ctor");
            }
        }

        // Token: 0x06000404 RID: 1028 RVA: 0x00040DF5 File Offset: 0x00020DF5
        public void Dispose()
        {
            this.Dispose(true);
        }

        // Token: 0x06000405 RID: 1029 RVA: 0x00040E00 File Offset: 0x00020E00
        protected void Dispose(bool disposing)
        {
            if (Interlocked.Exchange(ref this._disposed, 1) == 0)
            {
                if (NetEventSource.IsEnabled)
                {
                    this.Trace("Connection closing.", "Dispose");
                }
                this._pool.DecrementConnectionCount();
                if (disposing)
                {
                    GC.SuppressFinalize(this);
                    this._stream.Dispose();
                    ValueTask<int>? valueTask = this.ConsumeReadAheadTask();
                    if (valueTask != null)
                    {
                        HttpConnection.IgnoreExceptionsAsync(valueTask.GetValueOrDefault());
                    }
                }
            }
        }

        // Token: 0x06000406 RID: 1030 RVA: 0x00040E70 File Offset: 0x00020E70
        private static async void IgnoreExceptionsAsync(ValueTask<int> task)
        {
            try
            {
                await task.ConfigureAwait(false);
            }
            catch
            {
            }
        }

        // Token: 0x06000407 RID: 1031 RVA: 0x00040EAC File Offset: 0x00020EAC
        public bool PollRead()
        {
            if (this._socket != null)
            {
                try
                {
                    return this._socket.Poll(0, SelectMode.SelectRead);
                }
                catch (Exception ex) when (ex is SocketException || ex is ObjectDisposedException)
                {
                    return true;
                }
            }
            return this.EnsureReadAheadAndPollRead();
        }

        // Token: 0x06000408 RID: 1032 RVA: 0x00040F14 File Offset: 0x00020F14
        public bool EnsureReadAheadAndPollRead()
        {
            try
            {
                if (this._readAheadTask == null)
                {
                    this._readAheadTask = new ValueTask<int>?(this._stream.ReadAsync(new Memory<byte>(this._readBuffer), default(CancellationToken)));
                }
            }
            catch (Exception arg)
            {
                if (NetEventSource.IsEnabled)
                {
                    this.Trace(string.Format("Error performing read ahead: {0}", arg), "EnsureReadAheadAndPollRead");
                }
                this.Dispose();
                this._readAheadTask = new ValueTask<int>?(new ValueTask<int>(0));
            }
            return this._readAheadTask.Value.IsCompleted;
        }

        // Token: 0x06000409 RID: 1033 RVA: 0x00040FB4 File Offset: 0x00020FB4
        private ValueTask<int>? ConsumeReadAheadTask()
        {
            if (Interlocked.CompareExchange(ref this._readAheadTaskLock, 1, 0) == 0)
            {
                ValueTask<int>? readAheadTask = this._readAheadTask;
                this._readAheadTask = null;
                Volatile.Write(ref this._readAheadTaskLock, 0);
                return readAheadTask;
            }
            return null;
        }

        // Token: 0x170000E0 RID: 224
        // (get) Token: 0x0600040A RID: 1034 RVA: 0x00040FFA File Offset: 0x00020FFA
        public bool IsNewConnection
        {
            get
            {
                return this._readAheadTask == null;
            }
        }

        // Token: 0x170000E1 RID: 225
        // (get) Token: 0x0600040B RID: 1035 RVA: 0x0004100A File Offset: 0x0002100A
        public bool CanRetry
        {
            get
            {
                return this._canRetry;
            }
        }

        // Token: 0x170000E2 RID: 226
        // (get) Token: 0x0600040C RID: 1036 RVA: 0x00041012 File Offset: 0x00021012
        public DateTimeOffset CreationTime { get; } = DateTimeOffset.UtcNow;

        // Token: 0x170000E3 RID: 227
        // (get) Token: 0x0600040D RID: 1037 RVA: 0x0004101A File Offset: 0x0002101A
        public TransportContext TransportContext
        {
            get
            {
                return this._transportContext;
            }
        }

        // Token: 0x170000E4 RID: 228
        // (get) Token: 0x0600040E RID: 1038 RVA: 0x00041022 File Offset: 0x00021022
        public HttpConnectionKind Kind
        {
            get
            {
                return this._pool.Kind;
            }
        }

        // Token: 0x170000E5 RID: 229
        // (get) Token: 0x0600040F RID: 1039 RVA: 0x0004102F File Offset: 0x0002102F
        private int ReadBufferSize
        {
            get
            {
                return this._readBuffer.Length;
            }
        }

        // Token: 0x170000E6 RID: 230
        // (get) Token: 0x06000410 RID: 1040 RVA: 0x00041039 File Offset: 0x00021039
        private ReadOnlyMemory<byte> RemainingBuffer
        {
            get
            {
                return new ReadOnlyMemory<byte>(this._readBuffer, this._readOffset, this._readLength - this._readOffset);
            }
        }

        // Token: 0x06000411 RID: 1041 RVA: 0x00041059 File Offset: 0x00021059
        private void ConsumeFromRemainingBuffer(int bytesToConsume)
        {
            this._readOffset += bytesToConsume;
        }

        // Token: 0x06000412 RID: 1042 RVA: 0x0004106C File Offset: 0x0002106C
        private async Task WriteHeadersAsync(HttpHeaders headers, string cookiesFromContainer)
        {
            foreach (KeyValuePair<HeaderDescriptor, string[]> header in headers.GetHeaderDescriptorsAndValues())
            {
                if (header.Key.KnownHeader != null)
                {
                    await this.WriteBytesAsync(header.Key.KnownHeader.AsciiBytesWithColonSpace).ConfigureAwait(false);
                }
                else
                {
                    await this.WriteAsciiStringAsync(header.Key.Name).ConfigureAwait(false);
                    await this.WriteTwoBytesAsync(58, 32).ConfigureAwait(false);
                }
                if (header.Value.Length != 0)
                {
                    await this.WriteStringAsync(header.Value[0]).ConfigureAwait(false);
                    if (cookiesFromContainer != null && header.Key.KnownHeader == KnownHeaders.Cookie)
                    {
                        await this.WriteTwoBytesAsync(59, 32).ConfigureAwait(false);
                        await this.WriteStringAsync(cookiesFromContainer).ConfigureAwait(false);
                        cookiesFromContainer = null;
                    }
                    if (header.Value.Length > 1)
                    {
                        HttpHeaderParser parser = header.Key.Parser;
                        string separator = ", ";
                        if (parser != null && parser.SupportsMultipleValues)
                        {
                            separator = parser.Separator;
                        }
                        for (int i = 1; i < header.Value.Length; i++)
                        {
                            await this.WriteAsciiStringAsync(separator).ConfigureAwait(false);
                            await this.WriteStringAsync(header.Value[i]).ConfigureAwait(false);
                        }
                        separator = null;
                    }
                }
                await this.WriteTwoBytesAsync(13, 10).ConfigureAwait(false);
                //header = default(KeyValuePair<HeaderDescriptor, string[]>);
            }
            IEnumerator<KeyValuePair<HeaderDescriptor, string[]>> enumerator = null;
            if (cookiesFromContainer != null)
            {
                await this.WriteAsciiStringAsync("Cookie").ConfigureAwait(false);
                await this.WriteTwoBytesAsync(58, 32).ConfigureAwait(false);
                await this.WriteStringAsync(cookiesFromContainer).ConfigureAwait(false);
                await this.WriteTwoBytesAsync(13, 10).ConfigureAwait(false);
            }
        }

        // Token: 0x06000413 RID: 1043 RVA: 0x000410C4 File Offset: 0x000210C4
        private async Task WriteHostHeaderAsync(Uri uri)
        {
            await this.WriteBytesAsync(KnownHeaders.Host.AsciiBytesWithColonSpace).ConfigureAwait(false);
            if (this._pool.HostHeaderValueBytes != null)
            {
                await this.WriteBytesAsync(this._pool.HostHeaderValueBytes).ConfigureAwait(false);
            }
            else
            {
                if (uri.HostNameType == UriHostNameType.IPv6)
                {
                    await this.WriteByteAsync(91).ConfigureAwait(false);
                    await this.WriteAsciiStringAsync(uri.IdnHost).ConfigureAwait(false);
                    await this.WriteByteAsync(93).ConfigureAwait(false);
                }
                else
                {
                    await this.WriteAsciiStringAsync(uri.IdnHost).ConfigureAwait(false);
                }
                if (!uri.IsDefaultPort)
                {
                    await this.WriteByteAsync(58).ConfigureAwait(false);
                    await this.WriteDecimalInt32Async(uri.Port).ConfigureAwait(false);
                }
            }
            await this.WriteTwoBytesAsync(13, 10).ConfigureAwait(false);
        }

        // Token: 0x06000414 RID: 1044 RVA: 0x00041114 File Offset: 0x00021114
        private Task WriteDecimalInt32Async(int value)
        {
            int num;
            if (Utf8Formatter.TryFormat(value, new Span<byte>(this._writeBuffer, this._writeOffset, this._writeBuffer.Length - this._writeOffset), out num, default(StandardFormat)))
            {
                this._writeOffset += num;
                return Task.CompletedTask;
            }
            return this.WriteAsciiStringAsync(value.ToString());
        }

        // Token: 0x06000415 RID: 1045 RVA: 0x00041178 File Offset: 0x00021178
        private Task WriteHexInt32Async(int value)
        {
            int num;
            if (Utf8Formatter.TryFormat(value, new Span<byte>(this._writeBuffer, this._writeOffset, this._writeBuffer.Length - this._writeOffset), out num, 'X'))
            {
                this._writeOffset += num;
                return Task.CompletedTask;
            }
            return this.WriteAsciiStringAsync(value.ToString("X", CultureInfo.InvariantCulture));
        }

        // Token: 0x06000416 RID: 1046 RVA: 0x000411E4 File Offset: 0x000211E4
        public async Task<HttpResponseMessage> SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            TaskCompletionSource<bool> allowExpect100ToContinue = null;
            this._currentRequest = request;
            HttpMethod normalizedMethod = HttpMethod.Normalize(request.Method);
            bool hasExpectContinueHeader = request.HasHeaders && request.Headers.ExpectContinue == true;
            this._canRetry = true;
            if (NetEventSource.IsEnabled)
            {
                this.Trace(string.Format("Sending request: {0}", request), "SendAsyncCore");
            }
            CancellationTokenRegistration cancellationRegistration = this.RegisterCancellation(cancellationToken);
            HttpResponseMessage result;
            try
            {
                await this.WriteStringAsync(normalizedMethod.Method).ConfigureAwait(false);
                await this.WriteByteAsync(32).ConfigureAwait(false);
                if (normalizedMethod == HttpMethod.Connect)
                {
                    if (!request.HasHeaders || request.Headers.Host == null)
                    {
                        throw new HttpRequestException(SR.net_http_request_no_host);
                    }
                    await this.WriteAsciiStringAsync(request.Headers.Host).ConfigureAwait(false);
                }
                else
                {
                    if (this.Kind == HttpConnectionKind.Proxy)
                    {
                        await this.WriteBytesAsync(HttpConnection.s_httpSchemeAndDelimiter).ConfigureAwait(false);
                        if (request.RequestUri.HostNameType == UriHostNameType.IPv6)
                        {
                            await this.WriteByteAsync(91).ConfigureAwait(false);
                            await this.WriteAsciiStringAsync(request.RequestUri.IdnHost).ConfigureAwait(false);
                            await this.WriteByteAsync(93).ConfigureAwait(false);
                        }
                        else
                        {
                            await this.WriteAsciiStringAsync(request.RequestUri.IdnHost).ConfigureAwait(false);
                        }
                        if (!request.RequestUri.IsDefaultPort)
                        {
                            await this.WriteByteAsync(58).ConfigureAwait(false);
                            await this.WriteDecimalInt32Async(request.RequestUri.Port).ConfigureAwait(false);
                        }
                    }
                    await this.WriteStringAsync(request.RequestUri.GetComponents(UriComponents.Path | UriComponents.Query | UriComponents.Fragment, UriFormat.UriEscaped)).ConfigureAwait(false);
                }
                await this.WriteBytesAsync((request.Version.Minor == 0 && request.Version.Major == 1) ? HttpConnection.s_spaceHttp10NewlineAsciiBytes : HttpConnection.s_spaceHttp11NewlineAsciiBytes).ConfigureAwait(false);
                string text = null;
                if (this._pool.Settings._useCookies)
                {
                    text = this._pool.Settings._cookieContainer.GetCookieHeader(request.RequestUri);
                    if (text == "")
                    {
                        text = null;
                    }
                }
                if (request.HasHeaders || text != null)
                {
                    await this.WriteHeadersAsync(request.Headers, text).ConfigureAwait(false);
                }
                if (request.Content == null)
                {
                    if (normalizedMethod != HttpMethod.Get && normalizedMethod != HttpMethod.Head && normalizedMethod != HttpMethod.Connect)
                    {
                        await this.WriteBytesAsync(HttpConnection.s_contentLength0NewlineAsciiBytes).ConfigureAwait(false);
                    }
                }
                else
                {
                    await this.WriteHeadersAsync(request.Content.Headers, null).ConfigureAwait(false);
                }
                if (!request.HasHeaders || request.Headers.Host == null)
                {
                    await this.WriteHostHeaderAsync(request.RequestUri).ConfigureAwait(false);
                }
                await this.WriteTwoBytesAsync(13, 10).ConfigureAwait(false);
                Task sendRequestContentTask = null;
                if (request.Content == null)
                {
                    await this.FlushAsync().ConfigureAwait(false);
                }
                else if (!hasExpectContinueHeader)
                {
                    await this.SendRequestContentAsync(request, this.CreateRequestContentStream(request), cancellationToken).ConfigureAwait(false);
                }
                else
                {
                    await this.FlushAsync().ConfigureAwait(false);
                    allowExpect100ToContinue = new TaskCompletionSource<bool>();
                    Timer expect100Timer = new Timer(delegate (object s)
                    {
                        ((TaskCompletionSource<bool>)s).TrySetResult(true);
                    }, allowExpect100ToContinue, this._pool.Settings._expect100ContinueTimeout, Timeout.InfiniteTimeSpan);
                    sendRequestContentTask = this.SendRequestContentWithExpect100ContinueAsync(request, allowExpect100ToContinue.Task, this.CreateRequestContentStream(request), expect100Timer, cancellationToken);
                }
                this._allowedReadLineBytes = (int)Math.Min(2147483647L, (long)this._pool.Settings._maxResponseHeadersLength * 1024L);
                ValueTask<int>? valueTask = this.ConsumeReadAheadTask();
                if (valueTask != null)
                {
                    int num = await valueTask.GetValueOrDefault().ConfigureAwait(false);
                    if (NetEventSource.IsEnabled)
                    {
                        this.Trace(string.Format("Received {0} bytes.", num), "SendAsyncCore");
                    }
                    if (num == 0)
                    {
                        throw new IOException(SR.net_http_invalid_response);
                    }
                    this._readOffset = 0;
                    this._readLength = num;
                }
                this._canRetry = false;
                HttpResponseMessage response = new HttpResponseMessage
                {
                    RequestMessage = request,
                    Content = new HttpConnection.HttpConnectionResponseContent()
                };
                HttpConnection.ParseStatusLine(await this.ReadNextResponseHeaderLineAsync(false).ConfigureAwait(false), response);
                if (hasExpectContinueHeader)
                {
                    if (response.StatusCode >= HttpStatusCode.MultipleChoices && request.Content != null && (request.Content.Headers.ContentLength == null || request.Content.Headers.ContentLength.GetValueOrDefault() > 1024L))
                    {
                        allowExpect100ToContinue.TrySetResult(false);
                        if (!allowExpect100ToContinue.Task.Result)
                        {
                            this._connectionClose = true;
                        }
                    }
                    else
                    {
                        TaskCompletionSource<bool> taskCompletionSource = allowExpect100ToContinue;
                        if (taskCompletionSource != null)
                        {
                            taskCompletionSource.TrySetResult(true);
                        }
                        if (response.StatusCode == HttpStatusCode.Continue)
                        {
                            if (!HttpConnection.LineIsEmpty(await this.ReadNextResponseHeaderLineAsync(false).ConfigureAwait(false)))
                            {
                                HttpConnection.ThrowInvalidHttpResponse();
                            }
                            HttpConnection.ParseStatusLine(await this.ReadNextResponseHeaderLineAsync(false).ConfigureAwait(false), response);
                        }
                    }
                }
                if (sendRequestContentTask != null)
                {
                    await sendRequestContentTask.ConfigureAwait(false);
                    sendRequestContentTask = null;
                }
                for (; ; )
                {
                    ArraySegment<byte> line = await this.ReadNextResponseHeaderLineAsync(true).ConfigureAwait(false);
                    if (HttpConnection.LineIsEmpty(line))
                    {
                        break;
                    }
                    HttpConnection.ParseHeaderNameValue(line, response);
                }
                if (response.Headers.ConnectionClose.GetValueOrDefault())
                {
                    this._connectionClose = true;
                }
                cancellationRegistration.Dispose();
                CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
                HttpContentStream stream;
                if (normalizedMethod == HttpMethod.Head || response.StatusCode == HttpStatusCode.NoContent || response.StatusCode == HttpStatusCode.NotModified)
                {
                    stream = HttpConnection.EmptyReadStream.Instance;
                    this.CompleteResponse();
                }
                else if (normalizedMethod == HttpMethod.Connect && response.StatusCode == HttpStatusCode.OK)
                {
                    stream = new HttpConnection.RawConnectionStream(this);
                    this._connectionClose = true;
                }
                else if (response.StatusCode == HttpStatusCode.SwitchingProtocols)
                {
                    stream = new HttpConnection.RawConnectionStream(this);
                }
                else if (response.Content.Headers.ContentLength != null)
                {
                    long valueOrDefault = response.Content.Headers.ContentLength.GetValueOrDefault();
                    if (valueOrDefault <= 0L)
                    {
                        stream = HttpConnection.EmptyReadStream.Instance;
                        this.CompleteResponse();
                    }
                    else
                    {
                        stream = new HttpConnection.ContentLengthReadStream(this, (ulong)valueOrDefault);
                    }
                }
                else if (response.Headers.TransferEncodingChunked == true)
                {
                    stream = new HttpConnection.ChunkedEncodingReadStream(this);
                }
                else
                {
                    stream = new HttpConnection.ConnectionCloseReadStream(this);
                }
                ((HttpConnection.HttpConnectionResponseContent)response.Content).SetStream(stream);
                if (NetEventSource.IsEnabled)
                {
                    this.Trace(string.Format("Received response: {0}", response), "SendAsyncCore");
                }
                if (this._pool.Settings._useCookies)
                {
                    CookieHelper.ProcessReceivedCookies(response, this._pool.Settings._cookieContainer);
                }
                result = response;
            }
            catch (Exception ex)
            {
                cancellationRegistration.Dispose();
                TaskCompletionSource<bool> taskCompletionSource2 = allowExpect100ToContinue;
                if (taskCompletionSource2 != null)
                {
                    taskCompletionSource2.TrySetResult(false);
                }
                if (NetEventSource.IsEnabled)
                {
                    this.Trace(string.Format("Error sending request: {0}", ex), "SendAsyncCore");
                }
                this.Dispose();
                if (CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken))
                {
                    throw CancellationHelper.CreateOperationCanceledException(ex, cancellationToken);
                }
                if (ex is InvalidOperationException || ex is IOException)
                {
                    throw new HttpRequestException(SR.net_http_client_execution_error, ex);
                }
                throw;
            }
            return result;
        }

        // Token: 0x06000417 RID: 1047 RVA: 0x0004123C File Offset: 0x0002123C
        public Task<HttpResponseMessage> SendWithNtProxyAuthAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            if (this._pool.AnyProxyKind && this._pool.ProxyCredentials != null)
            {
                return AuthenticationHelper.SendWithNtProxyAuthAsync(request, this._pool.ProxyUri, this._pool.ProxyCredentials, this, cancellationToken);
            }
            return this.SendAsyncCore(request, cancellationToken);
        }

        // Token: 0x06000418 RID: 1048 RVA: 0x0004128A File Offset: 0x0002128A
        public Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool doRequestAuth, CancellationToken cancellationToken)
        {
            if (doRequestAuth && this._pool.Settings._credentials != null)
            {
                return AuthenticationHelper.SendWithNtConnectionAuthAsync(request, this._pool.Settings._credentials, this, cancellationToken);
            }
            return this.SendWithNtProxyAuthAsync(request, cancellationToken);
        }

        // Token: 0x06000419 RID: 1049 RVA: 0x000412C4 File Offset: 0x000212C4
        private HttpConnection.HttpContentWriteStream CreateRequestContentStream(HttpRequestMessage request)
        {
            return (request.HasHeaders && request.Headers.TransferEncodingChunked == true) ? (HttpContentWriteStream)new HttpConnection.ChunkedEncodingWriteStream(this) : new HttpConnection.ContentLengthWriteStream(this);
        }

        // Token: 0x0600041A RID: 1050 RVA: 0x00041312 File Offset: 0x00021312
        private CancellationTokenRegistration RegisterCancellation(CancellationToken cancellationToken)
        {
            return cancellationToken.Register(delegate (object s)
            {
                WeakReference<HttpConnection> weakReference = (WeakReference<HttpConnection>)s;
                HttpConnection httpConnection;
                if (weakReference.TryGetTarget(out httpConnection))
                {
                    if (NetEventSource.IsEnabled)
                    {
                        httpConnection.Trace("Cancellation requested. Disposing of the connection.", "RegisterCancellation");
                    }
                    httpConnection.Dispose();
                }
            }, this._weakThisRef);
        }

        // Token: 0x0600041B RID: 1051 RVA: 0x00041340 File Offset: 0x00021340
        private static bool LineIsEmpty(ArraySegment<byte> line)
        {
            return line.Count == 0;
        }

        // Token: 0x0600041C RID: 1052 RVA: 0x0004134C File Offset: 0x0002134C
        private async Task SendRequestContentAsync(HttpRequestMessage request, HttpConnection.HttpContentWriteStream stream, CancellationToken cancellationToken)
        {
            this._canRetry = false;
            await request.Content.CopyToAsync(stream, this._transportContext, cancellationToken).ConfigureAwait(false);
            await stream.FinishAsync().ConfigureAwait(false);
            await this.FlushAsync().ConfigureAwait(false);
        }

        // Token: 0x0600041D RID: 1053 RVA: 0x000413AC File Offset: 0x000213AC
        private async Task SendRequestContentWithExpect100ContinueAsync(HttpRequestMessage request, Task<bool> allowExpect100ToContinueTask, HttpConnection.HttpContentWriteStream stream, Timer expect100Timer, CancellationToken cancellationToken)
        {
            bool flag = await allowExpect100ToContinueTask.ConfigureAwait(false);
            bool flag2 = flag;
            expect100Timer.Dispose();
            if (flag2)
            {
                if (NetEventSource.IsEnabled)
                {
                    this.Trace("Sending request content for Expect: 100-continue.", "SendRequestContentWithExpect100ContinueAsync");
                }
                await this.SendRequestContentAsync(request, stream, cancellationToken).ConfigureAwait(false);
            }
            else if (NetEventSource.IsEnabled)
            {
                this.Trace("Canceling request content for Expect: 100-continue.", "SendRequestContentWithExpect100ContinueAsync");
            }
        }

        // Token: 0x0600041E RID: 1054 RVA: 0x0004141B File Offset: 0x0002141B
        private static void ParseStatusLine(ArraySegment<byte> line, HttpResponseMessage response)
        {
            HttpConnection.ParseStatusLine((Span<byte>)line, response);
        }

        // Token: 0x0600041F RID: 1055 RVA: 0x0004142C File Offset: 0x0002142C
        private unsafe static void ParseStatusLine(Span<byte> line, HttpResponseMessage response)
        {
            if (line.Length < 12 || line[8] != 32)
            {
                HttpConnection.ThrowInvalidHttpResponse();
            }
            ulong num = BitConverter.ToUInt64(line);
            if (num == HttpConnection.s_http11Bytes)
            {
                response.SetVersionWithoutValidation(HttpVersion.Version11);
            }
            else if (num == HttpConnection.s_http10Bytes)
            {
                response.SetVersionWithoutValidation(HttpVersion.Version10);
            }
            else
            {
                byte b = line[7];
                if (HttpConnection.IsDigit(b) && line.Slice(0, 7).SequenceEqual(HttpConnection.s_http1DotBytes))
                {
                    response.SetVersionWithoutValidation(new Version(1, (int)(b - 48)));
                }
                else
                {
                    HttpConnection.ThrowInvalidHttpResponse();
                }
            }
            byte b2 = line[9];
            byte b3 = line[10];
            byte b4 = line[11];
            if (!HttpConnection.IsDigit(b2) || !HttpConnection.IsDigit(b3) || !HttpConnection.IsDigit(b4))
            {
                HttpConnection.ThrowInvalidHttpResponse();
            }
            response.SetStatusCodeWithoutValidation((HttpStatusCode)(100 * (b2 - 48) + 10 * (b3 - 48) + (b4 - 48)));
            if (line.Length == 12)
            {
                response.SetReasonPhraseWithoutValidation(string.Empty);
                return;
            }
            if (line[12] == 32)
            {
                Span<byte> span = line.Slice(13);
                string text = HttpStatusDescription.Get(response.StatusCode);
                if (text != null && HttpConnection.EqualsOrdinal(text, span))
                {
                    response.SetReasonPhraseWithoutValidation(text);
                    return;
                }
                try
                {
                    response.ReasonPhrase = HttpRuleParser.DefaultHttpEncoding.GetString(span);
                    return;
                }
                catch (FormatException innerException)
                {
                    HttpConnection.ThrowInvalidHttpResponse(innerException);
                    return;
                }
            }
            HttpConnection.ThrowInvalidHttpResponse();
        }

        // Token: 0x06000420 RID: 1056 RVA: 0x000415BC File Offset: 0x000215BC
        private static void ParseHeaderNameValue(ArraySegment<byte> line, HttpResponseMessage response)
        {
            HttpConnection.ParseHeaderNameValue((Span<byte>)line, response);
        }

        // Token: 0x06000421 RID: 1057 RVA: 0x000415CC File Offset: 0x000215CC
        private unsafe static void ParseHeaderNameValue(Span<byte> line, HttpResponseMessage response)
        {
            int num = 0;
            while (line[num] != 58 && line[num] != 32)
            {
                num++;
                if (num == line.Length)
                {
                    HttpConnection.ThrowInvalidHttpResponse();
                }
            }
            if (num == 0)
            {
                HttpConnection.ThrowInvalidHttpResponse();
            }
            HeaderDescriptor descriptor;
            if (!HeaderDescriptor.TryGet(line.Slice(0, num), out descriptor))
            {
                HttpConnection.ThrowInvalidHttpResponse();
            }
            while (line[num] == 32)
            {
                num++;
                if (num == line.Length)
                {
                    HttpConnection.ThrowInvalidHttpResponse();
                }
            }
            if (line[num++] != 58)
            {
                HttpConnection.ThrowInvalidHttpResponse();
            }
            while (num < line.Length && (line[num] == 32 || line[num] == 9))
            {
                num++;
            }
            string headerValue = descriptor.GetHeaderValue(line.Slice(num));
            if (descriptor.HeaderType == HttpHeaderType.Content)
            {
                response.Content.Headers.TryAddWithoutValidation(descriptor, headerValue);
                return;
            }
            response.Headers.TryAddWithoutValidation(descriptor, headerValue);
        }

        // Token: 0x06000422 RID: 1058 RVA: 0x000416D1 File Offset: 0x000216D1
        private static bool IsDigit(byte c)
        {
            return c - 48 <= 9;
        }

        // Token: 0x06000423 RID: 1059 RVA: 0x000416E0 File Offset: 0x000216E0
        private void WriteToBuffer(ReadOnlyMemory<byte> source)
        {
            source.Span.CopyTo(new Span<byte>(this._writeBuffer, this._writeOffset, source.Length));
            this._writeOffset += source.Length;
        }

        // Token: 0x06000424 RID: 1060 RVA: 0x00041728 File Offset: 0x00021728
        private async Task WriteAsync(ReadOnlyMemory<byte> source)
        {
            int num = this._writeBuffer.Length - this._writeOffset;
            if (source.Length <= num)
            {
                this.WriteToBuffer(source);
            }
            else
            {
                if (this._writeOffset != 0)
                {
                    this.WriteToBuffer(source.Slice(0, num));
                    source = source.Slice(num);
                    await this.FlushAsync().ConfigureAwait(false);
                }
                if (source.Length >= this._writeBuffer.Length)
                {
                    await this.WriteToStreamAsync(source).ConfigureAwait(false);
                }
                else
                {
                    this.WriteToBuffer(source);
                }
            }
        }

        // Token: 0x06000425 RID: 1061 RVA: 0x00041778 File Offset: 0x00021778
        private ValueTask WriteWithoutBufferingAsync(ReadOnlyMemory<byte> source)
        {
            if (this._writeOffset == 0)
            {
                return this.WriteToStreamAsync(source);
            }
            int num = this._writeBuffer.Length - this._writeOffset;
            if (source.Length <= num)
            {
                this.WriteToBuffer(source);
                return this.FlushAsync();
            }
            return new ValueTask(this.FlushThenWriteWithoutBufferingAsync(source));
        }

        // Token: 0x06000426 RID: 1062 RVA: 0x000417CC File Offset: 0x000217CC
        private async Task FlushThenWriteWithoutBufferingAsync(ReadOnlyMemory<byte> source)
        {
            await this.FlushAsync().ConfigureAwait(false);
            await this.WriteToStreamAsync(source).ConfigureAwait(false);
        }

        // Token: 0x06000427 RID: 1063 RVA: 0x0004181C File Offset: 0x0002181C
        private Task WriteByteAsync(byte b)
        {
            if (this._writeOffset < this._writeBuffer.Length)
            {
                byte[] writeBuffer = this._writeBuffer;
                int writeOffset = this._writeOffset;
                this._writeOffset = writeOffset + 1;
                writeBuffer[writeOffset] = b;
                return Task.CompletedTask;
            }
            return this.WriteByteSlowAsync(b);
        }

        // Token: 0x06000428 RID: 1064 RVA: 0x00041860 File Offset: 0x00021860
        private async Task WriteByteSlowAsync(byte b)
        {
            await this.WriteToStreamAsync(this._writeBuffer).ConfigureAwait(false);
            this._writeBuffer[0] = b;
            this._writeOffset = 1;
        }

        // Token: 0x06000429 RID: 1065 RVA: 0x000418B0 File Offset: 0x000218B0
        private Task WriteTwoBytesAsync(byte b1, byte b2)
        {
            if (this._writeOffset <= this._writeBuffer.Length - 2)
            {
                byte[] writeBuffer = this._writeBuffer;
                byte[] array = writeBuffer;
                int writeOffset = this._writeOffset;
                this._writeOffset = writeOffset + 1;
                array[writeOffset] = b1;
                byte[] array2 = writeBuffer;
                writeOffset = this._writeOffset;
                this._writeOffset = writeOffset + 1;
                array2[writeOffset] = b2;
                return Task.CompletedTask;
            }
            return this.WriteTwoBytesSlowAsync(b1, b2);
        }

        // Token: 0x0600042A RID: 1066 RVA: 0x0004190C File Offset: 0x0002190C
        private async Task WriteTwoBytesSlowAsync(byte b1, byte b2)
        {
            await this.WriteByteAsync(b1).ConfigureAwait(false);
            await this.WriteByteAsync(b2).ConfigureAwait(false);
        }

        // Token: 0x0600042B RID: 1067 RVA: 0x00041964 File Offset: 0x00021964
        private Task WriteBytesAsync(byte[] bytes)
        {
            if (this._writeOffset <= this._writeBuffer.Length - bytes.Length)
            {
                Buffer.BlockCopy(bytes, 0, this._writeBuffer, this._writeOffset, bytes.Length);
                this._writeOffset += bytes.Length;
                return Task.CompletedTask;
            }
            return this.WriteBytesSlowAsync(bytes);
        }

        // Token: 0x0600042C RID: 1068 RVA: 0x000419B8 File Offset: 0x000219B8
        private async Task WriteBytesSlowAsync(byte[] bytes)
        {
            int offset = 0;
            for (; ; )
            {
                int val = bytes.Length - offset;
                int num = Math.Min(val, this._writeBuffer.Length - this._writeOffset);
                Buffer.BlockCopy(bytes, offset, this._writeBuffer, this._writeOffset, num);
                this._writeOffset += num;
                offset += num;
                if (offset == bytes.Length)
                {
                    break;
                }
                if (this._writeOffset == this._writeBuffer.Length)
                {
                    await this.WriteToStreamAsync(this._writeBuffer).ConfigureAwait(false);
                    this._writeOffset = 0;
                }
            }
        }

        // Token: 0x0600042D RID: 1069 RVA: 0x00041A08 File Offset: 0x00021A08
        private Task WriteStringAsync(string s)
        {
            int writeOffset = this._writeOffset;
            if (s.Length <= this._writeBuffer.Length - writeOffset)
            {
                byte[] writeBuffer = this._writeBuffer;
                foreach (char c in s)
                {
                    if ((c & 'ﾀ') != '\0')
                    {
                        throw new HttpRequestException(SR.net_http_request_invalid_char_encoding);
                    }
                    writeBuffer[writeOffset++] = (byte)c;
                }
                this._writeOffset = writeOffset;
                return Task.CompletedTask;
            }
            return this.WriteStringAsyncSlow(s);
        }

        // Token: 0x0600042E RID: 1070 RVA: 0x00041A84 File Offset: 0x00021A84
        private Task WriteAsciiStringAsync(string s)
        {
            int writeOffset = this._writeOffset;
            if (s.Length <= this._writeBuffer.Length - writeOffset)
            {
                byte[] writeBuffer = this._writeBuffer;
                foreach (char c in s)
                {
                    writeBuffer[writeOffset++] = (byte)c;
                }
                this._writeOffset = writeOffset;
                return Task.CompletedTask;
            }
            return this.WriteStringAsyncSlow(s);
        }

        // Token: 0x0600042F RID: 1071 RVA: 0x00041AEC File Offset: 0x00021AEC
        private async Task WriteStringAsyncSlow(string s)
        {
            foreach (char c in s)
            {
                if ((c & 'ﾀ') != '\0')
                {
                    throw new HttpRequestException(SR.net_http_request_invalid_char_encoding);
                }
                await this.WriteByteAsync((byte)c).ConfigureAwait(false);
            }
        }

        // Token: 0x06000430 RID: 1072 RVA: 0x00041B3C File Offset: 0x00021B3C
        private ValueTask FlushAsync()
        {
            if (this._writeOffset > 0)
            {
                ValueTask result = this.WriteToStreamAsync(new ReadOnlyMemory<byte>(this._writeBuffer, 0, this._writeOffset));
                this._writeOffset = 0;
                return result;
            }
            return default(ValueTask);
        }

        // Token: 0x06000431 RID: 1073 RVA: 0x00041B80 File Offset: 0x00021B80
        private ValueTask WriteToStreamAsync(ReadOnlyMemory<byte> source)
        {
            if (NetEventSource.IsEnabled)
            {
                this.Trace(string.Format("Writing {0} bytes.", source.Length), "WriteToStreamAsync");
            }
            return this._stream.WriteAsync(source, default(CancellationToken));
        }

        // Token: 0x06000432 RID: 1074 RVA: 0x00041BCC File Offset: 0x00021BCC
        private unsafe bool TryReadNextLine(out ReadOnlySpan<byte> line)
        {
            ReadOnlySpan<byte> span = new ReadOnlySpan<byte>(this._readBuffer, this._readOffset, this._readLength - this._readOffset);
            int num = span.IndexOf((byte)10);
            if (num < 0)
            {
                if (this._allowedReadLineBytes < span.Length)
                {
                    HttpConnection.ThrowInvalidHttpResponse();
                }
                line = default(ReadOnlySpan<byte>);
                return false;
            }
            int num2 = num + 1;
            this._readOffset += num2;
            this._allowedReadLineBytes -= num2;
            this.ThrowIfExceededAllowedReadLineBytes();
            line = span.Slice(0, (num > 0 && span[num - 1] == 13) ? (num - 1) : num);
            return true;
        }

        // Token: 0x06000433 RID: 1075 RVA: 0x00041C74 File Offset: 0x00021C74
        private async ValueTask<ArraySegment<byte>> ReadNextResponseHeaderLineAsync(bool foldedHeadersAllowed = false)
        {
            int previouslyScannedBytes = 0;
            int num;
            int num2;
            int readOffset;
            int num3;
            for (; ; )
            {
                num = this._readOffset + previouslyScannedBytes;
                num2 = Array.IndexOf<byte>(this._readBuffer, 10, num, this._readLength - num);
                if (num2 >= 0)
                {
                    readOffset = this._readOffset;
                    num3 = num2 - readOffset;
                    if (num2 > 0 && this._readBuffer[num2 - 1] == 13)
                    {
                        num3--;
                    }
                    if (!foldedHeadersAllowed || num3 <= 0)
                    {
                        break;
                    }
                    if (num2 + 1 == this._readLength)
                    {
                        int num4 = (this._readBuffer[num2 - 1] == 13) ? (num2 - 2) : (num2 - 1);
                        previouslyScannedBytes = num4 - this._readOffset;
                        this._allowedReadLineBytes -= num4 - num;
                        this.ThrowIfExceededAllowedReadLineBytes();
                        await this.FillAsync().ConfigureAwait(false);
                    }
                    else
                    {
                        char c = (char)this._readBuffer[num2 + 1];
                        if (c != ' ' && c != '\t')
                        {
                            break;
                        }
                        if (Array.IndexOf<byte>(this._readBuffer, 58, this._readOffset, num2 - this._readOffset) == -1)
                        {
                            HttpConnection.ThrowInvalidHttpResponse();
                        }
                        this._readBuffer[num2] = 32;
                        if (this._readBuffer[num2 - 1] == 13)
                        {
                            this._readBuffer[num2 - 1] = 32;
                        }
                        previouslyScannedBytes = num2 + 1 - this._readOffset;
                        this._allowedReadLineBytes -= num2 + 1 - num;
                        this.ThrowIfExceededAllowedReadLineBytes();
                    }
                }
                else
                {
                    previouslyScannedBytes = this._readLength - this._readOffset;
                    this._allowedReadLineBytes -= this._readLength - num;
                    this.ThrowIfExceededAllowedReadLineBytes();
                    await this.FillAsync().ConfigureAwait(false);
                }
            }
            this._allowedReadLineBytes -= num2 + 1 - num;
            this.ThrowIfExceededAllowedReadLineBytes();
            this._readOffset = num2 + 1;
            return new ArraySegment<byte>(this._readBuffer, readOffset, num3);
        }

        // Token: 0x06000434 RID: 1076 RVA: 0x00041CC1 File Offset: 0x00021CC1
        private void ThrowIfExceededAllowedReadLineBytes()
        {
            if (this._allowedReadLineBytes < 0)
            {
                HttpConnection.ThrowInvalidHttpResponse();
            }
        }

        // Token: 0x06000435 RID: 1077 RVA: 0x00041CD4 File Offset: 0x00021CD4
        private async Task FillAsync()
        {
            int num = this._readLength - this._readOffset;
            if (num == 0)
            {
                this._readOffset = (this._readLength = 0);
            }
            else if (this._readOffset > 0)
            {
                Buffer.BlockCopy(this._readBuffer, this._readOffset, this._readBuffer, 0, num);
                this._readOffset = 0;
                this._readLength = num;
            }
            else if (num == this._readBuffer.Length)
            {
                byte[] array = new byte[this._readBuffer.Length * 2];
                Buffer.BlockCopy(this._readBuffer, 0, array, 0, num);
                this._readBuffer = array;
                this._readOffset = 0;
                this._readLength = num;
            }
            int num2 = await this._stream.ReadAsync(new Memory<byte>(this._readBuffer, this._readLength, this._readBuffer.Length - this._readLength), default(CancellationToken)).ConfigureAwait(false);
            int num3 = num2;
            if (NetEventSource.IsEnabled)
            {
                this.Trace(string.Format("Received {0} bytes.", num3), "FillAsync");
            }
            if (num3 == 0)
            {
                throw new IOException(SR.net_http_invalid_response);
            }
            this._readLength += num3;
        }

        // Token: 0x06000436 RID: 1078 RVA: 0x00041D1C File Offset: 0x00021D1C
        private void ReadFromBuffer(Span<byte> buffer)
        {
            new Span<byte>(this._readBuffer, this._readOffset, buffer.Length).CopyTo(buffer);
            this._readOffset += buffer.Length;
        }

        // Token: 0x06000437 RID: 1079 RVA: 0x00041D60 File Offset: 0x00021D60
        private async ValueTask<int> ReadAsync(Memory<byte> destination)
        {
            int num = this._readLength - this._readOffset;
            int result;
            if (num > 0)
            {
                if (destination.Length <= num)
                {
                    this.ReadFromBuffer(destination.Span);
                    result = destination.Length;
                }
                else
                {
                    this.ReadFromBuffer(destination.Span.Slice(0, num));
                    result = num;
                }
            }
            else
            {
                int num2 = await this._stream.ReadAsync(destination, default(CancellationToken)).ConfigureAwait(false);
                int num3 = num2;
                if (NetEventSource.IsEnabled)
                {
                    this.Trace(string.Format("Received {0} bytes.", num3), "ReadAsync");
                }
                result = num3;
            }
            return result;
        }

        // Token: 0x06000438 RID: 1080 RVA: 0x00041DAD File Offset: 0x00021DAD
        private ValueTask<int> ReadBufferedAsync(Memory<byte> destination)
        {
            if (destination.Length < this._readBuffer.Length)
            {
                return this.ReadBufferedAsyncCore(destination);
            }
            return this.ReadAsync(destination);
        }

        // Token: 0x06000439 RID: 1081 RVA: 0x00041DD0 File Offset: 0x00021DD0
        private async ValueTask<int> ReadBufferedAsyncCore(Memory<byte> destination)
        {
            int num = this._readLength - this._readOffset;
            int result;
            if (num > 0)
            {
                if (destination.Length <= num)
                {
                    this.ReadFromBuffer(destination.Span);
                    result = destination.Length;
                }
                else
                {
                    this.ReadFromBuffer(destination.Span.Slice(0, num));
                    result = num;
                }
            }
            else
            {
                this._readOffset = (this._readLength = 0);
                int num2 = await this._stream.ReadAsync(this._readBuffer.AsMemory<byte>(), default(CancellationToken)).ConfigureAwait(false);
                int num3 = num2;
                if (NetEventSource.IsEnabled)
                {
                    this.Trace(string.Format("Received {0} bytes.", num3), "ReadBufferedAsyncCore");
                }
                this._readLength = num3;
                int num4 = Math.Min(num3, destination.Length);
                this._readBuffer.AsSpan(0, num4).CopyTo(destination.Span);
                this._readOffset = num4;
                result = num4;
            }
            return result;
        }

        // Token: 0x0600043A RID: 1082 RVA: 0x00041E20 File Offset: 0x00021E20
        private async Task CopyFromBufferAsync(Stream destination, int count, CancellationToken cancellationToken)
        {
            if (NetEventSource.IsEnabled)
            {
                this.Trace(string.Format("Copying {0} bytes to stream.", count), "CopyFromBufferAsync");
            }
            await destination.WriteAsync(new ReadOnlyMemory<byte>(this._readBuffer, this._readOffset, count), cancellationToken).ConfigureAwait(false);
            this._readOffset += count;
        }

        // Token: 0x0600043B RID: 1083 RVA: 0x00041E80 File Offset: 0x00021E80
        private Task CopyToUntilEofAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
        {
            int num = this._readLength - this._readOffset;
            if (num <= 0)
            {
                return this._stream.CopyToAsync(destination, bufferSize, cancellationToken);
            }
            return this.CopyToUntilEofWithExistingBufferedDataAsync(destination, cancellationToken);
        }

        // Token: 0x0600043C RID: 1084 RVA: 0x00041EB8 File Offset: 0x00021EB8
        private async Task CopyToUntilEofWithExistingBufferedDataAsync(Stream destination, CancellationToken cancellationToken)
        {
            int count = this._readLength - this._readOffset;
            await this.CopyFromBufferAsync(destination, count, cancellationToken).ConfigureAwait(false);
            int num = 0;
            this._readOffset = num;
            this._readLength = num;
            await this._stream.CopyToAsync(destination).ConfigureAwait(false);
        }

        // Token: 0x0600043D RID: 1085 RVA: 0x00041F10 File Offset: 0x00021F10
        private async Task CopyToExactLengthAsync(Stream destination, ulong length, CancellationToken cancellationToken)
        {
            int remaining = this._readLength - this._readOffset;
            if (remaining > 0)
            {
                if ((long)remaining > (long)length)
                {
                    remaining = (int)length;
                }
                await this.CopyFromBufferAsync(destination, remaining, cancellationToken).ConfigureAwait(false);
                length -= (ulong)((long)remaining);
                if (length == 0UL)
                {
                    return;
                }
            }
            do
            {
                await this.FillAsync().ConfigureAwait(false);
                remaining = (((long)this._readLength < (long)length) ? this._readLength : ((int)length));
                await this.CopyFromBufferAsync(destination, remaining, cancellationToken).ConfigureAwait(false);
                length -= (ulong)((long)remaining);
            }
            while (length != 0UL);
        }

        // Token: 0x0600043E RID: 1086 RVA: 0x00041F6D File Offset: 0x00021F6D
        public void Acquire()
        {
            this._inUse = true;
        }

        // Token: 0x0600043F RID: 1087 RVA: 0x00041F76 File Offset: 0x00021F76
        public void Release()
        {
            this._inUse = false;
            if (this._currentRequest == null)
            {
                this.ReturnConnectionToPool();
            }
        }

        // Token: 0x06000440 RID: 1088 RVA: 0x00041F90 File Offset: 0x00021F90
        private void CompleteResponse()
        {
            this._currentRequest = null;
            if (this.RemainingBuffer.Length != 0)
            {
                if (NetEventSource.IsEnabled)
                {
                    this.Trace("Unexpected data on connection after response read.", "CompleteResponse");
                }
                this.ConsumeFromRemainingBuffer(this.RemainingBuffer.Length);
                this._connectionClose = true;
            }
            if (!this._inUse)
            {
                this.ReturnConnectionToPool();
            }
        }

        // Token: 0x06000441 RID: 1089 RVA: 0x00041FF4 File Offset: 0x00021FF4
        public async Task DrainResponseAsync(HttpResponseMessage response)
        {
            if (this._connectionClose)
            {
                throw new HttpRequestException(SR.net_http_authconnectionfailure);
            }
            Stream stream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false);
            HttpConnection.HttpContentReadStream httpContentReadStream = (HttpConnection.HttpContentReadStream)stream;
            if (httpContentReadStream.NeedsDrain && (!(await httpContentReadStream.DrainAsync(this._pool.Settings._maxResponseDrainSize).ConfigureAwait(false)) || this._connectionClose))
            {
                throw new HttpRequestException(SR.net_http_authconnectionfailure);
            }
            response.Dispose();
        }

        // Token: 0x06000442 RID: 1090 RVA: 0x00042041 File Offset: 0x00022041
        private void ReturnConnectionToPool()
        {
            if (this._connectionClose)
            {
                if (NetEventSource.IsEnabled)
                {
                    this.Trace("Connection will not be reused.", "ReturnConnectionToPool");
                }
                this.Dispose();
                return;
            }
            this._pool.ReturnConnection(this);
        }

        // Token: 0x06000443 RID: 1091 RVA: 0x00042078 File Offset: 0x00022078
        private unsafe static bool EqualsOrdinal(string left, Span<byte> right)
        {
            if (left.Length != right.Length)
            {
                return false;
            }
            for (int i = 0; i < left.Length; i++)
            {
                if (left[i] != (char)(right[i]))
                {
                    return false;
                }
            }
            return true;
        }

        // Token: 0x06000444 RID: 1092 RVA: 0x000420BC File Offset: 0x000220BC
        public sealed override string ToString()
        {
            return string.Format("{0}({1})", "HttpConnection", this._pool);
        }

        // Token: 0x06000445 RID: 1093 RVA: 0x000420D3 File Offset: 0x000220D3
        private static void ThrowInvalidHttpResponse()
        {
            throw new HttpRequestException(SR.net_http_invalid_response);
        }

        // Token: 0x06000446 RID: 1094 RVA: 0x000420DF File Offset: 0x000220DF
        private static void ThrowInvalidHttpResponse(Exception innerException)
        {
            throw new HttpRequestException(SR.net_http_invalid_response, innerException);
        }

        // Token: 0x06000447 RID: 1095 RVA: 0x000420EC File Offset: 0x000220EC
        internal void Trace(string message, [CallerMemberName] string memberName = null)
        {
            /*NetEventSource log = NetEventSource.Log;
            HttpConnectionPool pool = this._pool;
            int handlerId = (pool != null) ? pool.GetHashCode() : 0;
            int hashCode = this.GetHashCode();
            HttpRequestMessage currentRequest = this._currentRequest;
            log.HandlerMessage(handlerId, hashCode, (currentRequest != null) ? currentRequest.GetHashCode() : 0, memberName, this.ToString() + ": " + message);
            */
        }

        // Token: 0x040002B9 RID: 697
        private static readonly byte[] s_contentLength0NewlineAsciiBytes = Encoding.ASCII.GetBytes("Content-Length: 0\r\n");

        // Token: 0x040002BA RID: 698
        private static readonly byte[] s_spaceHttp10NewlineAsciiBytes = Encoding.ASCII.GetBytes(" HTTP/1.0\r\n");

        // Token: 0x040002BB RID: 699
        private static readonly byte[] s_spaceHttp11NewlineAsciiBytes = Encoding.ASCII.GetBytes(" HTTP/1.1\r\n");

        // Token: 0x040002BC RID: 700
        private static readonly byte[] s_httpSchemeAndDelimiter = Encoding.ASCII.GetBytes(Uri.UriSchemeHttp + Uri.SchemeDelimiter);

        // Token: 0x040002BD RID: 701
        private static readonly byte[] s_http1DotBytes = Encoding.ASCII.GetBytes("HTTP/1.");

        // Token: 0x040002BE RID: 702
        private static readonly ulong s_http10Bytes = BitConverter.ToUInt64(Encoding.ASCII.GetBytes("HTTP/1.0"));

        // Token: 0x040002BF RID: 703
        private static readonly ulong s_http11Bytes = BitConverter.ToUInt64(Encoding.ASCII.GetBytes("HTTP/1.1"));

        // Token: 0x040002C0 RID: 704
        private readonly HttpConnectionPool _pool;

        // Token: 0x040002C1 RID: 705
        private readonly Socket _socket;

        // Token: 0x040002C2 RID: 706
        private readonly Stream _stream;

        // Token: 0x040002C3 RID: 707
        private readonly TransportContext _transportContext;

        // Token: 0x040002C4 RID: 708
        private readonly WeakReference<HttpConnection> _weakThisRef;

        // Token: 0x040002C5 RID: 709
        private HttpRequestMessage _currentRequest;

        // Token: 0x040002C6 RID: 710
        private readonly byte[] _writeBuffer;

        // Token: 0x040002C7 RID: 711
        private int _writeOffset;

        // Token: 0x040002C8 RID: 712
        private int _allowedReadLineBytes;

        // Token: 0x040002C9 RID: 713
        private ValueTask<int>? _readAheadTask;

        // Token: 0x040002CA RID: 714
        private int _readAheadTaskLock;

        // Token: 0x040002CB RID: 715
        private byte[] _readBuffer;

        // Token: 0x040002CC RID: 716
        private int _readOffset;

        // Token: 0x040002CD RID: 717
        private int _readLength;

        // Token: 0x040002CE RID: 718
        private bool _inUse;

        // Token: 0x040002CF RID: 719
        private bool _canRetry;

        // Token: 0x040002D0 RID: 720
        private bool _connectionClose;

        // Token: 0x040002D1 RID: 721
        private int _disposed;

        // Token: 0x020000A7 RID: 167
        private sealed class ChunkedEncodingReadStream : HttpConnection.HttpContentReadStream
        {
            // Token: 0x06000449 RID: 1097 RVA: 0x000421F7 File Offset: 0x000221F7
            public ChunkedEncodingReadStream(HttpConnection connection) : base(connection)
            {
            }

            // Token: 0x0600044A RID: 1098 RVA: 0x00042200 File Offset: 0x00022200
            public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    return new ValueTask<int>(Task.FromCanceled<int>(cancellationToken));
                }
                if (this._connection == null || buffer.Length == 0)
                {
                    return new ValueTask<int>(0);
                }
                int num = this.ReadChunksFromConnectionBuffer(buffer.Span, default(CancellationTokenRegistration));
                if (num > 0)
                {
                    return new ValueTask<int>(num);
                }
                if (this._connection == null)
                {
                    return new ValueTask<int>(0);
                }
                return this.ReadAsyncCore(buffer, cancellationToken);
            }

            // Token: 0x0600044B RID: 1099 RVA: 0x00042274 File Offset: 0x00022274
            private async ValueTask<int> ReadAsyncCore(Memory<byte> buffer, CancellationToken cancellationToken)
            {
                int result;
                using (CancellationTokenRegistration ctr = this._connection.RegisterCancellation(cancellationToken))
                {
                    try
                    {
                        while (this._connection != null)
                        {
                            if (this._state == HttpConnection.ChunkedEncodingReadStream.ParsingState.ExpectChunkData && buffer.Length >= this._connection.ReadBufferSize && this._chunkBytesRemaining >= (ulong)((long)this._connection.ReadBufferSize))
                            {
                                int num = await this._connection.ReadAsync(buffer.Slice(0, (int)Math.Min((ulong)((long)buffer.Length), this._chunkBytesRemaining))).ConfigureAwait(false);
                                int num2 = num;
                                if (num2 == 0)
                                {
                                    throw new IOException(SR.net_http_invalid_response);
                                }
                                this._chunkBytesRemaining -= (ulong)((long)num2);
                                if (this._chunkBytesRemaining == 0UL)
                                {
                                    this._state = HttpConnection.ChunkedEncodingReadStream.ParsingState.ExpectChunkTerminator;
                                }
                                return num2;
                            }
                            else
                            {
                                await this._connection.FillAsync().ConfigureAwait(false);
                                int num3 = this.ReadChunksFromConnectionBuffer(buffer.Span, ctr);
                                if (num3 > 0)
                                {
                                    return num3;
                                }
                            }
                        }
                        result = 0;
                    }
                    catch (Exception ex) when (CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken))
                    {
                        throw CancellationHelper.CreateOperationCanceledException(ex, cancellationToken);
                    }
                }
                return result;
            }

            // Token: 0x0600044C RID: 1100 RVA: 0x000422C9 File Offset: 0x000222C9
            public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
            {
                HttpContentStream.ValidateCopyToArgs(this, destination, bufferSize);
                if (cancellationToken.IsCancellationRequested)
                {
                    return Task.FromCanceled(cancellationToken);
                }
                if (this._connection != null)
                {
                    return this.CopyToAsyncCore(destination, cancellationToken);
                }
                return Task.CompletedTask;
            }

            // Token: 0x0600044D RID: 1101 RVA: 0x000422FC File Offset: 0x000222FC
            private async Task CopyToAsyncCore(Stream destination, CancellationToken cancellationToken)
            {
                using (CancellationTokenRegistration ctr = this._connection.RegisterCancellation(cancellationToken))
                {
                    try
                    {
                        for (; ; )
                        {
                            ReadOnlyMemory<byte> buffer = this.ReadChunkFromConnectionBuffer(int.MaxValue, ctr);
                            if (buffer.Length != 0)
                            {
                                await destination.WriteAsync(buffer, cancellationToken).ConfigureAwait(false);
                            }
                            else
                            {
                                if (this._connection == null)
                                {
                                    break;
                                }
                                await this._connection.FillAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    catch (Exception ex) when (CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken))
                    {
                        throw CancellationHelper.CreateOperationCanceledException(ex, cancellationToken);
                    }
                }
            }

            // Token: 0x0600044E RID: 1102 RVA: 0x00042354 File Offset: 0x00022354
            private int ReadChunksFromConnectionBuffer(Span<byte> buffer, CancellationTokenRegistration cancellationRegistration)
            {
                int num = 0;
                while (buffer.Length > 0)
                {
                    ReadOnlyMemory<byte> readOnlyMemory = this.ReadChunkFromConnectionBuffer(buffer.Length, cancellationRegistration);
                    if (readOnlyMemory.Length == 0)
                    {
                        break;
                    }
                    num += readOnlyMemory.Length;
                    readOnlyMemory.Span.CopyTo(buffer);
                    buffer = buffer.Slice(readOnlyMemory.Length);
                }
                return num;
            }

            private const int MaxChunkBytesAllowed = 16 * 1024;
            private const int MaxTrailingHeaderLength = 16 * 1024;

            // Token: 0x0600044F RID: 1103 RVA: 0x000423B4 File Offset: 0x000223B4
            private ReadOnlyMemory<byte> ReadChunkFromConnectionBuffer(int maxBytesToRead, CancellationTokenRegistration cancellationRegistration)
            {
                Debug.Assert(maxBytesToRead > 0);

                try
                {
                    ReadOnlySpan<byte> currentLine;
                    switch (_state)
                    {
                        case ParsingState.ExpectChunkHeader:
                            Debug.Assert(_chunkBytesRemaining == 0, $"Expected {nameof(_chunkBytesRemaining)} == 0, got {_chunkBytesRemaining}");

                            // Read the chunk header line.
                            _connection._allowedReadLineBytes = MaxChunkBytesAllowed;
                            if (!_connection.TryReadNextLine(out currentLine))
                            {
                                // Could not get a whole line, so we can't parse the chunk header.
                                return default;
                            }

                            // Parse the hex value from it.
                            if (!Utf8Parser.TryParse(currentLine, out ulong chunkSize, out int bytesConsumed, 'X'))
                            {
                                throw new IOException(SR.net_http_invalid_response);
                            }
                            _chunkBytesRemaining = chunkSize;

                            // If there's a chunk extension after the chunk size, validate it.
                            if (bytesConsumed != currentLine.Length)
                            {
                                ValidateChunkExtension(currentLine.Slice(bytesConsumed));
                            }

                            // Proceed to handle the chunk.  If there's data in it, go read it.
                            // Otherwise, finish handling the response.
                            if (chunkSize > 0)
                            {
                                _state = ParsingState.ExpectChunkData;
                                goto case ParsingState.ExpectChunkData;
                            }
                            else
                            {
                                _state = ParsingState.ConsumeTrailers;
                                goto case ParsingState.ConsumeTrailers;
                            }

                        case ParsingState.ExpectChunkData:
                            Debug.Assert(_chunkBytesRemaining > 0);

                            ReadOnlyMemory<byte> connectionBuffer = _connection.RemainingBuffer;
                            if (connectionBuffer.Length == 0)
                            {
                                return default;
                            }

                            int bytesToConsume = Math.Min(maxBytesToRead, (int)Math.Min((ulong)connectionBuffer.Length, _chunkBytesRemaining));
                            Debug.Assert(bytesToConsume > 0);

                            _connection.ConsumeFromRemainingBuffer(bytesToConsume);
                            _chunkBytesRemaining -= (ulong)bytesToConsume;
                            if (_chunkBytesRemaining == 0)
                            {
                                _state = ParsingState.ExpectChunkTerminator;
                            }

                            return connectionBuffer.Slice(0, bytesToConsume);

                        case ParsingState.ExpectChunkTerminator:
                            Debug.Assert(_chunkBytesRemaining == 0, $"Expected {nameof(_chunkBytesRemaining)} == 0, got {_chunkBytesRemaining}");

                            _connection._allowedReadLineBytes = MaxChunkBytesAllowed;
                            if (!_connection.TryReadNextLine(out currentLine))
                            {
                                return default;
                            }

                            if (currentLine.Length != 0)
                            {
                                ThrowInvalidHttpResponse();
                            }

                            _state = ParsingState.ExpectChunkHeader;
                            goto case ParsingState.ExpectChunkHeader;

                        case ParsingState.ConsumeTrailers:
                            Debug.Assert(_chunkBytesRemaining == 0, $"Expected {nameof(_chunkBytesRemaining)} == 0, got {_chunkBytesRemaining}");

                            while (true)
                            {
                                _connection._allowedReadLineBytes = MaxTrailingHeaderLength;
                                if (!_connection.TryReadNextLine(out currentLine))
                                {
                                    break;
                                }

                                if (currentLine.IsEmpty)
                                {
                                    // Dispose of the registration and then check whether cancellation has been
                                    // requested. This is necessary to make determinstic a race condition between
                                    // cancellation being requested and unregistering from the token.  Otherwise,
                                    // it's possible cancellation could be requested just before we unregister and
                                    // we then return a connection to the pool that has been or will be disposed
                                    // (e.g. if a timer is used and has already queued its callback but the
                                    // callback hasn't yet run).
                                    cancellationRegistration.Dispose();
                                    CancellationHelper.ThrowIfCancellationRequested(cancellationRegistration.Token);

                                    _state = ParsingState.Done;
                                    _connection.CompleteResponse();
                                    _connection = null;
                                    break;
                                }
                            }

                            return default;

                        default:
                        case ParsingState.Done: // shouldn't be called once we're done
                            Debug.Fail($"Unexpected state: {_state}");
                            if (NetEventSource.IsEnabled)
                            {
                                NetEventSource.Error(this, $"Unexpected state: {_state}");
                            }

                            return default;
                    }
                }
                catch (Exception)
                {
                    // Ensure we don't try to read from the connection again (in particular, for draining)
                    _connection.Dispose();
                    _connection = null;
                    throw;
                }
            }

            // Token: 0x06000450 RID: 1104 RVA: 0x00042608 File Offset: 0x00022608
            private unsafe static void ValidateChunkExtension(ReadOnlySpan<byte> lineAfterChunkSize)
            {
                for (int i = 0; i < lineAfterChunkSize.Length; i++)
                {
                    byte b = lineAfterChunkSize[i];
                    if (b == 59)
                    {
                        break;
                    }
                    if (b != 32 && b != 9)
                    {
                        throw new IOException(SR.net_http_invalid_response);
                    }
                }
            }

            // Token: 0x170000E7 RID: 231
            // (get) Token: 0x06000451 RID: 1105 RVA: 0x0004264B File Offset: 0x0002264B
            public override bool NeedsDrain
            {
                get
                {
                    return this._connection != null;
                }
            }

            // Token: 0x06000452 RID: 1106 RVA: 0x00042658 File Offset: 0x00022658
            public override async Task<bool> DrainAsync(int maxDrainBytes)
            {
                CancellationTokenSource cts = null;
                CancellationTokenRegistration ctr = default(CancellationTokenRegistration);
                bool result;
                try
                {
                    int drainedBytes = 0;
                    for (; ; )
                    {
                        drainedBytes += this._connection.RemainingBuffer.Length;
                        while (this.ReadChunkFromConnectionBuffer(2147483647, ctr).Length != 0)
                        {
                        }
                        if (this._connection == null)
                        {
                            break;
                        }
                        if (drainedBytes >= maxDrainBytes)
                        {
                            goto Block_5;
                        }
                        if (cts == null)
                        {
                            TimeSpan maxResponseDrainTime = this._connection._pool.Settings._maxResponseDrainTime;
                            if (maxResponseDrainTime != Timeout.InfiniteTimeSpan)
                            {
                                cts = new CancellationTokenSource((int)maxResponseDrainTime.TotalMilliseconds);
                                ctr = cts.Token.Register(delegate (object s)
                                {
                                    ((HttpConnection)s).Dispose();
                                }, this._connection);
                            }
                        }
                        await this._connection.FillAsync().ConfigureAwait(false);
                    }
                    return true;
                    Block_5:
                    result = false;
                }
                finally
                {
                    ctr.Dispose();
                    CancellationTokenSource cancellationTokenSource = cts;
                    if (cancellationTokenSource != null)
                    {
                        cancellationTokenSource.Dispose();
                    }
                }
                return result;
            }

            // Token: 0x040002D3 RID: 723
            private ulong _chunkBytesRemaining;

            // Token: 0x040002D4 RID: 724
            private HttpConnection.ChunkedEncodingReadStream.ParsingState _state;

            // Token: 0x020000A8 RID: 168
            private enum ParsingState : byte
            {
                // Token: 0x040002D6 RID: 726
                ExpectChunkHeader,
                // Token: 0x040002D7 RID: 727
                ExpectChunkData,
                // Token: 0x040002D8 RID: 728
                ExpectChunkTerminator,
                // Token: 0x040002D9 RID: 729
                ConsumeTrailers,
                // Token: 0x040002DA RID: 730
                Done
            }
        }

        // Token: 0x020000AD RID: 173
        private sealed class ChunkedEncodingWriteStream : HttpConnection.HttpContentWriteStream
        {
            // Token: 0x0600045C RID: 1116 RVA: 0x00042DB6 File Offset: 0x00022DB6
            public ChunkedEncodingWriteStream(HttpConnection connection) : base(connection)
            {
            }

            // Token: 0x0600045D RID: 1117 RVA: 0x00042DC0 File Offset: 0x00022DC0
            public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken ignored)
            {
                return (buffer.Length == 0) ? this._connection.FlushAsync() : new ValueTask(this.WriteChunkAsync(buffer));
            }

            // Token: 0x0600045E RID: 1118 RVA: 0x00042DF4 File Offset: 0x00022DF4
            private async Task WriteChunkAsync(ReadOnlyMemory<byte> buffer)
            {
                await this._connection.WriteHexInt32Async(buffer.Length).ConfigureAwait(false);
                await this._connection.WriteTwoBytesAsync(13, 10).ConfigureAwait(false);
                await this._connection.WriteAsync(buffer).ConfigureAwait(false);
                await this._connection.WriteTwoBytesAsync(13, 10).ConfigureAwait(false);
            }

            // Token: 0x0600045F RID: 1119 RVA: 0x00042E44 File Offset: 0x00022E44
            public override async Task FinishAsync()
            {
                await this._connection.WriteBytesAsync(HttpConnection.ChunkedEncodingWriteStream.s_finalChunkBytes).ConfigureAwait(false);
                this._connection = null;
            }

            // Token: 0x040002F5 RID: 757
            private static readonly byte[] s_finalChunkBytes = new byte[]
            {
                48,
                13,
                10,
                13,
                10
            };
        }

        // Token: 0x020000B0 RID: 176
        private sealed class ConnectionCloseReadStream : HttpConnection.HttpContentReadStream
        {
            // Token: 0x06000465 RID: 1125 RVA: 0x000421F7 File Offset: 0x000221F7
            public ConnectionCloseReadStream(HttpConnection connection) : base(connection)
            {
            }

            // Token: 0x06000466 RID: 1126 RVA: 0x000431D4 File Offset: 0x000231D4
            public override async ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken)
            {
                CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
                int result;
                if (this._connection == null || buffer.Length == 0)
                {
                    result = 0;
                }
                else
                {
                    ValueTask<int> valueTask = this._connection.ReadAsync(buffer);
                    int num;
                    if (valueTask.IsCompletedSuccessfully)
                    {
                        num = valueTask.Result;
                    }
                    else
                    {
                        using (this._connection.RegisterCancellation(cancellationToken))
                        {
                            try
                            {
                                int num2 = await valueTask.ConfigureAwait(false);
                                num = num2;
                            }
                            catch (Exception ex) when (CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken))
                            {
                                throw CancellationHelper.CreateOperationCanceledException(ex, cancellationToken);
                            }
                        }
                        CancellationTokenRegistration ctr = default(CancellationTokenRegistration);
                    }
                    if (num == 0)
                    {
                        CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
                        this._connection.Dispose();
                        this._connection = null;
                        result = 0;
                    }
                    else
                    {
                        result = num;
                    }
                }
                return result;
            }

            // Token: 0x06000467 RID: 1127 RVA: 0x0004322C File Offset: 0x0002322C
            public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
            {
                HttpContentStream.ValidateCopyToArgs(this, destination, bufferSize);
                if (cancellationToken.IsCancellationRequested)
                {
                    return Task.FromCanceled(cancellationToken);
                }
                if (this._connection == null)
                {
                    return Task.CompletedTask;
                }
                Task task = this._connection.CopyToUntilEofAsync(destination, bufferSize, cancellationToken);
                if (task.IsCompletedSuccessfully)
                {
                    this.Finish();
                    return Task.CompletedTask;
                }
                return this.CompleteCopyToAsync(task, cancellationToken);
            }

            // Token: 0x06000468 RID: 1128 RVA: 0x0004328C File Offset: 0x0002328C
            private async Task CompleteCopyToAsync(Task copyTask, CancellationToken cancellationToken)
            {
                using (this._connection.RegisterCancellation(cancellationToken))
                {
                    try
                    {
                        await copyTask.ConfigureAwait(false);
                    }
                    catch (Exception ex) when (CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken))
                    {
                        throw CancellationHelper.CreateOperationCanceledException(ex, cancellationToken);
                    }
                }
                CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
                this.Finish();
            }

            // Token: 0x06000469 RID: 1129 RVA: 0x000432E1 File Offset: 0x000232E1
            private void Finish()
            {
                this._connection.Dispose();
                this._connection = null;
            }
        }

        // Token: 0x020000B3 RID: 179
        private sealed class ContentLengthReadStream : HttpConnection.HttpContentReadStream
        {
            // Token: 0x0600046E RID: 1134 RVA: 0x00043646 File Offset: 0x00023646
            public ContentLengthReadStream(HttpConnection connection, ulong contentLength) : base(connection)
            {
                this._contentBytesRemaining = contentLength;
            }

            // Token: 0x0600046F RID: 1135 RVA: 0x00043658 File Offset: 0x00023658
            public override async ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken)
            {
                CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
                int result;
                if (this._connection == null || buffer.Length == 0)
                {
                    result = 0;
                }
                else
                {
                    if ((long)buffer.Length > (long)this._contentBytesRemaining)
                    {
                        buffer = buffer.Slice(0, (int)this._contentBytesRemaining);
                    }
                    ValueTask<int> valueTask = this._connection.ReadAsync(buffer);
                    int num;
                    if (valueTask.IsCompletedSuccessfully)
                    {
                        num = valueTask.Result;
                    }
                    else
                    {
                        using (this._connection.RegisterCancellation(cancellationToken))
                        {
                            try
                            {
                                int num2 = await valueTask.ConfigureAwait(false);
                                num = num2;
                            }
                            catch (Exception ex) when (CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken))
                            {
                                throw CancellationHelper.CreateOperationCanceledException(ex, cancellationToken);
                            }
                        }
                        CancellationTokenRegistration ctr = default(CancellationTokenRegistration);
                    }
                    if (num <= 0)
                    {
                        CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
                        throw new IOException(SR.net_http_invalid_response);
                    }
                    this._contentBytesRemaining -= (ulong)((long)num);
                    if (this._contentBytesRemaining == 0UL)
                    {
                        this._connection.CompleteResponse();
                        this._connection = null;
                    }
                    result = num;
                }
                return result;
            }

            // Token: 0x06000470 RID: 1136 RVA: 0x000436B0 File Offset: 0x000236B0
            public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
            {
                HttpContentStream.ValidateCopyToArgs(this, destination, bufferSize);
                if (cancellationToken.IsCancellationRequested)
                {
                    return Task.FromCanceled(cancellationToken);
                }
                if (this._connection == null)
                {
                    return Task.CompletedTask;
                }
                Task task = this._connection.CopyToExactLengthAsync(destination, this._contentBytesRemaining, cancellationToken);
                if (task.IsCompletedSuccessfully)
                {
                    this.Finish();
                    return Task.CompletedTask;
                }
                return this.CompleteCopyToAsync(task, cancellationToken);
            }

            // Token: 0x06000471 RID: 1137 RVA: 0x00043714 File Offset: 0x00023714
            private async Task CompleteCopyToAsync(Task copyTask, CancellationToken cancellationToken)
            {
                using (this._connection.RegisterCancellation(cancellationToken))
                {
                    try
                    {
                        await copyTask.ConfigureAwait(false);
                    }
                    catch (Exception ex) when (CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken))
                    {
                        throw CancellationHelper.CreateOperationCanceledException(ex, cancellationToken);
                    }
                }
                this.Finish();
            }

            // Token: 0x06000472 RID: 1138 RVA: 0x00043769 File Offset: 0x00023769
            private void Finish()
            {
                this._contentBytesRemaining = 0UL;
                this._connection.CompleteResponse();
                this._connection = null;
            }

            // Token: 0x06000473 RID: 1139 RVA: 0x00043788 File Offset: 0x00023788
            private ReadOnlyMemory<byte> ReadFromConnectionBuffer(int maxBytesToRead)
            {
                ReadOnlyMemory<byte> remainingBuffer = this._connection.RemainingBuffer;
                if (remainingBuffer.Length == 0)
                {
                    return default(ReadOnlyMemory<byte>);
                }
                int num = Math.Min(maxBytesToRead, (int)Math.Min((ulong)((long)remainingBuffer.Length), this._contentBytesRemaining));
                this._connection.ConsumeFromRemainingBuffer(num);
                this._contentBytesRemaining -= (ulong)((long)num);
                return remainingBuffer.Slice(0, num);
            }

            // Token: 0x170000E8 RID: 232
            // (get) Token: 0x06000474 RID: 1140 RVA: 0x0004264B File Offset: 0x0002264B
            public override bool NeedsDrain
            {
                get
                {
                    return this._connection != null;
                }
            }

            // Token: 0x06000475 RID: 1141 RVA: 0x000437F4 File Offset: 0x000237F4
            public override async Task<bool> DrainAsync(int maxDrainBytes)
            {
                this.ReadFromConnectionBuffer(int.MaxValue);
                bool result;
                if (this._contentBytesRemaining == 0UL)
                {
                    this.Finish();
                    result = true;
                }
                else if (this._contentBytesRemaining > (ulong)((long)maxDrainBytes))
                {
                    result = false;
                }
                else
                {
                    CancellationTokenSource cts = null;
                    CancellationTokenRegistration ctr = default(CancellationTokenRegistration);
                    TimeSpan maxResponseDrainTime = this._connection._pool.Settings._maxResponseDrainTime;
                    if (maxResponseDrainTime != Timeout.InfiniteTimeSpan)
                    {
                        cts = new CancellationTokenSource((int)maxResponseDrainTime.TotalMilliseconds);
                        ctr = cts.Token.Register(delegate (object s)
                        {
                            ((HttpConnection)s).Dispose();
                        }, this._connection);
                    }
                    try
                    {
                        do
                        {
                            await this._connection.FillAsync().ConfigureAwait(false);
                            this.ReadFromConnectionBuffer(int.MaxValue);
                        }
                        while (this._contentBytesRemaining != 0UL);
                        ctr.Dispose();
                        CancellationHelper.ThrowIfCancellationRequested(ctr.Token);
                        this.Finish();
                        result = true;
                    }
                    finally
                    {
                        ctr.Dispose();
                        CancellationTokenSource cancellationTokenSource = cts;
                        if (cancellationTokenSource != null)
                        {
                            cancellationTokenSource.Dispose();
                        }
                    }
                }
                return result;
            }

            // Token: 0x0400030D RID: 781
            private ulong _contentBytesRemaining;
        }

        // Token: 0x020000B8 RID: 184
        private sealed class ContentLengthWriteStream : HttpConnection.HttpContentWriteStream
        {
            // Token: 0x0600047F RID: 1151 RVA: 0x00042DB6 File Offset: 0x00022DB6
            public ContentLengthWriteStream(HttpConnection connection) : base(connection)
            {
            }

            // Token: 0x06000480 RID: 1152 RVA: 0x00043E02 File Offset: 0x00023E02
            public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken ignored)
            {
                return new ValueTask(this._connection.WriteAsync(buffer));
            }

            // Token: 0x06000481 RID: 1153 RVA: 0x00043E15 File Offset: 0x00023E15
            public override Task FinishAsync()
            {
                this._connection = null;
                return Task.CompletedTask;
            }
        }

        // Token: 0x020000B9 RID: 185
        private sealed class EmptyReadStream : HttpConnection.HttpContentReadStream
        {
            // Token: 0x170000E9 RID: 233
            // (get) Token: 0x06000482 RID: 1154 RVA: 0x00043E23 File Offset: 0x00023E23
            internal static HttpConnection.EmptyReadStream Instance { get; } = new HttpConnection.EmptyReadStream();

            // Token: 0x06000483 RID: 1155 RVA: 0x00043E2A File Offset: 0x00023E2A
            private EmptyReadStream() : base(null)
            {
            }

            // Token: 0x06000484 RID: 1156 RVA: 0x00034ED8 File Offset: 0x00014ED8
            protected override void Dispose(bool disposing)
            {
            }

            // Token: 0x06000485 RID: 1157 RVA: 0x00034ED8 File Offset: 0x00014ED8
            public override void Close()
            {
            }

            // Token: 0x06000486 RID: 1158 RVA: 0x00043E33 File Offset: 0x00023E33
            public override int ReadByte()
            {
                return -1;
            }

            // Token: 0x06000487 RID: 1159 RVA: 0x000356C2 File Offset: 0x000156C2
            public override int Read(Span<byte> buffer)
            {
                return 0;
            }

            // Token: 0x06000488 RID: 1160 RVA: 0x00043E36 File Offset: 0x00023E36
            public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken)
            {
                if (!cancellationToken.IsCancellationRequested)
                {
                    return new ValueTask<int>(0);
                }
                return new ValueTask<int>(Task.FromCanceled<int>(cancellationToken));
            }

            // Token: 0x04000325 RID: 805
            private static readonly Task<int> s_zeroTask = Task.FromResult<int>(0);
        }

        // Token: 0x020000BA RID: 186
        private sealed class HttpConnectionResponseContent : HttpContent
        {
            // Token: 0x0600048A RID: 1162 RVA: 0x00043E6A File Offset: 0x00023E6A
            public void SetStream(HttpContentStream stream)
            {
                this._stream = stream;
            }

            // Token: 0x0600048B RID: 1163 RVA: 0x00043E73 File Offset: 0x00023E73
            private HttpContentStream ConsumeStream()
            {
                if (this._consumedStream || this._stream == null)
                {
                    throw new InvalidOperationException(SR.net_http_content_stream_already_read);
                }
                this._consumedStream = true;
                return this._stream;
            }

            // Token: 0x0600048C RID: 1164 RVA: 0x00043E9D File Offset: 0x00023E9D
            protected sealed override Task SerializeToStreamAsync(Stream stream, TransportContext context)
            {
                return this.SerializeToStreamAsync(stream, context, CancellationToken.None);
            }

            // Token: 0x0600048D RID: 1165 RVA: 0x00043EAC File Offset: 0x00023EAC
            internal sealed override async Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken)
            {
                using (HttpContentStream contentStream = this.ConsumeStream())
                {
                    await contentStream.CopyToAsync(stream, 8192, cancellationToken).ConfigureAwait(false);
                }
                //HttpContentStream contentStream = null;
            }

            // Token: 0x0600048E RID: 1166 RVA: 0x00043F01 File Offset: 0x00023F01
            protected internal sealed override bool TryComputeLength(out long length)
            {
                length = 0L;
                return false;
            }

            // Token: 0x0600048F RID: 1167 RVA: 0x00043F08 File Offset: 0x00023F08
            protected sealed override Task<Stream> CreateContentReadStreamAsync()
            {
                return Task.FromResult<Stream>(this.ConsumeStream());
            }

            // Token: 0x06000490 RID: 1168 RVA: 0x00043F15 File Offset: 0x00023F15
            internal sealed override Stream TryCreateContentReadStream()
            {
                return this.ConsumeStream();
            }

            // Token: 0x06000491 RID: 1169 RVA: 0x00043F1D File Offset: 0x00023F1D
            protected sealed override void Dispose(bool disposing)
            {
                if (disposing && this._stream != null)
                {
                    this._stream.Dispose();
                    this._stream = null;
                }
                base.Dispose(disposing);
            }

            // Token: 0x04000327 RID: 807
            private HttpContentStream _stream;

            // Token: 0x04000328 RID: 808
            private bool _consumedStream;
        }

        // Token: 0x020000BC RID: 188
        internal abstract class HttpContentReadStream : HttpContentStream
        {
            // Token: 0x06000495 RID: 1173 RVA: 0x0004406A File Offset: 0x0002406A
            public HttpContentReadStream(HttpConnection connection) : base(connection)
            {
            }

            // Token: 0x170000EA RID: 234
            // (get) Token: 0x06000496 RID: 1174 RVA: 0x0003607C File Offset: 0x0001607C
            public sealed override bool CanRead
            {
                get
                {
                    return true;
                }
            }

            // Token: 0x170000EB RID: 235
            // (get) Token: 0x06000497 RID: 1175 RVA: 0x000356C2 File Offset: 0x000156C2
            public sealed override bool CanWrite
            {
                get
                {
                    return false;
                }
            }

            // Token: 0x06000498 RID: 1176 RVA: 0x00034ED8 File Offset: 0x00014ED8
            public sealed override void Flush()
            {
            }

            // Token: 0x06000499 RID: 1177 RVA: 0x00044073 File Offset: 0x00024073
            public sealed override Task FlushAsync(CancellationToken cancellationToken)
            {
                if (!cancellationToken.IsCancellationRequested)
                {
                    return Task.CompletedTask;
                }
                return Task.FromCanceled(cancellationToken);
            }

            // Token: 0x0600049A RID: 1178 RVA: 0x00036351 File Offset: 0x00016351
            public sealed override void WriteByte(byte value)
            {
                throw new NotSupportedException();
            }

            // Token: 0x0600049B RID: 1179 RVA: 0x00036351 File Offset: 0x00016351
            public sealed override void Write(byte[] buffer, int offset, int count)
            {
                throw new NotSupportedException();
            }

            // Token: 0x0600049C RID: 1180 RVA: 0x00036351 File Offset: 0x00016351
            public sealed override void Write(ReadOnlySpan<byte> source)
            {
                throw new NotSupportedException();
            }

            // Token: 0x0600049D RID: 1181 RVA: 0x00036351 File Offset: 0x00016351
            public sealed override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
            {
                throw new NotSupportedException();
            }

            // Token: 0x0600049E RID: 1182 RVA: 0x0004408C File Offset: 0x0002408C
            public sealed override ValueTask WriteAsync(ReadOnlyMemory<byte> destination, CancellationToken cancellationToken)
            {
                throw new NotSupportedException();
            }

            // Token: 0x0600049F RID: 1183 RVA: 0x000440A0 File Offset: 0x000240A0
            public sealed override int Read(byte[] buffer, int offset, int count)
            {
                HttpContentStream.ValidateBufferArgs(buffer, offset, count);
                return this.ReadAsync(new Memory<byte>(buffer, offset, count), CancellationToken.None).GetAwaiter().GetResult();
            }

            // Token: 0x060004A0 RID: 1184 RVA: 0x000440D8 File Offset: 0x000240D8
            public sealed override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
            {
                HttpContentStream.ValidateBufferArgs(buffer, offset, count);
                return this.ReadAsync(new Memory<byte>(buffer, offset, count), cancellationToken).AsTask();
            }

            // Token: 0x060004A1 RID: 1185 RVA: 0x00044108 File Offset: 0x00024108
            public sealed override void CopyTo(Stream destination, int bufferSize)
            {
                this.CopyToAsync(destination, bufferSize, CancellationToken.None).GetAwaiter().GetResult();
            }

            // Token: 0x170000EC RID: 236
            // (get) Token: 0x060004A2 RID: 1186 RVA: 0x000356C2 File Offset: 0x000156C2
            public virtual bool NeedsDrain
            {
                get
                {
                    return false;
                }
            }

            // Token: 0x060004A3 RID: 1187 RVA: 0x0004412F File Offset: 0x0002412F
            public virtual Task<bool> DrainAsync(int maxDrainBytes)
            {
                return Task.FromResult<bool>(false);
            }

            // Token: 0x060004A4 RID: 1188 RVA: 0x00044137 File Offset: 0x00024137
            protected override void Dispose(bool disposing)
            {
                if (Interlocked.Exchange(ref this._disposed, 1) != 0)
                {
                    return;
                }
                if (disposing && this.NeedsDrain)
                {
                    this.DrainOnDisposeAsync();
                    return;
                }
                base.Dispose(disposing);
            }

            // Token: 0x060004A5 RID: 1189 RVA: 0x00044164 File Offset: 0x00024164
            private async void DrainOnDisposeAsync()
            {
                HttpConnection connection = this._connection;
                try
                {
                    bool flag = await this.DrainAsync(connection._pool.Settings._maxResponseDrainSize).ConfigureAwait(false);
                    bool flag2 = flag;
                    if (NetEventSource.IsEnabled)
                    {
                        connection.Trace(flag2 ? "Connection drain succeeded" : string.Format("Connection drain failed because MaxResponseDrainSize of {0} bytes was exceeded", connection._pool.Settings._maxResponseDrainSize), "DrainOnDisposeAsync");
                    }
                }
                catch (Exception arg)
                {
                    if (NetEventSource.IsEnabled)
                    {
                        connection.Trace(string.Format("Connection drain failed due to exception: {0}", arg), "DrainOnDisposeAsync");
                    }
                }
                base.Dispose(true);
            }

            // Token: 0x04000330 RID: 816
            private int _disposed;
        }

        // Token: 0x020000BE RID: 190
        private abstract class HttpContentWriteStream : HttpContentStream
        {
            // Token: 0x060004A9 RID: 1193 RVA: 0x0004406A File Offset: 0x0002406A
            public HttpContentWriteStream(HttpConnection connection) : base(connection)
            {
            }

            // Token: 0x170000ED RID: 237
            // (get) Token: 0x060004AA RID: 1194 RVA: 0x000356C2 File Offset: 0x000156C2
            public sealed override bool CanRead
            {
                get
                {
                    return false;
                }
            }

            // Token: 0x170000EE RID: 238
            // (get) Token: 0x060004AB RID: 1195 RVA: 0x0003607C File Offset: 0x0001607C
            public sealed override bool CanWrite
            {
                get
                {
                    return true;
                }
            }

            // Token: 0x060004AC RID: 1196 RVA: 0x00044340 File Offset: 0x00024340
            public sealed override void Flush()
            {
                base.FlushAsync().GetAwaiter().GetResult();
            }

            // Token: 0x060004AD RID: 1197 RVA: 0x00036351 File Offset: 0x00016351
            public sealed override int Read(byte[] buffer, int offset, int count)
            {
                throw new NotSupportedException();
            }

            // Token: 0x060004AE RID: 1198 RVA: 0x00044360 File Offset: 0x00024360
            public sealed override void Write(byte[] buffer, int offset, int count)
            {
                this.WriteAsync(buffer, offset, count, CancellationToken.None).GetAwaiter().GetResult();
            }

            // Token: 0x060004AF RID: 1199 RVA: 0x00044388 File Offset: 0x00024388
            public sealed override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken ignored)
            {
                HttpContentStream.ValidateBufferArgs(buffer, offset, count);
                return this.WriteAsync(new ReadOnlyMemory<byte>(buffer, offset, count), ignored).AsTask();
            }

            // Token: 0x060004B0 RID: 1200 RVA: 0x000443B8 File Offset: 0x000243B8
            public sealed override Task FlushAsync(CancellationToken ignored)
            {
                return this._connection.FlushAsync().AsTask();
            }

            // Token: 0x060004B1 RID: 1201
            public abstract Task FinishAsync();
        }

        // Token: 0x020000BF RID: 191
        private sealed class RawConnectionStream : HttpContentDuplexStream
        {
            // Token: 0x060004B2 RID: 1202 RVA: 0x000443D8 File Offset: 0x000243D8
            public RawConnectionStream(HttpConnection connection) : base(connection)
            {
            }

            // Token: 0x060004B3 RID: 1203 RVA: 0x000443E4 File Offset: 0x000243E4
            public override async ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken)
            {
                CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
                int result;
                if (this._connection == null || buffer.Length == 0)
                {
                    result = 0;
                }
                else
                {
                    ValueTask<int> valueTask = this._connection.ReadBufferedAsync(buffer);
                    int num;
                    if (valueTask.IsCompletedSuccessfully)
                    {
                        num = valueTask.Result;
                    }
                    else
                    {
                        using (this._connection.RegisterCancellation(cancellationToken))
                        {
                            try
                            {
                                int num2 = await valueTask.ConfigureAwait(false);
                                num = num2;
                            }
                            catch (Exception ex) when (CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken))
                            {
                                throw CancellationHelper.CreateOperationCanceledException(ex, cancellationToken);
                            }
                        }
                        CancellationTokenRegistration ctr = default(CancellationTokenRegistration);
                    }
                    if (num == 0)
                    {
                        CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
                        this._connection.Dispose();
                        this._connection = null;
                        result = 0;
                    }
                    else
                    {
                        result = num;
                    }
                }
                return result;
            }

            // Token: 0x060004B4 RID: 1204 RVA: 0x0004443C File Offset: 0x0002443C
            public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
            {
                HttpContentStream.ValidateCopyToArgs(this, destination, bufferSize);
                if (cancellationToken.IsCancellationRequested)
                {
                    return Task.FromCanceled(cancellationToken);
                }
                if (this._connection == null)
                {
                    return Task.CompletedTask;
                }
                Task task = this._connection.CopyToUntilEofAsync(destination, bufferSize, cancellationToken);
                if (task.IsCompletedSuccessfully)
                {
                    this.Finish();
                    return Task.CompletedTask;
                }
                return this.CompleteCopyToAsync(task, cancellationToken);
            }

            // Token: 0x060004B5 RID: 1205 RVA: 0x0004449C File Offset: 0x0002449C
            private async Task CompleteCopyToAsync(Task copyTask, CancellationToken cancellationToken)
            {
                using (this._connection.RegisterCancellation(cancellationToken))
                {
                    try
                    {
                        await copyTask.ConfigureAwait(false);
                    }
                    catch (Exception ex) when (CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken))
                    {
                        throw CancellationHelper.CreateOperationCanceledException(ex, cancellationToken);
                    }
                }
                CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
                this.Finish();
            }

            // Token: 0x060004B6 RID: 1206 RVA: 0x000432E1 File Offset: 0x000232E1
            private void Finish()
            {
                this._connection.Dispose();
                this._connection = null;
            }

            // Token: 0x060004B7 RID: 1207 RVA: 0x000444F4 File Offset: 0x000244F4
            public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    return new ValueTask(Task.FromCanceled(cancellationToken));
                }
                if (this._connection == null)
                {
                    return new ValueTask(Task.FromException(new IOException(SR.net_http_io_write)));
                }
                if (buffer.Length == 0)
                {
                    return default(ValueTask);
                }
                ValueTask valueTask = this._connection.WriteWithoutBufferingAsync(buffer);
                if (!valueTask.IsCompleted)
                {
                    return new ValueTask(this.WaitWithConnectionCancellationAsync(valueTask, cancellationToken));
                }
                return valueTask;
            }

            // Token: 0x060004B8 RID: 1208 RVA: 0x0004456C File Offset: 0x0002456C
            public override Task FlushAsync(CancellationToken cancellationToken)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    return Task.FromCanceled(cancellationToken);
                }
                if (this._connection == null)
                {
                    return Task.CompletedTask;
                }
                ValueTask task = this._connection.FlushAsync();
                if (!task.IsCompleted)
                {
                    return this.WaitWithConnectionCancellationAsync(task, cancellationToken);
                }
                return task.AsTask();
            }

            // Token: 0x060004B9 RID: 1209 RVA: 0x000445BC File Offset: 0x000245BC
            private async Task WaitWithConnectionCancellationAsync(ValueTask task, CancellationToken cancellationToken)
            {
                using (this._connection.RegisterCancellation(cancellationToken))
                {
                    try
                    {
                        await task.ConfigureAwait(false);
                    }
                    catch (Exception ex) when (CancellationHelper.ShouldWrapInOperationCanceledException(ex, cancellationToken))
                    {
                        throw CancellationHelper.CreateOperationCanceledException(ex, cancellationToken);
                    }
                }
            }
        }
    }


    // Token: 0x020000E9 RID: 233
    internal sealed class HttpConnectionHandler : HttpMessageHandler
    {
        // Token: 0x06000521 RID: 1313 RVA: 0x000495E8 File Offset: 0x000295E8
        public HttpConnectionHandler(HttpConnectionPoolManager poolManager)
        {
            this._poolManager = poolManager;
        }

        // Token: 0x06000522 RID: 1314 RVA: 0x000495F7 File Offset: 0x000295F7
        protected internal override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            return this._poolManager.SendAsync(request, false, cancellationToken);
        }

        // Token: 0x06000523 RID: 1315 RVA: 0x00049607 File Offset: 0x00029607
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                this._poolManager.Dispose();
            }
            base.Dispose(disposing);
        }

        // Token: 0x04000405 RID: 1029
        private readonly HttpConnectionPoolManager _poolManager;
    }


    // Token: 0x020000EA RID: 234
    internal enum HttpConnectionKind : byte
    {
        // Token: 0x04000407 RID: 1031
        Http,
        // Token: 0x04000408 RID: 1032
        Https,
        // Token: 0x04000409 RID: 1033
        Proxy,
        // Token: 0x0400040A RID: 1034
        ProxyTunnel,
        // Token: 0x0400040B RID: 1035
        SslProxyTunnel,
        // Token: 0x0400040C RID: 1036
        ProxyConnect
    }


    // Token: 0x020000EB RID: 235
    internal sealed class HttpConnectionPool : IDisposable
    {
        // Token: 0x06000524 RID: 1316 RVA: 0x00049620 File Offset: 0x00029620
        public HttpConnectionPool(HttpConnectionPoolManager poolManager, HttpConnectionKind kind, string host, int port, string sslHostName, Uri proxyUri, int maxConnections)
        {
            this._poolManager = poolManager;
            this._kind = kind;
            this._host = host;
            this._port = port;
            this._proxyUri = proxyUri;
            this._maxConnections = maxConnections;
            switch (kind)
            {
                case HttpConnectionKind.Https:
                    this._sslOptions = HttpConnectionPool.ConstructSslOptions(poolManager, sslHostName);
                    break;
                case HttpConnectionKind.SslProxyTunnel:
                    this._sslOptions = HttpConnectionPool.ConstructSslOptions(poolManager, sslHostName);
                    break;
            }
            if (this._host != null)
            {
                string s = (this._port != ((this._sslOptions == null) ? 80 : 443)) ? string.Format("{0}:{1}", this._host, this._port) : this._host;
                this._hostHeaderValueBytes = Encoding.ASCII.GetBytes(s);
            }
            if (this._poolManager.Settings._preAuthenticate)
            {
                this.PreAuthCredentials = new CredentialCache();
            }
        }

        // Token: 0x06000525 RID: 1317 RVA: 0x00049724 File Offset: 0x00029724
        private static SslClientAuthenticationOptions ConstructSslOptions(HttpConnectionPoolManager poolManager, string sslHostName)
        {
            SslClientAuthenticationOptions sslOptions = poolManager.Settings._sslOptions;
            SslClientAuthenticationOptions sslClientAuthenticationOptions = ((sslOptions != null) ? sslOptions._ShallowClone() : null) ?? new SslClientAuthenticationOptions();
            sslClientAuthenticationOptions.ApplicationProtocols = null;
            sslClientAuthenticationOptions.TargetHost = sslHostName;
            if (HttpConnectionPool.s_isWindows7Or2008R2 && sslClientAuthenticationOptions.EnabledSslProtocols == SslProtocols.None)
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Info(poolManager, FormattableStringFactory.Create("Win7OrWin2K8R2 platform, Changing default TLS protocols to {0}", new object[]
                    {
                        SslProtocols.Tls | SslProtocols.Tls11 | SslProtocols.Tls12
                    }), "ConstructSslOptions");
                }
                sslClientAuthenticationOptions.EnabledSslProtocols = (SslProtocols.Tls | SslProtocols.Tls11 | SslProtocols.Tls12);
            }
            return sslClientAuthenticationOptions;
        }

        // Token: 0x170000F3 RID: 243
        // (get) Token: 0x06000526 RID: 1318 RVA: 0x000497AA File Offset: 0x000297AA
        public HttpConnectionSettings Settings
        {
            get
            {
                return this._poolManager.Settings;
            }
        }

        // Token: 0x170000F4 RID: 244
        // (get) Token: 0x06000527 RID: 1319 RVA: 0x000497B7 File Offset: 0x000297B7
        public bool IsSecure
        {
            get
            {
                return this._sslOptions != null;
            }
        }

        // Token: 0x170000F5 RID: 245
        // (get) Token: 0x06000528 RID: 1320 RVA: 0x000497C2 File Offset: 0x000297C2
        public HttpConnectionKind Kind
        {
            get
            {
                return this._kind;
            }
        }

        // Token: 0x170000F6 RID: 246
        // (get) Token: 0x06000529 RID: 1321 RVA: 0x000497CA File Offset: 0x000297CA
        public bool AnyProxyKind
        {
            get
            {
                return this._proxyUri != null;
            }
        }

        // Token: 0x170000F7 RID: 247
        // (get) Token: 0x0600052A RID: 1322 RVA: 0x000497D8 File Offset: 0x000297D8
        public Uri ProxyUri
        {
            get
            {
                return this._proxyUri;
            }
        }

        // Token: 0x170000F8 RID: 248
        // (get) Token: 0x0600052B RID: 1323 RVA: 0x000497E0 File Offset: 0x000297E0
        public ICredentials ProxyCredentials
        {
            get
            {
                return this._poolManager.ProxyCredentials;
            }
        }

        // Token: 0x170000F9 RID: 249
        // (get) Token: 0x0600052C RID: 1324 RVA: 0x000497ED File Offset: 0x000297ED
        public byte[] HostHeaderValueBytes
        {
            get
            {
                return this._hostHeaderValueBytes;
            }
        }

        // Token: 0x170000FA RID: 250
        // (get) Token: 0x0600052D RID: 1325 RVA: 0x000497F5 File Offset: 0x000297F5
        public CredentialCache PreAuthCredentials { get; }

        // Token: 0x170000FB RID: 251
        // (get) Token: 0x0600052E RID: 1326 RVA: 0x000497FD File Offset: 0x000297FD
        private object SyncObj
        {
            get
            {
                return this._idleConnections;
            }
        }

        // Token: 0x0600052F RID: 1327 RVA: 0x00049808 File Offset: 0x00029808
        private ValueTask<ValueTuple<HttpConnection, HttpResponseMessage>> GetConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return new ValueTask<ValueTuple<HttpConnection, HttpResponseMessage>>(Task.FromCanceled<ValueTuple<HttpConnection, HttpResponseMessage>>(cancellationToken));
            }
            TimeSpan pooledConnectionLifetime = this._poolManager.Settings._pooledConnectionLifetime;
            TimeSpan pooledConnectionIdleTimeout = this._poolManager.Settings._pooledConnectionIdleTimeout;
            DateTimeOffset utcNow = DateTimeOffset.UtcNow;
            List<HttpConnectionPool.CachedConnection> idleConnections = this._idleConnections;
            object syncObj = this.SyncObj;
            ValueTask<ValueTuple<HttpConnection, HttpResponseMessage>> result;
            lock (syncObj)
            {
                while (idleConnections.Count > 0)
                {
                    HttpConnectionPool.CachedConnection cachedConnection = idleConnections[idleConnections.Count - 1];
                    HttpConnection connection = cachedConnection._connection;
                    idleConnections.RemoveAt(idleConnections.Count - 1);
                    if (cachedConnection.IsUsable(utcNow, pooledConnectionLifetime, pooledConnectionIdleTimeout, false) && !connection.EnsureReadAheadAndPollRead())
                    {
                        if (NetEventSource.IsEnabled)
                        {
                            connection.Trace("Found usable connection in pool.", "GetConnectionAsync");
                        }
                        return new ValueTask<ValueTuple<HttpConnection, HttpResponseMessage>>(new ValueTuple<HttpConnection, HttpResponseMessage>(connection, null));
                    }
                    if (NetEventSource.IsEnabled)
                    {
                        connection.Trace("Found invalid connection in pool.", "GetConnectionAsync");
                    }
                    connection.Dispose();
                }
                if (this._associatedConnectionCount < this._maxConnections)
                {
                    if (NetEventSource.IsEnabled)
                    {
                        this.Trace("Creating new connection for pool.", "GetConnectionAsync");
                    }
                    this.IncrementConnectionCountNoLock();
                    result = this.WaitForCreatedConnectionAsync(this.CreateConnectionAsync(request, cancellationToken));
                }
                else
                {
                    if (NetEventSource.IsEnabled)
                    {
                        this.Trace("Limit reached.  Waiting to create new connection.", "GetConnectionAsync");
                    }
                    HttpConnectionPool.ConnectionWaiter connectionWaiter = new HttpConnectionPool.ConnectionWaiter(this, request, cancellationToken);
                    this.EnqueueWaiter(connectionWaiter);
                    if (cancellationToken.CanBeCanceled)
                    {
                        connectionWaiter._cancellationTokenRegistration = cancellationToken.Register(delegate (object s)
                        {
                            HttpConnectionPool.ConnectionWaiter connectionWaiter2 = (HttpConnectionPool.ConnectionWaiter)s;
                            object syncObj2 = connectionWaiter2._pool.SyncObj;
                            lock (syncObj2)
                            {
                                if (connectionWaiter2._pool.RemoveWaiterForCancellation(connectionWaiter2))
                                {
                                    bool flag3 = connectionWaiter2.TrySetCanceled(connectionWaiter2._cancellationToken);
                                }
                            }
                        }, connectionWaiter);
                    }
                    result = new ValueTask<ValueTuple<HttpConnection, HttpResponseMessage>>(connectionWaiter.Task);
                }
            }
            return result;
        }

        // Token: 0x06000530 RID: 1328 RVA: 0x000499E0 File Offset: 0x000299E0
        public async Task<HttpResponseMessage> SendWithRetryAsync(HttpRequestMessage request, bool doRequestAuth, CancellationToken cancellationToken)
        {
            HttpResponseMessage item;
            for (; ; )
            {
                ValueTuple<HttpConnection, HttpResponseMessage> valueTuple = await this.GetConnectionAsync(request, cancellationToken).ConfigureAwait(false);
                ValueTuple<HttpConnection, HttpResponseMessage> valueTuple2 = valueTuple;
                HttpConnection connection = valueTuple2.Item1;
                item = valueTuple2.Item2;
                if (item != null)
                {
                    break;
                }
                bool isNewConnection = connection.IsNewConnection;
                connection.Acquire();
                try
                {
                    return await connection.SendAsync(request, doRequestAuth, cancellationToken).ConfigureAwait(false);
                }
                catch (HttpRequestException ex) when (!isNewConnection && ex.InnerException is IOException && connection.CanRetry)
                {
                }
                finally
                {
                    connection.Release();
                }
                connection = null;
            }
            return item;
        }

        // Token: 0x06000531 RID: 1329 RVA: 0x00049A40 File Offset: 0x00029A40
        public Task<HttpResponseMessage> SendWithProxyAuthAsync(HttpRequestMessage request, bool doRequestAuth, CancellationToken cancellationToken)
        {
            if ((this._kind == HttpConnectionKind.Proxy || this._kind == HttpConnectionKind.ProxyConnect) && this._poolManager.ProxyCredentials != null)
            {
                return AuthenticationHelper.SendWithProxyAuthAsync(request, this._proxyUri, this._poolManager.ProxyCredentials, doRequestAuth, this, cancellationToken);
            }
            return this.SendWithRetryAsync(request, doRequestAuth, cancellationToken);
        }

        // Token: 0x06000532 RID: 1330 RVA: 0x00049A90 File Offset: 0x00029A90
        public Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool doRequestAuth, CancellationToken cancellationToken)
        {
            if (doRequestAuth && this.Settings._credentials != null)
            {
                return AuthenticationHelper.SendWithRequestAuthAsync(request, this.Settings._credentials, this.Settings._preAuthenticate, this, cancellationToken);
            }
            return this.SendWithProxyAuthAsync(request, doRequestAuth, cancellationToken);
        }

        // Token: 0x06000533 RID: 1331 RVA: 0x00049ACC File Offset: 0x00029ACC
        private async ValueTask<ValueTuple<HttpConnection, HttpResponseMessage>> CreateConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            CancellationTokenSource cancellationWithConnectTimeout = null;
            if (this.Settings._connectTimeout != Timeout.InfiniteTimeSpan)
            {
                cancellationWithConnectTimeout = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, default(CancellationToken));
                cancellationWithConnectTimeout.CancelAfter(this.Settings._connectTimeout);
                cancellationToken = cancellationWithConnectTimeout.Token;
            }
            ValueTuple<HttpConnection, HttpResponseMessage> result;
            try
            {
                Socket socket = null;
                Stream stream = null;
                switch (this._kind)
                {
                    case HttpConnectionKind.Http:
                    case HttpConnectionKind.Https:
                    case HttpConnectionKind.ProxyConnect:
                        {
                            ValueTuple<Socket, Stream> valueTuple = await ConnectHelper.ConnectAsync(this.Settings._tcpIpSystem, this._host, this._port, cancellationToken).ConfigureAwait(false);
                            ValueTuple<Socket, Stream> valueTuple2 = valueTuple;
                            socket = valueTuple2.Item1;
                            stream = valueTuple2.Item2;
                            break;
                        }
                    case HttpConnectionKind.Proxy:
                        {
                            ValueTuple<Socket, Stream> valueTuple3 = await ConnectHelper.ConnectAsync(this.Settings._tcpIpSystem, this._proxyUri.IdnHost, this._proxyUri.Port, cancellationToken).ConfigureAwait(false);
                            socket = valueTuple3.Item1;
                            stream = valueTuple3.Item2;
                            break;
                        }
                    case HttpConnectionKind.ProxyTunnel:
                    case HttpConnectionKind.SslProxyTunnel:
                        {
                            ValueTuple<Stream, HttpResponseMessage> valueTuple4 = await this.EstablishProxyTunnel(cancellationToken).ConfigureAwait(false);
                            stream = valueTuple4.Item1;
                            HttpResponseMessage item = valueTuple4.Item2;
                            if (item != null)
                            {
                                item.RequestMessage = request;
                                return new ValueTuple<HttpConnection, HttpResponseMessage>(null, item);
                            }
                            break;
                        }
                }
                TransportContext transportContext = null;
                if (this._sslOptions != null)
                {
                    transportContext = ((SslStream)(stream = await ConnectHelper.EstablishSslConnectionAsync(this._sslOptions, request, stream, cancellationToken).ConfigureAwait(false))).TransportContext;
                }
                HttpConnection item2 = (this._maxConnections == int.MaxValue) ? new HttpConnection(this, socket, stream, transportContext) : new HttpConnectionWithFinalizer(this, socket, stream, transportContext);
                result = new ValueTuple<HttpConnection, HttpResponseMessage>(item2, null);
            }
            finally
            {
                CancellationTokenSource cancellationTokenSource = cancellationWithConnectTimeout;
                if (cancellationTokenSource != null)
                {
                    cancellationTokenSource.Dispose();
                }
            }
            return result;
        }

        // Token: 0x06000534 RID: 1332 RVA: 0x00049B24 File Offset: 0x00029B24
        private async ValueTask<ValueTuple<Stream, HttpResponseMessage>> EstablishProxyTunnel(CancellationToken cancellationToken)
        {
            HttpRequestMessage httpRequestMessage = new HttpRequestMessage(HttpMethod.Connect, this._proxyUri);
            httpRequestMessage.Headers.Host = string.Format("{0}:{1}", this._host, this._port);
            HttpResponseMessage httpResponseMessage = await this._poolManager.SendProxyConnectAsync(httpRequestMessage, this._proxyUri, cancellationToken).ConfigureAwait(false);
            HttpResponseMessage httpResponseMessage2 = httpResponseMessage;
            ValueTuple<Stream, HttpResponseMessage> result;
            if (httpResponseMessage2.StatusCode != HttpStatusCode.OK)
            {
                result = new ValueTuple<Stream, HttpResponseMessage>(null, httpResponseMessage2);
            }
            else
            {
                result = new ValueTuple<Stream, HttpResponseMessage>(await httpResponseMessage2.Content.ReadAsStreamAsync().ConfigureAwait(false), null);
            }
            return result;
        }

        // Token: 0x06000535 RID: 1333 RVA: 0x00049B71 File Offset: 0x00029B71
        private void EnqueueWaiter(HttpConnectionPool.ConnectionWaiter waiter)
        {
            waiter._next = this._waitersHead;
            if (this._waitersHead != null)
            {
                this._waitersHead._prev = waiter;
            }
            else
            {
                this._waitersTail = waiter;
            }
            this._waitersHead = waiter;
        }

        // Token: 0x06000536 RID: 1334 RVA: 0x00049BA4 File Offset: 0x00029BA4
        private HttpConnectionPool.ConnectionWaiter DequeueWaiter()
        {
            HttpConnectionPool.ConnectionWaiter waitersTail = this._waitersTail;
            this._waitersTail = waitersTail._prev;
            if (this._waitersTail != null)
            {
                this._waitersTail._next = null;
            }
            else
            {
                this._waitersHead = null;
            }
            waitersTail._next = null;
            waitersTail._prev = null;
            return waitersTail;
        }

        // Token: 0x06000537 RID: 1335 RVA: 0x00049BF0 File Offset: 0x00029BF0
        private bool RemoveWaiterForCancellation(HttpConnectionPool.ConnectionWaiter waiter)
        {
            bool result = waiter._next != null || waiter._prev != null || this._waitersHead == waiter || this._waitersTail == waiter;
            if (waiter._next != null)
            {
                waiter._next._prev = waiter._prev;
            }
            if (waiter._prev != null)
            {
                waiter._prev._next = waiter._next;
            }
            if (this._waitersHead == waiter && this._waitersTail == waiter)
            {
                this._waitersHead = (this._waitersTail = null);
            }
            else if (this._waitersHead == waiter)
            {
                this._waitersHead = waiter._next;
            }
            else if (this._waitersTail == waiter)
            {
                this._waitersTail = waiter._prev;
            }
            waiter._next = null;
            waiter._prev = null;
            return result;
        }

        // Token: 0x06000538 RID: 1336 RVA: 0x00049CB4 File Offset: 0x00029CB4
        private async ValueTask<ValueTuple<HttpConnection, HttpResponseMessage>> WaitForCreatedConnectionAsync(ValueTask<ValueTuple<HttpConnection, HttpResponseMessage>> creationTask)
        {
            ValueTuple<HttpConnection, HttpResponseMessage> result;
            try
            {
                ValueTuple<HttpConnection, HttpResponseMessage> valueTuple = await creationTask.ConfigureAwait(false);
                ValueTuple<HttpConnection, HttpResponseMessage> valueTuple2 = valueTuple;
                HttpConnection item = valueTuple2.Item1;
                HttpResponseMessage item2 = valueTuple2.Item2;
                if (item == null)
                {
                    this.DecrementConnectionCount();
                }
                result = new ValueTuple<HttpConnection, HttpResponseMessage>(item, item2);
            }
            catch
            {
                this.DecrementConnectionCount();
                throw;
            }
            return result;
        }

        // Token: 0x06000539 RID: 1337 RVA: 0x00049D01 File Offset: 0x00029D01
        private void IncrementConnectionCountNoLock()
        {
            if (NetEventSource.IsEnabled)
            {
                this.Trace(null, "IncrementConnectionCountNoLock");
            }
            this._usedSinceLastCleanup = true;
            this._associatedConnectionCount++;
        }

        // Token: 0x0600053A RID: 1338 RVA: 0x00049D2C File Offset: 0x00029D2C
        public void DecrementConnectionCount()
        {
            if (NetEventSource.IsEnabled)
            {
                this.Trace(null, "DecrementConnectionCount");
            }
            object syncObj = this.SyncObj;
            lock (syncObj)
            {
                this._usedSinceLastCleanup = true;
                if (this._waitersHead == null)
                {
                    this._associatedConnectionCount--;
                }
                else
                {
                    HttpConnectionPool.ConnectionWaiter connectionWaiter = this.DequeueWaiter();
                    connectionWaiter._cancellationTokenRegistration.Dispose();
                    ValueTask<ValueTuple<HttpConnection, HttpResponseMessage>> valueTask = connectionWaiter.CreateConnectionAsync();
                    if (valueTask.IsCompletedSuccessfully)
                    {
                        connectionWaiter.SetResult(valueTask.Result);
                    }
                    else
                    {
                        valueTask.AsTask().ContinueWith(delegate (Task<ValueTuple<HttpConnection, HttpResponseMessage>> innerConnectionTask, object state)
                        {
                            HttpConnectionPool.ConnectionWaiter connectionWaiter2 = (HttpConnectionPool.ConnectionWaiter)state;
                            try
                            {
                                ValueTuple<HttpConnection, HttpResponseMessage> result = innerConnectionTask.GetAwaiter().GetResult();
                                HttpConnection item = result.Item1;
                                HttpResponseMessage item2 = result.Item2;
                                if (item2 != null)
                                {
                                    connectionWaiter2._pool.DecrementConnectionCount();
                                }
                                connectionWaiter2.SetResult(innerConnectionTask.Result);
                            }
                            catch (Exception exception)
                            {
                                connectionWaiter2.SetException(exception);
                                connectionWaiter2._pool.DecrementConnectionCount();
                            }
                        }, connectionWaiter, CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);
                    }
                }
            }
        }

        // Token: 0x0600053B RID: 1339 RVA: 0x00049E08 File Offset: 0x00029E08
        public void ReturnConnection(HttpConnection connection)
        {
            List<HttpConnectionPool.CachedConnection> idleConnections = this._idleConnections;
            object syncObj = this.SyncObj;
            lock (syncObj)
            {
                this._usedSinceLastCleanup = true;
                if (this._waitersTail != null && !connection.EnsureReadAheadAndPollRead())
                {
                    HttpConnectionPool.ConnectionWaiter connectionWaiter = this.DequeueWaiter();
                    connectionWaiter._cancellationTokenRegistration.Dispose();
                    if (NetEventSource.IsEnabled)
                    {
                        connection.Trace("Transferring connection returned to pool.", "ReturnConnection");
                    }
                    connectionWaiter.SetResult(new ValueTuple<HttpConnection, HttpResponseMessage>(connection, null));
                }
                else if (this._disposed || this._poolManager.AvoidStoringConnections)
                {
                    if (NetEventSource.IsEnabled)
                    {
                        connection.Trace("Disposing connection returned to disposed pool.", "ReturnConnection");
                    }
                    connection.Dispose();
                }
                else
                {
                    idleConnections.Add(new HttpConnectionPool.CachedConnection(connection));
                    if (NetEventSource.IsEnabled)
                    {
                        connection.Trace("Stored connection in pool.", "ReturnConnection");
                    }
                }
            }
        }

        // Token: 0x0600053C RID: 1340 RVA: 0x00049EF0 File Offset: 0x00029EF0
        public void Dispose()
        {
            List<HttpConnectionPool.CachedConnection> idleConnections = this._idleConnections;
            object syncObj = this.SyncObj;
            lock (syncObj)
            {
                if (!this._disposed)
                {
                    if (NetEventSource.IsEnabled)
                    {
                        this.Trace("Disposing pool.", "Dispose");
                    }
                    this._disposed = true;
                    idleConnections.ForEach(delegate (HttpConnectionPool.CachedConnection c)
                    {
                        c._connection.Dispose();
                    });
                    idleConnections.Clear();
                }
            }
        }

        // Token: 0x0600053D RID: 1341 RVA: 0x00049F84 File Offset: 0x00029F84
        public bool CleanCacheAndDisposeIfUnused()
        {
            TimeSpan pooledConnectionLifetime = this._poolManager.Settings._pooledConnectionLifetime;
            TimeSpan pooledConnectionIdleTimeout = this._poolManager.Settings._pooledConnectionIdleTimeout;
            List<HttpConnectionPool.CachedConnection> idleConnections = this._idleConnections;
            List<HttpConnection> list = null;
            bool flag = false;
            try
            {
                if (NetEventSource.IsEnabled)
                {
                    this.Trace("Cleaning pool.", "CleanCacheAndDisposeIfUnused");
                }
                Monitor.Enter(this.SyncObj, ref flag);
                DateTimeOffset utcNow = DateTimeOffset.UtcNow;
                int num = 0;
                while (num < idleConnections.Count && idleConnections[num].IsUsable(utcNow, pooledConnectionLifetime, pooledConnectionIdleTimeout, true))
                {
                    num++;
                }
                if (num < idleConnections.Count)
                {
                    list = new List<HttpConnection>
                    {
                        idleConnections[num]._connection
                    };
                    int i = num + 1;
                    while (i < idleConnections.Count)
                    {
                        while (i < idleConnections.Count && !idleConnections[i].IsUsable(utcNow, pooledConnectionLifetime, pooledConnectionIdleTimeout, true))
                        {
                            list.Add(idleConnections[i]._connection);
                            i++;
                        }
                        if (i < idleConnections.Count)
                        {
                            idleConnections[num++] = idleConnections[i++];
                        }
                    }
                    idleConnections.RemoveRange(num, idleConnections.Count - num);
                    if (this._associatedConnectionCount == 0 && !this._usedSinceLastCleanup)
                    {
                        this._disposed = true;
                        return true;
                    }
                }
                this._usedSinceLastCleanup = false;
            }
            finally
            {
                if (flag)
                {
                    Monitor.Exit(this.SyncObj);
                }
                if (list != null)
                {
                    list.ForEach(delegate (HttpConnection c)
                    {
                        c.Dispose();
                    });
                }
            }
            return false;
        }

        // Token: 0x0600053E RID: 1342 RVA: 0x0004A13C File Offset: 0x0002A13C
        private static bool GetIsWindows7Or2008R2()
        {
            OperatingSystem osversion = Environment.OSVersion;
            if (osversion.Platform == PlatformID.Win32NT)
            {
                Version version = osversion.Version;
                return version.Major == 6 && version.Minor == 1;
            }
            return false;
        }

        // Token: 0x0600053F RID: 1343 RVA: 0x0004A178 File Offset: 0x0002A178
        public override string ToString()
        {
            return string.Format("{0}", "HttpConnectionPool") + ((this._proxyUri == null) ? ((this._sslOptions == null) ? string.Format("http://{0}:{1}", this._host, this._port) : (string.Format("https://{0}:{1}", this._host, this._port) + ((this._sslOptions.TargetHost != this._host) ? string.Format(", SSL TargetHost={0}", this._sslOptions.TargetHost) : null))) : ((this._sslOptions == null) ? string.Format("Proxy {0}", this._proxyUri) : (string.Format("https://{0}:{1}/ tunnelled via Proxy {2}", this._host, this._port, this._proxyUri) + ((this._sslOptions.TargetHost != this._host) ? string.Format(", SSL TargetHost={0}", this._sslOptions.TargetHost) : null))));
        }

        // Token: 0x06000540 RID: 1344 RVA: 0x0004A291 File Offset: 0x0002A291
        private void Trace(string message, [CallerMemberName] string memberName = null)
        {
            NetEventSource.Log.HandlerMessage(this.GetHashCode(), 0, 0, memberName, this.ToString() + ":" + message);
        }

        // Token: 0x0400040D RID: 1037
        private static readonly bool s_isWindows7Or2008R2 = HttpConnectionPool.GetIsWindows7Or2008R2();

        // Token: 0x0400040E RID: 1038
        private readonly HttpConnectionPoolManager _poolManager;

        // Token: 0x0400040F RID: 1039
        private readonly HttpConnectionKind _kind;

        // Token: 0x04000410 RID: 1040
        private readonly string _host;

        // Token: 0x04000411 RID: 1041
        private readonly int _port;

        // Token: 0x04000412 RID: 1042
        private readonly Uri _proxyUri;

        // Token: 0x04000413 RID: 1043
        private readonly List<HttpConnectionPool.CachedConnection> _idleConnections = new List<HttpConnectionPool.CachedConnection>();

        // Token: 0x04000414 RID: 1044
        private readonly int _maxConnections;

        // Token: 0x04000415 RID: 1045
        private readonly byte[] _hostHeaderValueBytes;

        // Token: 0x04000416 RID: 1046
        private readonly SslClientAuthenticationOptions _sslOptions;

        // Token: 0x04000417 RID: 1047
        private HttpConnectionPool.ConnectionWaiter _waitersHead;

        // Token: 0x04000418 RID: 1048
        private HttpConnectionPool.ConnectionWaiter _waitersTail;

        // Token: 0x04000419 RID: 1049
        private int _associatedConnectionCount;

        // Token: 0x0400041A RID: 1050
        private bool _usedSinceLastCleanup = true;

        // Token: 0x0400041B RID: 1051
        private bool _disposed;

        // Token: 0x020000EC RID: 236
        [StructLayout(LayoutKind.Auto)]
        private readonly struct CachedConnection : IEquatable<HttpConnectionPool.CachedConnection>
        {
            // Token: 0x06000542 RID: 1346 RVA: 0x0004A2C3 File Offset: 0x0002A2C3
            public CachedConnection(HttpConnection connection)
            {
                this._connection = connection;
                this._returnedTime = DateTimeOffset.UtcNow;
            }

            // Token: 0x06000543 RID: 1347 RVA: 0x0004A2D8 File Offset: 0x0002A2D8
            public bool IsUsable(DateTimeOffset now, TimeSpan pooledConnectionLifetime, TimeSpan pooledConnectionIdleTimeout, bool poll = false)
            {
                if (pooledConnectionIdleTimeout != Timeout.InfiniteTimeSpan && now - this._returnedTime > pooledConnectionIdleTimeout)
                {
                    if (NetEventSource.IsEnabled)
                    {
                        this._connection.Trace(string.Format("Connection no longer usable. Idle {0} > {1}.", now - this._returnedTime, pooledConnectionIdleTimeout), "IsUsable");
                    }
                    return false;
                }
                if (pooledConnectionLifetime != Timeout.InfiniteTimeSpan && now - this._connection.CreationTime > pooledConnectionLifetime)
                {
                    if (NetEventSource.IsEnabled)
                    {
                        this._connection.Trace(string.Format("Connection no longer usable. Alive {0} > {1}.", now - this._connection.CreationTime, pooledConnectionLifetime), "IsUsable");
                    }
                    return false;
                }
                if (poll && this._connection.PollRead())
                {
                    if (NetEventSource.IsEnabled)
                    {
                        this._connection.Trace("Connection no longer usable. Unexpected data received.", "IsUsable");
                    }
                    return false;
                }
                return true;
            }

            // Token: 0x06000544 RID: 1348 RVA: 0x0004A3D5 File Offset: 0x0002A3D5
            public bool Equals(HttpConnectionPool.CachedConnection other)
            {
                return other._connection == this._connection;
            }

            // Token: 0x06000545 RID: 1349 RVA: 0x0004A3E5 File Offset: 0x0002A3E5
            public override bool Equals(object obj)
            {
                return obj is HttpConnectionPool.CachedConnection && this.Equals((HttpConnectionPool.CachedConnection)obj);
            }

            // Token: 0x06000546 RID: 1350 RVA: 0x0004A3FD File Offset: 0x0002A3FD
            public override int GetHashCode()
            {
                HttpConnection connection = this._connection;
                if (connection == null)
                {
                    return 0;
                }
                return connection.GetHashCode();
            }

            // Token: 0x0400041D RID: 1053
            internal readonly HttpConnection _connection;

            // Token: 0x0400041E RID: 1054
            internal readonly DateTimeOffset _returnedTime;
        }

        // Token: 0x020000ED RID: 237
        private class ConnectionWaiter : TaskCompletionSource<ValueTuple<HttpConnection, HttpResponseMessage>>
        {
            // Token: 0x06000547 RID: 1351 RVA: 0x0004A410 File Offset: 0x0002A410
            public ConnectionWaiter(HttpConnectionPool pool, HttpRequestMessage request, CancellationToken cancellationToken) : base(TaskCreationOptions.RunContinuationsAsynchronously)
            {
                this._pool = pool;
                this._request = request;
                this._cancellationToken = cancellationToken;
            }

            // Token: 0x06000548 RID: 1352 RVA: 0x0004A42F File Offset: 0x0002A42F
            public ValueTask<ValueTuple<HttpConnection, HttpResponseMessage>> CreateConnectionAsync()
            {
                return this._pool.CreateConnectionAsync(this._request, this._cancellationToken);
            }

            // Token: 0x0400041F RID: 1055
            internal readonly HttpConnectionPool _pool;

            // Token: 0x04000420 RID: 1056
            private readonly HttpRequestMessage _request;

            // Token: 0x04000421 RID: 1057
            internal readonly CancellationToken _cancellationToken;

            // Token: 0x04000422 RID: 1058
            internal CancellationTokenRegistration _cancellationTokenRegistration;

            // Token: 0x04000423 RID: 1059
            internal HttpConnectionPool.ConnectionWaiter _next;

            // Token: 0x04000424 RID: 1060
            internal HttpConnectionPool.ConnectionWaiter _prev;
        }
    }


    // Token: 0x020000F3 RID: 243
    internal sealed class HttpConnectionPoolManager : IDisposable
    {
        // Token: 0x170000FC RID: 252
        // (get) Token: 0x06000557 RID: 1367 RVA: 0x0004AE92 File Offset: 0x0002AE92
        private object SyncObj
        {
            get
            {
                return this._pools;
            }
        }

        // Token: 0x06000558 RID: 1368 RVA: 0x0004AE9C File Offset: 0x0002AE9C
        public HttpConnectionPoolManager(HttpConnectionSettings settings)
        {
            this._settings = settings;
            this._maxConnectionsPerServer = settings._maxConnectionsPerServer;
            this._avoidStoringConnections = (settings._pooledConnectionIdleTimeout == TimeSpan.Zero || settings._pooledConnectionLifetime == TimeSpan.Zero);
            this._pools = new ConcurrentDictionary<HttpConnectionPoolManager.HttpConnectionKey, HttpConnectionPool>();
            if (!this._avoidStoringConnections)
            {
                if (settings._pooledConnectionIdleTimeout == Timeout.InfiniteTimeSpan)
                {
                    this._cleanPoolTimeout = TimeSpan.FromSeconds(30.0);
                }
                else
                {
                    TimeSpan timeSpan = settings._pooledConnectionIdleTimeout / 4.0;
                    this._cleanPoolTimeout = ((timeSpan.TotalSeconds >= 1.0) ? timeSpan : TimeSpan.FromSeconds(1.0));
                }
                bool flag = false;
                try
                {
                    if (!ExecutionContext.IsFlowSuppressed())
                    {
                        ExecutionContext.SuppressFlow();
                        flag = true;
                    }
                    this._cleaningTimer = new Timer(delegate (object s)
                    {
                        ((HttpConnectionPoolManager)s).RemoveStalePools();
                    }, this, -1, -1);
                }
                finally
                {
                    if (flag)
                    {
                        ExecutionContext.RestoreFlow();
                    }
                }
            }
            if (settings._useProxy)
            {
                this._proxy = (settings._proxy ?? SystemProxyInfo.ConstructSystemProxy());
                if (this._proxy != null)
                {
                    this._proxyCredentials = (this._proxy.Credentials ?? settings._defaultProxyCredentials);
                }
            }
        }

        // Token: 0x170000FD RID: 253
        // (get) Token: 0x06000559 RID: 1369 RVA: 0x0004B004 File Offset: 0x0002B004
        public HttpConnectionSettings Settings
        {
            get
            {
                return this._settings;
            }
        }

        // Token: 0x170000FE RID: 254
        // (get) Token: 0x0600055A RID: 1370 RVA: 0x0004B00C File Offset: 0x0002B00C
        public ICredentials ProxyCredentials
        {
            get
            {
                return this._proxyCredentials;
            }
        }

        // Token: 0x170000FF RID: 255
        // (get) Token: 0x0600055B RID: 1371 RVA: 0x0004B014 File Offset: 0x0002B014
        public bool AvoidStoringConnections
        {
            get
            {
                return this._avoidStoringConnections;
            }
        }

        // Token: 0x0600055C RID: 1372 RVA: 0x0004B01C File Offset: 0x0002B01C
        private static string ParseHostNameFromHeader(string hostHeader)
        {
            int num = hostHeader.IndexOf(':');
            if (num >= 0)
            {
                int num2 = hostHeader.IndexOf(']');
                if (num2 == -1)
                {
                    return hostHeader.Substring(0, num);
                }
                num = hostHeader.LastIndexOf(':');
                if (num > num2)
                {
                    return hostHeader.Substring(0, num);
                }
            }
            return hostHeader;
        }

        // Token: 0x0600055D RID: 1373 RVA: 0x0004B064 File Offset: 0x0002B064
        private static HttpConnectionPoolManager.HttpConnectionKey GetConnectionKey(HttpRequestMessage request, Uri proxyUri, bool isProxyConnect)
        {
            Uri requestUri = request.RequestUri;
            if (isProxyConnect)
            {
                return new HttpConnectionPoolManager.HttpConnectionKey(HttpConnectionKind.ProxyConnect, requestUri.IdnHost, requestUri.Port, null, proxyUri);
            }
            string text = null;
            if (HttpUtilities.IsSupportedSecureScheme(requestUri.Scheme))
            {
                string host = request.Headers.Host;
                if (host != null)
                {
                    text = HttpConnectionPoolManager.ParseHostNameFromHeader(host);
                }
                else
                {
                    text = requestUri.IdnHost;
                }
            }
            if (proxyUri != null)
            {
                if (text != null)
                {
                    return new HttpConnectionPoolManager.HttpConnectionKey(HttpConnectionKind.SslProxyTunnel, requestUri.IdnHost, requestUri.Port, text, proxyUri);
                }
                if (HttpUtilities.IsNonSecureWebSocketScheme(requestUri.Scheme))
                {
                    return new HttpConnectionPoolManager.HttpConnectionKey(HttpConnectionKind.ProxyTunnel, requestUri.IdnHost, requestUri.Port, null, proxyUri);
                }
                return new HttpConnectionPoolManager.HttpConnectionKey(HttpConnectionKind.Proxy, null, 0, null, proxyUri);
            }
            else
            {
                if (text != null)
                {
                    return new HttpConnectionPoolManager.HttpConnectionKey(HttpConnectionKind.Https, requestUri.IdnHost, requestUri.Port, text, null);
                }
                return new HttpConnectionPoolManager.HttpConnectionKey(HttpConnectionKind.Http, requestUri.IdnHost, requestUri.Port, null, null);
            }
        }

        // Token: 0x0600055E RID: 1374 RVA: 0x0004B138 File Offset: 0x0002B138
        public Task<HttpResponseMessage> SendAsyncCore(HttpRequestMessage request, Uri proxyUri, bool doRequestAuth, bool isProxyConnect, CancellationToken cancellationToken)
        {
            HttpConnectionPoolManager.HttpConnectionKey connectionKey = HttpConnectionPoolManager.GetConnectionKey(request, proxyUri, isProxyConnect);
            HttpConnectionPool httpConnectionPool;
            while (!this._pools.TryGetValue(connectionKey, out httpConnectionPool))
            {
                bool flag = connectionKey.Host != null && request.RequestUri.HostNameType == UriHostNameType.IPv6;
                httpConnectionPool = new HttpConnectionPool(this, connectionKey.Kind, flag ? ("[" + connectionKey.Host + "]") : connectionKey.Host, connectionKey.Port, connectionKey.SslHostName, connectionKey.ProxyUri, this._maxConnectionsPerServer);
                if (this._cleaningTimer == null)
                {
                    break;
                }
                if (this._pools.TryAdd(connectionKey, httpConnectionPool))
                {
                    object syncObj = this.SyncObj;
                    lock (syncObj)
                    {
                        if (!this._timerIsRunning)
                        {
                            this.SetCleaningTimer(this._cleanPoolTimeout);
                        }
                        break;
                    }
                }
            }
            return httpConnectionPool.SendAsync(request, doRequestAuth, cancellationToken);
        }

        // Token: 0x0600055F RID: 1375 RVA: 0x0004B22C File Offset: 0x0002B22C
        public Task<HttpResponseMessage> SendProxyConnectAsync(HttpRequestMessage request, Uri proxyUri, CancellationToken cancellationToken)
        {
            return this.SendAsyncCore(request, proxyUri, false, true, cancellationToken);
        }

        // Token: 0x06000560 RID: 1376 RVA: 0x0004B23C File Offset: 0x0002B23C
        public Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool doRequestAuth, CancellationToken cancellationToken)
        {
            if (this._proxy == null)
            {
                return this.SendAsyncCore(request, null, doRequestAuth, false, cancellationToken);
            }
            Uri uri = null;
            try
            {
                if (!this._proxy.IsBypassed(request.RequestUri))
                {
                    uri = this._proxy.GetProxy(request.RequestUri);
                }
            }
            catch (Exception ex)
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(this, FormattableStringFactory.Create("Exception from IWebProxy.GetProxy({0}): {1}", new object[]
                    {
                        request.RequestUri,
                        ex
                    }), "SendAsync");
                }
            }
            if (uri != null && uri.Scheme != "http")
            {
                throw new NotSupportedException(SR.net_http_invalid_proxy_scheme);
            }
            return this.SendAsyncCore(request, uri, doRequestAuth, false, cancellationToken);
        }

        // Token: 0x06000561 RID: 1377 RVA: 0x0004B2FC File Offset: 0x0002B2FC
        public void Dispose()
        {
            Timer cleaningTimer = this._cleaningTimer;
            if (cleaningTimer != null)
            {
                cleaningTimer.Dispose();
            }
            foreach (KeyValuePair<HttpConnectionPoolManager.HttpConnectionKey, HttpConnectionPool> keyValuePair in this._pools)
            {
                keyValuePair.Value.Dispose();
            }
            IDisposable disposable;
            if ((disposable = (this._proxy as IDisposable)) != null)
            {
                disposable.Dispose();
            }
        }

        // Token: 0x06000562 RID: 1378 RVA: 0x0004B374 File Offset: 0x0002B374
        private void SetCleaningTimer(TimeSpan timeout)
        {
            try
            {
                this._cleaningTimer.Change(timeout, timeout);
                this._timerIsRunning = (timeout != Timeout.InfiniteTimeSpan);
            }
            catch (ObjectDisposedException)
            {
            }
        }

        // Token: 0x06000563 RID: 1379 RVA: 0x0004B3B8 File Offset: 0x0002B3B8
        private void RemoveStalePools()
        {
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Enter(this, null, "RemoveStalePools");
            }
            foreach (KeyValuePair<HttpConnectionPoolManager.HttpConnectionKey, HttpConnectionPool> keyValuePair in this._pools)
            {
                if (keyValuePair.Value.CleanCacheAndDisposeIfUnused())
                {
                    HttpConnectionPool httpConnectionPool;
                    this._pools.TryRemove(keyValuePair.Key, out httpConnectionPool);
                }
            }
            object syncObj = this.SyncObj;
            lock (syncObj)
            {
                if (this._pools.IsEmpty)
                {
                    this.SetCleaningTimer(Timeout.InfiniteTimeSpan);
                }
            }
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Exit(this, null, "RemoveStalePools");
            }
        }

        // Token: 0x04000449 RID: 1097
        private readonly TimeSpan _cleanPoolTimeout;

        // Token: 0x0400044A RID: 1098
        private readonly ConcurrentDictionary<HttpConnectionPoolManager.HttpConnectionKey, HttpConnectionPool> _pools;

        // Token: 0x0400044B RID: 1099
        private readonly Timer _cleaningTimer;

        // Token: 0x0400044C RID: 1100
        private readonly int _maxConnectionsPerServer;

        // Token: 0x0400044D RID: 1101
        private readonly bool _avoidStoringConnections;

        // Token: 0x0400044E RID: 1102
        private readonly HttpConnectionSettings _settings;

        // Token: 0x0400044F RID: 1103
        private readonly IWebProxy _proxy;

        // Token: 0x04000450 RID: 1104
        private readonly ICredentials _proxyCredentials;

        // Token: 0x04000451 RID: 1105
        private bool _timerIsRunning;

        // Token: 0x020000F4 RID: 244
        internal readonly struct HttpConnectionKey : IEquatable<HttpConnectionPoolManager.HttpConnectionKey>
        {
            // Token: 0x06000564 RID: 1380 RVA: 0x0004B48C File Offset: 0x0002B48C
            public HttpConnectionKey(HttpConnectionKind kind, string host, int port, string sslHostName, Uri proxyUri)
            {
                this.Kind = kind;
                this.Host = host;
                this.Port = port;
                this.SslHostName = sslHostName;
                this.ProxyUri = proxyUri;
            }

            // Token: 0x06000565 RID: 1381 RVA: 0x0004B4B4 File Offset: 0x0002B4B4
            public override int GetHashCode()
            {
                if (!(this.SslHostName == this.Host))
                {
                    return HashCode.Combine<HttpConnectionKind, string, int, string, Uri>(this.Kind, this.Host, this.Port, this.SslHostName, this.ProxyUri);
                }
                return HashCode.Combine<HttpConnectionKind, string, int, Uri>(this.Kind, this.Host, this.Port, this.ProxyUri);
            }

            // Token: 0x06000566 RID: 1382 RVA: 0x0004B515 File Offset: 0x0002B515
            public override bool Equals(object obj)
            {
                return obj != null && obj is HttpConnectionPoolManager.HttpConnectionKey && this.Equals((HttpConnectionPoolManager.HttpConnectionKey)obj);
            }

            // Token: 0x06000567 RID: 1383 RVA: 0x0004B530 File Offset: 0x0002B530
            public bool Equals(HttpConnectionPoolManager.HttpConnectionKey other)
            {
                return this.Kind == other.Kind && this.Host == other.Host && this.Port == other.Port && this.ProxyUri == other.ProxyUri && this.SslHostName == other.SslHostName;
            }

            // Token: 0x04000452 RID: 1106
            public readonly HttpConnectionKind Kind;

            // Token: 0x04000453 RID: 1107
            public readonly string Host;

            // Token: 0x04000454 RID: 1108
            public readonly int Port;

            // Token: 0x04000455 RID: 1109
            public readonly string SslHostName;

            // Token: 0x04000456 RID: 1110
            public readonly Uri ProxyUri;
        }
    }


    // Token: 0x020000F6 RID: 246
    internal sealed class HttpConnectionSettings
    {
        // Token: 0x0600056B RID: 1387 RVA: 0x0004B5AC File Offset: 0x0002B5AC
        public HttpConnectionSettings Clone()
        {
            if (this._useCookies && this._cookieContainer == null)
            {
                this._cookieContainer = new CookieContainer();
            }
            HttpConnectionSettings httpConnectionSettings = new HttpConnectionSettings();
            httpConnectionSettings._allowAutoRedirect = this._allowAutoRedirect;
            httpConnectionSettings._automaticDecompression = this._automaticDecompression;
            httpConnectionSettings._cookieContainer = this._cookieContainer;
            httpConnectionSettings._connectTimeout = this._connectTimeout;
            httpConnectionSettings._credentials = this._credentials;
            httpConnectionSettings._defaultProxyCredentials = this._defaultProxyCredentials;
            httpConnectionSettings._expect100ContinueTimeout = this._expect100ContinueTimeout;
            httpConnectionSettings._maxAutomaticRedirections = this._maxAutomaticRedirections;
            httpConnectionSettings._maxConnectionsPerServer = this._maxConnectionsPerServer;
            httpConnectionSettings._maxResponseDrainSize = this._maxResponseDrainSize;
            httpConnectionSettings._maxResponseDrainTime = this._maxResponseDrainTime;
            httpConnectionSettings._maxResponseHeadersLength = this._maxResponseHeadersLength;
            httpConnectionSettings._pooledConnectionLifetime = this._pooledConnectionLifetime;
            httpConnectionSettings._pooledConnectionIdleTimeout = this._pooledConnectionIdleTimeout;
            httpConnectionSettings._preAuthenticate = this._preAuthenticate;
            httpConnectionSettings._properties = this._properties;
            httpConnectionSettings._proxy = this._proxy;
            SslClientAuthenticationOptions sslOptions = this._sslOptions;
            httpConnectionSettings._sslOptions = ((sslOptions != null) ? sslOptions._ShallowClone() : null);
            httpConnectionSettings._useCookies = this._useCookies;
            httpConnectionSettings._useProxy = this._useProxy;
            httpConnectionSettings._tcpIpSystem = this._tcpIpSystem;
            return httpConnectionSettings;
        }

        // Token: 0x04000459 RID: 1113
        internal DecompressionMethods _automaticDecompression;

        // Token: 0x0400045A RID: 1114
        internal bool _useCookies = true;

        // Token: 0x0400045B RID: 1115
        internal CookieContainer _cookieContainer;

        // Token: 0x0400045C RID: 1116
        internal bool _useProxy = true;

        // Token: 0x0400045D RID: 1117
        internal IWebProxy _proxy;

        // Token: 0x0400045E RID: 1118
        internal ICredentials _defaultProxyCredentials;

        // Token: 0x0400045F RID: 1119
        internal bool _preAuthenticate;

        // Token: 0x04000460 RID: 1120
        internal ICredentials _credentials;

        // Token: 0x04000461 RID: 1121
        internal bool _allowAutoRedirect = true;

        // Token: 0x04000462 RID: 1122
        internal int _maxAutomaticRedirections = 50;

        // Token: 0x04000463 RID: 1123
        internal int _maxConnectionsPerServer = int.MaxValue;

        // Token: 0x04000464 RID: 1124
        internal int _maxResponseDrainSize = 1048576;

        // Token: 0x04000465 RID: 1125
        internal TimeSpan _maxResponseDrainTime = HttpHandlerDefaults.DefaultResponseDrainTimeout;

        // Token: 0x04000466 RID: 1126
        internal int _maxResponseHeadersLength = 64;

        // Token: 0x04000467 RID: 1127
        internal TimeSpan _pooledConnectionLifetime = HttpHandlerDefaults.DefaultPooledConnectionLifetime;

        // Token: 0x04000468 RID: 1128
        internal TimeSpan _pooledConnectionIdleTimeout = HttpHandlerDefaults.DefaultPooledConnectionIdleTimeout;

        // Token: 0x04000469 RID: 1129
        internal TimeSpan _expect100ContinueTimeout = HttpHandlerDefaults.DefaultExpect100ContinueTimeout;

        // Token: 0x0400046A RID: 1130
        internal TimeSpan _connectTimeout = HttpHandlerDefaults.DefaultConnectTimeout;

        // Token: 0x0400046B RID: 1131
        internal SslClientAuthenticationOptions _sslOptions;

        // Token: 0x0400046C RID: 1132
        internal IDictionary<string, object> _properties;

        internal TcpIpSystem _tcpIpSystem = null;
    }


    // Token: 0x020000E8 RID: 232
    internal sealed class HttpConnectionWithFinalizer : HttpConnection
    {
        // Token: 0x0600051F RID: 1311 RVA: 0x000495A8 File Offset: 0x000295A8
        public HttpConnectionWithFinalizer(HttpConnectionPool pool, Socket socket, Stream stream, TransportContext transportContext) : base(pool, socket, stream, transportContext)
        {
        }

        // Token: 0x06000520 RID: 1312 RVA: 0x000495B8 File Offset: 0x000295B8
        ~HttpConnectionWithFinalizer()
        {
            base.Dispose(false);
        }
    }


    /// <summary>
    ///         HTTP エンティティ本体およびコンテンツ ヘッダーを表す基本クラス。
    ///       </summary>
    // Token: 0x0200007C RID: 124
    abstract class HttpContent : IDisposable
    {
        /// <summary>
        ///         RFC 2616 で定義されているように HTTP コンテンツ ヘッダーを取得します。
        ///       </summary>
        /// <returns>
        ///         RFC 2616 で定義されているようなコンテンツ ヘッダー。
        ///       </returns>
        // Token: 0x170000AC RID: 172
        // (get) Token: 0x06000292 RID: 658 RVA: 0x0003B5D2 File Offset: 0x0001B5D2
        public HttpContentHeaders Headers
        {
            get
            {
                if (this._headers == null)
                {
                    this._headers = new HttpContentHeaders(this);
                }
                return this._headers;
            }
        }

        // Token: 0x170000AD RID: 173
        // (get) Token: 0x06000293 RID: 659 RVA: 0x0003B5EE File Offset: 0x0001B5EE
        private bool IsBuffered
        {
            get
            {
                return this._bufferedContent != null;
            }
        }

        // Token: 0x06000294 RID: 660 RVA: 0x0003B5F9 File Offset: 0x0001B5F9
        internal void SetBuffer(byte[] buffer, int offset, int count)
        {
            this._bufferedContent = new MemoryStream(buffer, offset, count, false, true);
        }

        // Token: 0x06000295 RID: 661 RVA: 0x0003B60B File Offset: 0x0001B60B
        internal bool TryGetBuffer(out ArraySegment<byte> buffer)
        {
            if (this._bufferedContent != null)
            {
                return this._bufferedContent.TryGetBuffer(out buffer);
            }
            buffer = default(ArraySegment<byte>);
            return false;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpContent" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        // Token: 0x06000296 RID: 662 RVA: 0x0003B62A File Offset: 0x0001B62A
        protected HttpContent()
        {
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Enter(this, null, ".ctor");
            }
            this._canCalculateLength = true;
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Exit(this, null, ".ctor");
            }
        }

        /// <summary>
        ///         非同期操作として HTTP コンテンツを文字列にシリアル化します。
        ///       </summary>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x06000297 RID: 663 RVA: 0x0003B65F File Offset: 0x0001B65F
        public Task<string> ReadAsStringAsync()
        {
            this.CheckDisposed();
            return HttpContent.WaitAndReturnAsync<HttpContent, string>(this.LoadIntoBufferAsync(), this, (HttpContent s) => s.ReadBufferedContentAsString());
        }

        // Token: 0x06000298 RID: 664 RVA: 0x0003B694 File Offset: 0x0001B694
        private string ReadBufferedContentAsString()
        {
            if (this._bufferedContent.Length == 0L)
            {
                return string.Empty;
            }
            ArraySegment<byte> buffer;
            if (!this.TryGetBuffer(out buffer))
            {
                buffer = new ArraySegment<byte>(this._bufferedContent.ToArray());
            }
            return HttpContent.ReadBufferAsString(buffer, this.Headers);
        }

        // Token: 0x06000299 RID: 665 RVA: 0x0003B6DC File Offset: 0x0001B6DC
        internal static string ReadBufferAsString(ArraySegment<byte> buffer, HttpContentHeaders headers)
        {
            Encoding encoding = null;
            int num = -1;
            if (headers.ContentType != null && headers.ContentType.CharSet != null)
            {
                try
                {
                    encoding = Encoding.GetEncoding(headers.ContentType.CharSet);
                    num = HttpContent.GetPreambleLength(buffer, encoding);
                }
                catch (ArgumentException innerException)
                {
                    throw new InvalidOperationException(SR.net_http_content_invalid_charset, innerException);
                }
            }
            if (encoding == null && !HttpContent.TryDetectEncoding(buffer, out encoding, out num))
            {
                encoding = HttpContent.DefaultStringEncoding;
                num = 0;
            }
            return encoding.GetString(buffer.Array, buffer.Offset + num, buffer.Count - num);
        }

        /// <summary>
        ///         非同期操作として HTTP コンテンツをバイト配列にシリアル化します。
        ///       </summary>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x0600029A RID: 666 RVA: 0x0003B770 File Offset: 0x0001B770
        public Task<byte[]> ReadAsByteArrayAsync()
        {
            this.CheckDisposed();
            return HttpContent.WaitAndReturnAsync<HttpContent, byte[]>(this.LoadIntoBufferAsync(), this, (HttpContent s) => s.ReadBufferedContentAsByteArray());
        }

        // Token: 0x0600029B RID: 667 RVA: 0x0003B7A3 File Offset: 0x0001B7A3
        internal byte[] ReadBufferedContentAsByteArray()
        {
            return this._bufferedContent.ToArray();
        }

        /// <summary>
        ///         HTTP コンテンツをシリアル化し、非同期操作としてコンテンツを表すストリームを返します。
        ///       </summary>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x0600029C RID: 668 RVA: 0x0003B7B0 File Offset: 0x0001B7B0
        public Task<Stream> ReadAsStreamAsync()
        {
            this.CheckDisposed();
            if (this._contentReadStream == null)
            {
                ArraySegment<byte> arraySegment;
                Task<Stream> task = this.TryGetBuffer(out arraySegment) ? Task.FromResult<Stream>(new MemoryStream(arraySegment.Array, arraySegment.Offset, arraySegment.Count, false)) : this.CreateContentReadStreamAsync();
                this._contentReadStream = task;
                return task;
            }
            Task<Stream> result;
            if ((result = (this._contentReadStream as Task<Stream>)) != null)
            {
                return result;
            }
            Task<Stream> task2 = Task.FromResult<Stream>((Stream)this._contentReadStream);
            this._contentReadStream = task2;
            return task2;
        }

        // Token: 0x0600029D RID: 669 RVA: 0x0003B834 File Offset: 0x0001B834
        internal Stream TryReadAsStream()
        {
            this.CheckDisposed();
            if (this._contentReadStream == null)
            {
                ArraySegment<byte> arraySegment;
                Stream stream = this.TryGetBuffer(out arraySegment) ? new MemoryStream(arraySegment.Array, arraySegment.Offset, arraySegment.Count, false) : this.TryCreateContentReadStream();
                this._contentReadStream = stream;
                return stream;
            }
            Stream result;
            if ((result = (this._contentReadStream as Stream)) != null)
            {
                return result;
            }
            Task<Stream> task = (Task<Stream>)this._contentReadStream;
            if (task.Status != TaskStatus.RanToCompletion)
            {
                return null;
            }
            return task.Result;
        }

        /// <summary>
        ///         非同期操作として HTTP コンテンツをストリームにシリアル化します。
        ///       </summary>
        /// <param name="stream">
        ///           対象のストリーム。
        ///         </param>
        /// <param name="context">
        ///           トランスポート (チャネル バインディング トークンなど) について説明します。
        ///            このパラメーターは <see langword="null" /> でもかまいません。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x0600029E RID: 670
        protected abstract Task SerializeToStreamAsync(Stream stream, TransportContext context);

        // Token: 0x0600029F RID: 671 RVA: 0x0003B8B4 File Offset: 0x0001B8B4
        internal virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken)
        {
            return this.SerializeToStreamAsync(stream, context);
        }

        /// <summary>
        ///         HTTP コンテンツをバイト ストリームにシリアル化し、<paramref name="stream" /> パラメーターとして指定されたストリーム オブジェクトにコピーします。
        ///       </summary>
        /// <param name="stream">
        ///           対象のストリーム。
        ///         </param>
        /// <param name="context">
        ///           トランスポート (チャネル バインディング トークンなど) について説明します。
        ///            このパラメーターは <see langword="null" /> でもかまいません。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x060002A0 RID: 672 RVA: 0x0003B8BE File Offset: 0x0001B8BE
        public Task CopyToAsync(Stream stream, TransportContext context)
        {
            return this.CopyToAsync(stream, context, CancellationToken.None);
        }

        // Token: 0x060002A1 RID: 673 RVA: 0x0003B8D0 File Offset: 0x0001B8D0
        internal Task CopyToAsync(Stream stream, TransportContext context, CancellationToken cancellationToken)
        {
            this.CheckDisposed();
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }
            Task result;
            try
            {
                ArraySegment<byte> arraySegment;
                if (this.TryGetBuffer(out arraySegment))
                {
                    result = HttpContent.CopyToAsyncCore(stream.WriteAsync(new ReadOnlyMemory<byte>(arraySegment.Array, arraySegment.Offset, arraySegment.Count), cancellationToken));
                }
                else
                {
                    Task task = this.SerializeToStreamAsync(stream, context, cancellationToken);
                    this.CheckTaskNotNull(task);
                    result = HttpContent.CopyToAsyncCore(new ValueTask(task));
                }
            }
            catch (Exception ex) when (HttpContent.StreamCopyExceptionNeedsWrapping(ex))
            {
                result = Task.FromException(HttpContent.GetStreamCopyException(ex));
            }
            return result;
        }

        // Token: 0x060002A2 RID: 674 RVA: 0x0003B97C File Offset: 0x0001B97C
        private static async Task CopyToAsyncCore(ValueTask copyTask)
        {
            try
            {
                await copyTask.ConfigureAwait(false);
            }
            catch (Exception ex) when (HttpContent.StreamCopyExceptionNeedsWrapping(ex))
            {
                throw HttpContent.GetStreamCopyException(ex);
            }
        }

        /// <summary>
        ///         HTTP コンテンツをバイト ストリームにシリアル化し、<paramref name="stream" /> パラメーターとして指定されたストリーム オブジェクトにコピーします。
        ///       </summary>
        /// <param name="stream">
        ///           対象のストリーム。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x060002A3 RID: 675 RVA: 0x0003B9C1 File Offset: 0x0001B9C1
        public Task CopyToAsync(Stream stream)
        {
            return this.CopyToAsync(stream, null);
        }

        /// <summary>
        ///         非同期操作として HTTP コンテンツをメモリ バッファーにシリアル化します。
        ///       </summary>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x060002A4 RID: 676 RVA: 0x0003B9CB File Offset: 0x0001B9CB
        public Task LoadIntoBufferAsync()
        {
            return this.LoadIntoBufferAsync(2147483647L);
        }

        /// <summary>
        ///         非同期操作として HTTP コンテンツをメモリ バッファーにシリアル化します。
        ///       </summary>
        /// <param name="maxBufferSize">
        ///           使用バッファーの最大サイズ (バイト単位)。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x060002A5 RID: 677 RVA: 0x0003B9D9 File Offset: 0x0001B9D9
        public Task LoadIntoBufferAsync(long maxBufferSize)
        {
            return this.LoadIntoBufferAsync(maxBufferSize, CancellationToken.None);
        }

        // Token: 0x060002A6 RID: 678 RVA: 0x0003B9E8 File Offset: 0x0001B9E8
        internal Task LoadIntoBufferAsync(long maxBufferSize, CancellationToken cancellationToken)
        {
            this.CheckDisposed();
            if (maxBufferSize > 2147483647L)
            {
                throw new ArgumentOutOfRangeException("maxBufferSize", maxBufferSize, string.Format(CultureInfo.InvariantCulture, SR.net_http_content_buffersize_limit, int.MaxValue));
            }
            if (this.IsBuffered)
            {
                return Task.CompletedTask;
            }
            Exception exception = null;
            MemoryStream memoryStream = this.CreateMemoryStream(maxBufferSize, out exception);
            if (memoryStream == null)
            {
                return Task.FromException(exception);
            }
            Task result;
            try
            {
                Task task = this.SerializeToStreamAsync(memoryStream, null, cancellationToken);
                this.CheckTaskNotNull(task);
                result = this.LoadIntoBufferAsyncCore(task, memoryStream);
            }
            catch (Exception ex) when (HttpContent.StreamCopyExceptionNeedsWrapping(ex))
            {
                result = Task.FromException(HttpContent.GetStreamCopyException(ex));
            }
            return result;
        }

        // Token: 0x060002A7 RID: 679 RVA: 0x0003BAAC File Offset: 0x0001BAAC
        private async Task LoadIntoBufferAsyncCore(Task serializeToStreamTask, MemoryStream tempBuffer)
        {
            try
            {
                await serializeToStreamTask.ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                tempBuffer.Dispose();
                Exception streamCopyException = HttpContent.GetStreamCopyException(ex);
                if (streamCopyException != ex)
                {
                    throw streamCopyException;
                }
                throw;
            }
            try
            {
                tempBuffer.Seek(0L, SeekOrigin.Begin);
                this._bufferedContent = tempBuffer;
            }
            catch (Exception message)
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(this, message, "LoadIntoBufferAsyncCore");
                }
                throw;
            }
        }

        /// <summary>
        ///         非同期操作として HTTP コンテンツをメモリ ストリームにシリアル化します。
        ///       </summary>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x060002A8 RID: 680 RVA: 0x0003BB01 File Offset: 0x0001BB01
        protected virtual Task<Stream> CreateContentReadStreamAsync()
        {
            return HttpContent.WaitAndReturnAsync<HttpContent, Stream>(this.LoadIntoBufferAsync(), this, (HttpContent s) => s._bufferedContent);
        }

        // Token: 0x060002A9 RID: 681 RVA: 0x0003BB2E File Offset: 0x0001BB2E
        internal virtual Stream TryCreateContentReadStream()
        {
            return null;
        }

        /// <summary>
        ///         HTTP コンテンツが有効なバイト長であるかどうかを判断します。
        ///       </summary>
        /// <param name="length">
        ///           HTTP コンテンツの長さ (バイト単位)。
        ///         </param>
        /// <returns>
        ///         <paramref name="length" /> が有効な長さの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x060002AA RID: 682
        protected internal abstract bool TryComputeLength(out long length);

        // Token: 0x060002AB RID: 683 RVA: 0x0003BB34 File Offset: 0x0001BB34
        internal long? GetComputedOrBufferLength()
        {
            this.CheckDisposed();
            if (this.IsBuffered)
            {
                return new long?(this._bufferedContent.Length);
            }
            if (this._canCalculateLength)
            {
                long value = 0L;
                if (this.TryComputeLength(out value))
                {
                    return new long?(value);
                }
                this._canCalculateLength = false;
            }
            return null;
        }

        // Token: 0x060002AC RID: 684 RVA: 0x0003BB8C File Offset: 0x0001BB8C
        private MemoryStream CreateMemoryStream(long maxBufferSize, out Exception error)
        {
            error = null;
            long? contentLength = this.Headers.ContentLength;
            if (contentLength == null)
            {
                return new HttpContent.LimitMemoryStream((int)maxBufferSize, 0);
            }
            if (contentLength > maxBufferSize)
            {
                error = new HttpRequestException(string.Format(CultureInfo.InvariantCulture, SR.net_http_content_buffersize_exceeded, maxBufferSize));
                return null;
            }
            return new HttpContent.LimitMemoryStream((int)maxBufferSize, (int)contentLength.Value);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpContent" /> が使用しているアンマネージ リソースを解放します。オプションとして、マネージ リソースを破棄することもできます。
        ///       </summary>
        /// <param name="disposing">
        ///           マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。
        ///         </param>
        // Token: 0x060002AD RID: 685 RVA: 0x0003BC04 File Offset: 0x0001BC04
        protected virtual void Dispose(bool disposing)
        {
            if (disposing && !this._disposed)
            {
                this._disposed = true;
                if (this._contentReadStream != null)
                {
                    Stream stream;
                    if ((stream = (this._contentReadStream as Stream)) == null)
                    {
                        Task<Stream> task;
                        stream = (((task = (this._contentReadStream as Task<Stream>)) != null && task.Status == TaskStatus.RanToCompletion) ? task.Result : null);
                    }
                    Stream stream2 = stream;
                    if (stream2 != null)
                    {
                        stream2.Dispose();
                    }
                    this._contentReadStream = null;
                }
                if (this.IsBuffered)
                {
                    this._bufferedContent.Dispose();
                }
            }
        }

        /// <summary>
        ///         リリースで使用されるアンマネージ リソースおよびマネージ リソースを破棄、 <see cref="T:System.Net.Http.HttpContent" />です。
        ///       </summary>
        // Token: 0x060002AE RID: 686 RVA: 0x0003BC7F File Offset: 0x0001BC7F
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        // Token: 0x060002AF RID: 687 RVA: 0x0003BC8E File Offset: 0x0001BC8E
        private void CheckDisposed()
        {
            if (this._disposed)
            {
                throw new ObjectDisposedException(base.GetType().ToString());
            }
        }

        // Token: 0x060002B0 RID: 688 RVA: 0x0003BCAC File Offset: 0x0001BCAC
        private void CheckTaskNotNull(Task task)
        {
            if (task == null)
            {
                InvalidOperationException ex = new InvalidOperationException(SR.net_http_content_no_task_returned);
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(this, ex, "CheckTaskNotNull");
                }
                throw ex;
            }
        }

        // Token: 0x060002B1 RID: 689 RVA: 0x0003BCDC File Offset: 0x0001BCDC
        private static bool StreamCopyExceptionNeedsWrapping(Exception e)
        {
            return e is IOException || e is ObjectDisposedException;
        }

        // Token: 0x060002B2 RID: 690 RVA: 0x0003BCF1 File Offset: 0x0001BCF1
        private static Exception GetStreamCopyException(Exception originalException)
        {
            if (!HttpContent.StreamCopyExceptionNeedsWrapping(originalException))
            {
                return originalException;
            }
            return new HttpRequestException(SR.net_http_content_stream_copy_error, originalException);
        }

        // Token: 0x060002B3 RID: 691 RVA: 0x0003BD08 File Offset: 0x0001BD08
        private static int GetPreambleLength(ArraySegment<byte> buffer, Encoding encoding)
        {
            byte[] array = buffer.Array;
            int offset = buffer.Offset;
            int count = buffer.Count;
            int codePage = encoding.CodePage;
            if (codePage <= 1201)
            {
                if (codePage != 1200)
                {
                    if (codePage == 1201)
                    {
                        if (count < 2 || array[offset] != 254 || array[offset + 1] != 255)
                        {
                            return 0;
                        }
                        return 2;
                    }
                }
                else
                {
                    if (count < 2 || array[offset] != 255 || array[offset + 1] != 254)
                    {
                        return 0;
                    }
                    return 2;
                }
            }
            else if (codePage != 12000)
            {
                if (codePage == 65001)
                {
                    if (count < 3 || array[offset] != 239 || array[offset + 1] != 187 || array[offset + 2] != 191)
                    {
                        return 0;
                    }
                    return 3;
                }
            }
            else
            {
                if (count < 4 || array[offset] != 255 || array[offset + 1] != 254 || array[offset + 2] != 0 || array[offset + 3] != 0)
                {
                    return 0;
                }
                return 4;
            }
            byte[] preamble = encoding.GetPreamble();
            if (!HttpContent.BufferHasPrefix(buffer, preamble))
            {
                return 0;
            }
            return preamble.Length;
        }

        // Token: 0x060002B4 RID: 692 RVA: 0x0003BE14 File Offset: 0x0001BE14
        private static bool TryDetectEncoding(ArraySegment<byte> buffer, out Encoding encoding, out int preambleLength)
        {
            byte[] array = buffer.Array;
            int offset = buffer.Offset;
            int count = buffer.Count;
            if (count >= 2)
            {
                int num = (int)array[offset] << 8 | (int)array[offset + 1];
                if (num != 61371)
                {
                    if (num == 65279)
                    {
                        encoding = Encoding.BigEndianUnicode;
                        preambleLength = 2;
                        return true;
                    }
                    if (num == 65534)
                    {
                        if (count >= 4 && array[offset + 2] == 0 && array[offset + 3] == 0)
                        {
                            encoding = Encoding.UTF32;
                            preambleLength = 4;
                        }
                        else
                        {
                            encoding = Encoding.Unicode;
                            preambleLength = 2;
                        }
                        return true;
                    }
                }
                else if (count >= 3 && array[offset + 2] == 191)
                {
                    encoding = Encoding.UTF8;
                    preambleLength = 3;
                    return true;
                }
            }
            encoding = null;
            preambleLength = 0;
            return false;
        }

        // Token: 0x060002B5 RID: 693 RVA: 0x0003BEBC File Offset: 0x0001BEBC
        private static bool BufferHasPrefix(ArraySegment<byte> buffer, byte[] prefix)
        {
            byte[] array = buffer.Array;
            if (prefix == null || array == null || prefix.Length > buffer.Count || prefix.Length == 0)
            {
                return false;
            }
            int i = 0;
            int num = buffer.Offset;
            while (i < prefix.Length)
            {
                if (prefix[i] != array[num])
                {
                    return false;
                }
                i++;
                num++;
            }
            return true;
        }

        // Token: 0x060002B6 RID: 694 RVA: 0x0003BF10 File Offset: 0x0001BF10
        private static async Task<TResult> WaitAndReturnAsync<TState, TResult>(Task waitTask, TState state, Func<TState, TResult> returnFunc)
        {
            await waitTask.ConfigureAwait(false);
            return returnFunc(state);
        }

        // Token: 0x060002B7 RID: 695 RVA: 0x0003BF65 File Offset: 0x0001BF65
        private static Exception CreateOverCapacityException(int maxBufferSize)
        {
            return new HttpRequestException(SR.Format(SR.net_http_content_buffersize_exceeded, maxBufferSize));
        }

        // Token: 0x0400020B RID: 523
        private HttpContentHeaders _headers;

        // Token: 0x0400020C RID: 524
        private MemoryStream _bufferedContent;

        // Token: 0x0400020D RID: 525
        private object _contentReadStream;

        // Token: 0x0400020E RID: 526
        private bool _disposed;

        // Token: 0x0400020F RID: 527
        private bool _canCalculateLength;

        // Token: 0x04000210 RID: 528
        internal static readonly Encoding DefaultStringEncoding = Encoding.UTF8;

        // Token: 0x0200007D RID: 125
        internal sealed class LimitMemoryStream : MemoryStream
        {
            // Token: 0x060002B9 RID: 697 RVA: 0x0003BF88 File Offset: 0x0001BF88
            public LimitMemoryStream(int maxSize, int capacity) : base(capacity)
            {
                this._maxSize = maxSize;
            }

            // Token: 0x060002BA RID: 698 RVA: 0x0003BF98 File Offset: 0x0001BF98
            public byte[] GetSizedBuffer()
            {
                ArraySegment<byte> arraySegment;
                if (!this.TryGetBuffer(out arraySegment) || arraySegment.Offset != 0 || arraySegment.Count != arraySegment.Array.Length)
                {
                    return this.ToArray();
                }
                return arraySegment.Array;
            }

            // Token: 0x060002BB RID: 699 RVA: 0x0003BFD8 File Offset: 0x0001BFD8
            public override void Write(byte[] buffer, int offset, int count)
            {
                this.CheckSize(count);
                base.Write(buffer, offset, count);
            }

            // Token: 0x060002BC RID: 700 RVA: 0x0003BFEA File Offset: 0x0001BFEA
            public override void WriteByte(byte value)
            {
                this.CheckSize(1);
                base.WriteByte(value);
            }

            // Token: 0x060002BD RID: 701 RVA: 0x0003BFFA File Offset: 0x0001BFFA
            public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
            {
                this.CheckSize(count);
                return base.WriteAsync(buffer, offset, count, cancellationToken);
            }

            // Token: 0x060002BE RID: 702 RVA: 0x0003C00E File Offset: 0x0001C00E
            public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken)
            {
                this.CheckSize(buffer.Length);
                return base.WriteAsync(buffer, cancellationToken);
            }

            // Token: 0x060002BF RID: 703 RVA: 0x0003C025 File Offset: 0x0001C025
            public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
            {
                this.CheckSize(count);
                return base.BeginWrite(buffer, offset, count, callback, state);
            }

            // Token: 0x060002C0 RID: 704 RVA: 0x0003C03B File Offset: 0x0001C03B
            public override void EndWrite(IAsyncResult asyncResult)
            {
                base.EndWrite(asyncResult);
            }

            // Token: 0x060002C1 RID: 705 RVA: 0x0003C044 File Offset: 0x0001C044
            public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
            {
                ArraySegment<byte> arraySegment;
                if (this.TryGetBuffer(out arraySegment))
                {
                    StreamHelpers.ValidateCopyToArgs(this, destination, bufferSize);
                    long position = this.Position;
                    long length = this.Length;
                    this.Position = length;
                    long num = length - position;
                    return destination.WriteAsync(arraySegment.Array, (int)((long)arraySegment.Offset + position), (int)num, cancellationToken);
                }
                return base.CopyToAsync(destination, bufferSize, cancellationToken);
            }

            // Token: 0x060002C2 RID: 706 RVA: 0x0003C0A1 File Offset: 0x0001C0A1
            private void CheckSize(int countToAdd)
            {
                if ((long)this._maxSize - this.Length < (long)countToAdd)
                {
                    throw HttpContent.CreateOverCapacityException(this._maxSize);
                }
            }

            // Token: 0x04000211 RID: 529
            private readonly int _maxSize;
        }

        // Token: 0x0200007E RID: 126
        internal sealed class LimitArrayPoolWriteStream : Stream
        {
            // Token: 0x060002C3 RID: 707 RVA: 0x0003C0C1 File Offset: 0x0001C0C1
            public LimitArrayPoolWriteStream(int maxBufferSize) : this(maxBufferSize, 256L)
            {
            }

            // Token: 0x060002C4 RID: 708 RVA: 0x0003C0D0 File Offset: 0x0001C0D0
            public LimitArrayPoolWriteStream(int maxBufferSize, long capacity)
            {
                if (capacity < 256L)
                {
                    capacity = 256L;
                }
                else if (capacity > (long)maxBufferSize)
                {
                    throw HttpContent.CreateOverCapacityException(maxBufferSize);
                }
                this._maxBufferSize = maxBufferSize;
                this._buffer = ArrayPool<byte>.Shared.Rent((int)capacity);
            }

            // Token: 0x060002C5 RID: 709 RVA: 0x0003C110 File Offset: 0x0001C110
            protected override void Dispose(bool disposing)
            {
                ArrayPool<byte>.Shared.Return(this._buffer, false);
                this._buffer = null;
                base.Dispose(disposing);
            }

            // Token: 0x060002C6 RID: 710 RVA: 0x0003C131 File Offset: 0x0001C131
            public ArraySegment<byte> GetBuffer()
            {
                return new ArraySegment<byte>(this._buffer, 0, this._length);
            }

            // Token: 0x060002C7 RID: 711 RVA: 0x0003C148 File Offset: 0x0001C148
            public byte[] ToArray()
            {
                byte[] array = new byte[this._length];
                Buffer.BlockCopy(this._buffer, 0, array, 0, this._length);
                return array;
            }

            // Token: 0x060002C8 RID: 712 RVA: 0x0003C176 File Offset: 0x0001C176
            private void EnsureCapacity(int value)
            {
                if (value > this._maxBufferSize)
                {
                    throw HttpContent.CreateOverCapacityException(this._maxBufferSize);
                }
                if (value > this._buffer.Length)
                {
                    this.Grow(value);
                }
            }

            // Token: 0x060002C9 RID: 713 RVA: 0x0003C1A0 File Offset: 0x0001C1A0
            private void Grow(int value)
            {
                byte[] buffer = this._buffer;
                this._buffer = null;
                uint num = (uint)(2 * buffer.Length);
                int minimumLength = (num > 2147483591u) ? ((value > 2147483591) ? value : 2147483591) : Math.Max(value, (int)num);
                byte[] array = ArrayPool<byte>.Shared.Rent(minimumLength);
                Buffer.BlockCopy(buffer, 0, array, 0, this._length);
                ArrayPool<byte>.Shared.Return(buffer, false);
                this._buffer = array;
            }

            // Token: 0x060002CA RID: 714 RVA: 0x0003C211 File Offset: 0x0001C211
            public override void Write(byte[] buffer, int offset, int count)
            {
                this.EnsureCapacity(this._length + count);
                Buffer.BlockCopy(buffer, offset, this._buffer, this._length, count);
                this._length += count;
            }

            // Token: 0x060002CB RID: 715 RVA: 0x0003C244 File Offset: 0x0001C244
            public override void Write(ReadOnlySpan<byte> buffer)
            {
                this.EnsureCapacity(this._length + buffer.Length);
                buffer.CopyTo(new Span<byte>(this._buffer, this._length, buffer.Length));
                this._length += buffer.Length;
            }

            // Token: 0x060002CC RID: 716 RVA: 0x0003C298 File Offset: 0x0001C298
            public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
            {
                this.Write(buffer, offset, count);
                return Task.CompletedTask;
            }

            // Token: 0x060002CD RID: 717 RVA: 0x0003C2A8 File Offset: 0x0001C2A8
            public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken))
            {
                this.Write(buffer.Span);
                return default(ValueTask);
            }

            // Token: 0x060002CE RID: 718 RVA: 0x0003C2CB File Offset: 0x0001C2CB
            public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
            {
                return TaskToApm.Begin(this.WriteAsync(buffer, offset, count, CancellationToken.None), asyncCallback, asyncState);
            }

            // Token: 0x060002CF RID: 719 RVA: 0x0003C2E4 File Offset: 0x0001C2E4
            public override void EndWrite(IAsyncResult asyncResult)
            {
                TaskToApm.End(asyncResult);
            }

            // Token: 0x060002D0 RID: 720 RVA: 0x0003C2EC File Offset: 0x0001C2EC
            public override void WriteByte(byte value)
            {
                int num = this._length + 1;
                this.EnsureCapacity(num);
                this._buffer[this._length] = value;
                this._length = num;
            }

            // Token: 0x060002D1 RID: 721 RVA: 0x00034ED8 File Offset: 0x00014ED8
            public override void Flush()
            {
            }

            // Token: 0x060002D2 RID: 722 RVA: 0x0003634A File Offset: 0x0001634A
            public override Task FlushAsync(CancellationToken cancellationToken)
            {
                return Task.CompletedTask;
            }

            // Token: 0x170000AE RID: 174
            // (get) Token: 0x060002D3 RID: 723 RVA: 0x0003C31E File Offset: 0x0001C31E
            public override long Length
            {
                get
                {
                    return (long)this._length;
                }
            }

            // Token: 0x170000AF RID: 175
            // (get) Token: 0x060002D4 RID: 724 RVA: 0x0003607C File Offset: 0x0001607C
            public override bool CanWrite
            {
                get
                {
                    return true;
                }
            }

            // Token: 0x170000B0 RID: 176
            // (get) Token: 0x060002D5 RID: 725 RVA: 0x000356C2 File Offset: 0x000156C2
            public override bool CanRead
            {
                get
                {
                    return false;
                }
            }

            // Token: 0x170000B1 RID: 177
            // (get) Token: 0x060002D6 RID: 726 RVA: 0x000356C2 File Offset: 0x000156C2
            public override bool CanSeek
            {
                get
                {
                    return false;
                }
            }

            // Token: 0x170000B2 RID: 178
            // (get) Token: 0x060002D7 RID: 727 RVA: 0x00036351 File Offset: 0x00016351
            // (set) Token: 0x060002D8 RID: 728 RVA: 0x00036351 File Offset: 0x00016351
            public override long Position
            {
                get
                {
                    throw new NotSupportedException();
                }
                set
                {
                    throw new NotSupportedException();
                }
            }

            // Token: 0x060002D9 RID: 729 RVA: 0x00036351 File Offset: 0x00016351
            public override int Read(byte[] buffer, int offset, int count)
            {
                throw new NotSupportedException();
            }

            // Token: 0x060002DA RID: 730 RVA: 0x00036351 File Offset: 0x00016351
            public override long Seek(long offset, SeekOrigin origin)
            {
                throw new NotSupportedException();
            }

            // Token: 0x060002DB RID: 731 RVA: 0x00036351 File Offset: 0x00016351
            public override void SetLength(long value)
            {
                throw new NotSupportedException();
            }

            // Token: 0x04000212 RID: 530
            private readonly int _maxBufferSize;

            // Token: 0x04000213 RID: 531
            private byte[] _buffer;

            // Token: 0x04000214 RID: 532
            private int _length;
        }
    }


    // Token: 0x020000F7 RID: 247
    internal abstract class HttpContentDuplexStream : HttpContentStream
    {
        // Token: 0x0600056D RID: 1389 RVA: 0x0004B75D File Offset: 0x0002B75D
        public HttpContentDuplexStream(HttpConnection connection) : base(connection)
        {
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Info(this, null, ".ctor");
            }
        }

        // Token: 0x17000100 RID: 256
        // (get) Token: 0x0600056E RID: 1390 RVA: 0x0003607C File Offset: 0x0001607C
        public sealed override bool CanRead
        {
            get
            {
                return true;
            }
        }

        // Token: 0x17000101 RID: 257
        // (get) Token: 0x0600056F RID: 1391 RVA: 0x0003607C File Offset: 0x0001607C
        public sealed override bool CanWrite
        {
            get
            {
                return true;
            }
        }

        // Token: 0x06000570 RID: 1392 RVA: 0x0004B77C File Offset: 0x0002B77C
        public sealed override void Flush()
        {
            base.FlushAsync().GetAwaiter().GetResult();
        }

        // Token: 0x06000571 RID: 1393 RVA: 0x0004B79C File Offset: 0x0002B79C
        public sealed override int Read(byte[] buffer, int offset, int count)
        {
            HttpContentStream.ValidateBufferArgs(buffer, offset, count);
            return this.ReadAsync(new Memory<byte>(buffer, offset, count), CancellationToken.None).GetAwaiter().GetResult();
        }

        // Token: 0x06000572 RID: 1394 RVA: 0x0004B7D4 File Offset: 0x0002B7D4
        public sealed override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            HttpContentStream.ValidateBufferArgs(buffer, offset, count);
            return this.ReadAsync(new Memory<byte>(buffer, offset, count), cancellationToken).AsTask();
        }

        // Token: 0x06000573 RID: 1395 RVA: 0x0004B804 File Offset: 0x0002B804
        public sealed override void Write(byte[] buffer, int offset, int count)
        {
            HttpContentStream.ValidateBufferArgs(buffer, offset, count);
            this.WriteAsync(new Memory<byte>(buffer, offset, count), CancellationToken.None).GetAwaiter().GetResult();
        }

        // Token: 0x06000574 RID: 1396 RVA: 0x0004B844 File Offset: 0x0002B844
        public sealed override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            HttpContentStream.ValidateBufferArgs(buffer, offset, count);
            return this.WriteAsync(new ReadOnlyMemory<byte>(buffer, offset, count), cancellationToken).AsTask();
        }

        // Token: 0x06000575 RID: 1397 RVA: 0x0004B874 File Offset: 0x0002B874
        public sealed override void CopyTo(Stream destination, int bufferSize)
        {
            this.CopyToAsync(destination, bufferSize, CancellationToken.None).GetAwaiter().GetResult();
        }
    }


    // Token: 0x020000F8 RID: 248
    internal abstract class HttpContentStream : Stream
    {
        // Token: 0x06000576 RID: 1398 RVA: 0x0004B89B File Offset: 0x0002B89B
        public HttpContentStream(HttpConnection connection)
        {
            this._connection = connection;
        }

        // Token: 0x06000577 RID: 1399 RVA: 0x0004B8AA File Offset: 0x0002B8AA
        protected override void Dispose(bool disposing)
        {
            if (disposing && this._connection != null)
            {
                this._connection.Dispose();
                this._connection = null;
            }
            base.Dispose(disposing);
        }

        // Token: 0x17000102 RID: 258
        // (get) Token: 0x06000578 RID: 1400 RVA: 0x000356C2 File Offset: 0x000156C2
        public sealed override bool CanSeek
        {
            get
            {
                return false;
            }
        }

        // Token: 0x06000579 RID: 1401 RVA: 0x0004B8D0 File Offset: 0x0002B8D0
        public sealed override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return TaskToApm.Begin(this.ReadAsync(buffer, offset, count, default(CancellationToken)), callback, state);
        }

        // Token: 0x0600057A RID: 1402 RVA: 0x000362A9 File Offset: 0x000162A9
        public sealed override int EndRead(IAsyncResult asyncResult)
        {
            return TaskToApm.End<int>(asyncResult);
        }

        // Token: 0x0600057B RID: 1403 RVA: 0x0004B8F8 File Offset: 0x0002B8F8
        public sealed override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return TaskToApm.Begin(this.WriteAsync(buffer, offset, count, default(CancellationToken)), callback, state);
        }

        // Token: 0x0600057C RID: 1404 RVA: 0x0003C2E4 File Offset: 0x0001C2E4
        public sealed override void EndWrite(IAsyncResult asyncResult)
        {
            TaskToApm.End(asyncResult);
        }

        // Token: 0x0600057D RID: 1405 RVA: 0x00036351 File Offset: 0x00016351
        public sealed override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException();
        }

        // Token: 0x0600057E RID: 1406 RVA: 0x00036351 File Offset: 0x00016351
        public sealed override void SetLength(long value)
        {
            throw new NotSupportedException();
        }

        // Token: 0x17000103 RID: 259
        // (get) Token: 0x0600057F RID: 1407 RVA: 0x00036351 File Offset: 0x00016351
        public sealed override long Length
        {
            get
            {
                throw new NotSupportedException();
            }
        }

        // Token: 0x17000104 RID: 260
        // (get) Token: 0x06000580 RID: 1408 RVA: 0x00036351 File Offset: 0x00016351
        // (set) Token: 0x06000581 RID: 1409 RVA: 0x00036351 File Offset: 0x00016351
        public sealed override long Position
        {
            get
            {
                throw new NotSupportedException();
            }
            set
            {
                throw new NotSupportedException();
            }
        }

        // Token: 0x06000582 RID: 1410 RVA: 0x0004B920 File Offset: 0x0002B920
        protected static void ValidateBufferArgs(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }
            if ((ulong)offset > (ulong)((long)buffer.Length))
            {
                throw new ArgumentOutOfRangeException("offset");
            }
            if ((ulong)count > (ulong)((long)(buffer.Length - offset)))
            {
                throw new ArgumentOutOfRangeException("count");
            }
        }

        // Token: 0x06000583 RID: 1411 RVA: 0x0004B958 File Offset: 0x0002B958
        protected static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize)
        {
            if (destination == null)
            {
                throw new ArgumentNullException("destination");
            }
            if (bufferSize <= 0)
            {
                throw new ArgumentOutOfRangeException("bufferSize", bufferSize, SR.ArgumentOutOfRange_NeedPosNum);
            }
            if (!destination.CanWrite)
            {
                throw destination.CanRead ? (Exception)new NotSupportedException(SR.NotSupported_UnwritableStream) : new ObjectDisposedException("destination", SR.ObjectDisposed_StreamClosed);
            }
        }

        // Token: 0x0400046D RID: 1133
        protected HttpConnection _connection;
    }

    // Token: 0x020000FE RID: 254
    internal sealed class HttpEnvironmentProxy : IWebProxy
    {
        // Token: 0x060005BE RID: 1470 RVA: 0x0004C628 File Offset: 0x0002C628
        public static bool TryCreate(out IWebProxy proxy)
        {
            Uri uri = HttpEnvironmentProxy.GetUriFromString(Environment.GetEnvironmentVariable("http_proxy"));
            Uri uri2 = HttpEnvironmentProxy.GetUriFromString(Environment.GetEnvironmentVariable("https_proxy")) ?? HttpEnvironmentProxy.GetUriFromString(Environment.GetEnvironmentVariable("HTTPS_PROXY"));
            if (uri == null || uri2 == null)
            {
                Uri uri3 = HttpEnvironmentProxy.GetUriFromString(Environment.GetEnvironmentVariable("all_proxy")) ?? HttpEnvironmentProxy.GetUriFromString(Environment.GetEnvironmentVariable("ALL_PROXY"));
                if (uri == null)
                {
                    uri = uri3;
                }
                if (uri2 == null)
                {
                    uri2 = uri3;
                }
            }
            if (uri == null && uri2 == null)
            {
                proxy = null;
                return false;
            }
            proxy = new HttpEnvironmentProxy(uri, uri2, Environment.GetEnvironmentVariable("no_proxy"));
            return true;
        }

        // Token: 0x060005BF RID: 1471 RVA: 0x0004C6E0 File Offset: 0x0002C6E0
        private HttpEnvironmentProxy(Uri httpProxy, Uri httpsProxy, string bypassList)
        {
            this._httpProxyUri = httpProxy;
            this._httpsProxyUri = httpsProxy;
            this._credentials = HttpEnvironmentProxyCredentials.TryCreate(httpProxy, httpsProxy);
            if (!string.IsNullOrWhiteSpace(bypassList))
            {
                string[] array = bypassList.Split(',', StringSplitOptions.None);
                List<string> list = new List<string>(array.Length);
                foreach (string text in array)
                {
                    string text2 = text.Trim();
                    if (text2.Length > 0)
                    {
                        list.Add(text2);
                    }
                }
                if (list.Count > 0)
                {
                    this._bypass = list.ToArray();
                }
            }
        }

        // Token: 0x060005C0 RID: 1472 RVA: 0x0004C770 File Offset: 0x0002C770
        private static Uri GetUriFromString(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return null;
            }
            if (value.StartsWith("http://", StringComparison.OrdinalIgnoreCase))
            {
                value = value.Substring(7);
            }
            string text = null;
            string text2 = null;
            ushort portNumber = 80;
            int num = value.LastIndexOf('@');
            if (num != -1)
            {
                string text3 = value.Substring(0, num);
                try
                {
                    text3 = Uri.UnescapeDataString(text3);
                }
                catch
                {
                }
                value = value.Substring(num + 1);
                num = text3.IndexOf(':');
                if (num == -1)
                {
                    text = text3;
                }
                else
                {
                    text = text3.Substring(0, num);
                    text2 = text3.Substring(num + 1);
                }
            }
            int num2 = value.IndexOf(']');
            num = value.LastIndexOf(':');
            string host;
            if (num == -1 || (num2 != -1 && num < num2))
            {
                host = value;
            }
            else
            {
                host = value.Substring(0, num);
                int num3 = num + 1;
                while (num3 < value.Length && char.IsDigit(value[num3]))
                {
                    num3++;
                }
                if (!ushort.TryParse(value.AsSpan(num + 1, num3 - num - 1), out portNumber))
                {
                    return null;
                }
            }
            try
            {
                UriBuilder uriBuilder = new UriBuilder("http", host, (int)portNumber);
                if (text != null)
                {
                    uriBuilder.UserName = Uri.EscapeDataString(text);
                }
                if (text2 != null)
                {
                    uriBuilder.Password = Uri.EscapeDataString(text2);
                }
                return uriBuilder.Uri;
            }
            catch
            {
            }
            return null;
        }

        // Token: 0x060005C1 RID: 1473 RVA: 0x0004C8DC File Offset: 0x0002C8DC
        private bool IsMatchInBypassList(Uri input)
        {
            if (this._bypass != null)
            {
                foreach (string text in this._bypass)
                {
                    if (text[0] == '.')
                    {
                        if (text.Length - 1 == input.Host.Length && string.Compare(text, 1, input.Host, 0, input.Host.Length, StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return true;
                        }
                        if (input.Host.EndsWith(text, StringComparison.OrdinalIgnoreCase))
                        {
                            return true;
                        }
                    }
                    else if (string.Equals(text, input.Host, StringComparison.OrdinalIgnoreCase))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        // Token: 0x060005C2 RID: 1474 RVA: 0x0004C96B File Offset: 0x0002C96B
        public Uri GetProxy(Uri uri)
        {
            if (!(uri.Scheme == Uri.UriSchemeHttp))
            {
                return this._httpsProxyUri;
            }
            return this._httpProxyUri;
        }

        // Token: 0x060005C3 RID: 1475 RVA: 0x0004C98C File Offset: 0x0002C98C
        public bool IsBypassed(Uri uri)
        {
            return this.GetProxy(uri) == null || this.IsMatchInBypassList(uri);
        }

        // Token: 0x17000119 RID: 281
        // (get) Token: 0x060005C4 RID: 1476 RVA: 0x0004C9A6 File Offset: 0x0002C9A6
        // (set) Token: 0x060005C5 RID: 1477 RVA: 0x00036351 File Offset: 0x00016351
        public ICredentials Credentials
        {
            get
            {
                return this._credentials;
            }
            set
            {
                throw new NotSupportedException();
            }
        }

        // Token: 0x0400047F RID: 1151
        private Uri _httpProxyUri;

        // Token: 0x04000480 RID: 1152
        private Uri _httpsProxyUri;

        // Token: 0x04000481 RID: 1153
        private string[] _bypass;

        // Token: 0x04000482 RID: 1154
        private ICredentials _credentials;
    }


    // Token: 0x020000FD RID: 253
    internal sealed class HttpEnvironmentProxyCredentials : ICredentials
    {
        // Token: 0x060005BA RID: 1466 RVA: 0x0004C509 File Offset: 0x0002C509
        public HttpEnvironmentProxyCredentials(Uri httpProxy, NetworkCredential httpCred, Uri httpsProxy, NetworkCredential httpsCred)
        {
            this._httpCred = httpCred;
            this._httpsCred = httpsCred;
            this._httpProxy = httpProxy;
            this._httpsProxy = httpsProxy;
        }

        // Token: 0x060005BB RID: 1467 RVA: 0x0004C52E File Offset: 0x0002C52E
        public NetworkCredential GetCredential(Uri uri, string authType)
        {
            if (uri == null)
            {
                return null;
            }
            if (uri.Equals(this._httpProxy))
            {
                return this._httpCred;
            }
            if (!uri.Equals(this._httpsProxy))
            {
                return null;
            }
            return this._httpsCred;
        }

        // Token: 0x060005BC RID: 1468 RVA: 0x0004C568 File Offset: 0x0002C568
        public static HttpEnvironmentProxyCredentials TryCreate(Uri httpProxy, Uri httpsProxy)
        {
            NetworkCredential networkCredential = null;
            NetworkCredential networkCredential2 = null;
            if (httpProxy != null)
            {
                networkCredential = HttpEnvironmentProxyCredentials.GetCredentialsFromString(httpProxy.UserInfo);
            }
            if (httpsProxy != null)
            {
                networkCredential2 = HttpEnvironmentProxyCredentials.GetCredentialsFromString(httpsProxy.UserInfo);
            }
            if (networkCredential == null && networkCredential2 == null)
            {
                return null;
            }
            return new HttpEnvironmentProxyCredentials(httpProxy, networkCredential, httpsProxy, networkCredential2);
        }

        // Token: 0x060005BD RID: 1469 RVA: 0x0004C5B4 File Offset: 0x0002C5B4
        private static NetworkCredential GetCredentialsFromString(string value)
        {
            if (string.IsNullOrWhiteSpace(value))
            {
                return null;
            }
            value = Uri.UnescapeDataString(value);
            string password = "";
            string domain = null;
            int num = value.IndexOf(':');
            if (num != -1)
            {
                password = value.Substring(num + 1);
                value = value.Substring(0, num);
            }
            num = value.IndexOf('\\');
            if (num != -1)
            {
                domain = value.Substring(0, num);
                value = value.Substring(num + 1);
            }
            return new NetworkCredential(value, password, domain);
        }

        // Token: 0x0400047B RID: 1147
        private readonly NetworkCredential _httpCred;

        // Token: 0x0400047C RID: 1148
        private readonly NetworkCredential _httpsCred;

        // Token: 0x0400047D RID: 1149
        private readonly Uri _httpProxy;

        // Token: 0x0400047E RID: 1150
        private readonly Uri _httpsProxy;
    }


    // Token: 0x02000114 RID: 276
    internal static class HttpHandlerDefaults
    {
        // Token: 0x040004FC RID: 1276
        public static readonly TimeSpan DefaultResponseDrainTimeout = TimeSpan.FromSeconds(2.0);

        // Token: 0x040004FD RID: 1277
        public static readonly TimeSpan DefaultPooledConnectionLifetime = Timeout.InfiniteTimeSpan;

        // Token: 0x040004FE RID: 1278
        public static readonly TimeSpan DefaultPooledConnectionIdleTimeout = TimeSpan.FromMinutes(2.0);

        // Token: 0x040004FF RID: 1279
        public static readonly TimeSpan DefaultExpect100ContinueTimeout = TimeSpan.FromSeconds(1.0);

        // Token: 0x04000500 RID: 1280
        public static readonly TimeSpan DefaultConnectTimeout = Timeout.InfiniteTimeSpan;
    }

    /// <summary>
    ///         HTTP メッセージ ハンドラーの基本データ型。
    ///       </summary>
    // Token: 0x02000083 RID: 131
    abstract class HttpMessageHandler : IDisposable
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpMessageHandler" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        // Token: 0x060002E7 RID: 743 RVA: 0x0003C662 File Offset: 0x0001C662
        protected HttpMessageHandler()
        {
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Info(this, null, ".ctor");
            }
        }

        /// <summary>
        ///         非同期操作として HTTP 要求を送信します。
        ///       </summary>
        /// <param name="request">
        ///           送信する HTTP 要求メッセージ。
        ///         </param>
        /// <param name="cancellationToken">
        ///           操作をキャンセルするキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="request" /> が <see langword="null" />でした。
        ///           </exception>
        // Token: 0x060002E8 RID: 744
        protected internal abstract Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);

        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpMessageHandler" /> が使用しているアンマネージ リソースを解放します。オプションとして、マネージ リソースを破棄することもできます。
        ///       </summary>
        /// <param name="disposing">
        ///           マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。
        ///         </param>
        // Token: 0x060002E9 RID: 745 RVA: 0x00034ED8 File Offset: 0x00014ED8
        protected virtual void Dispose(bool disposing)
        {
        }

        /// <summary>
        ///         リリースで使用されるアンマネージ リソースおよびマネージ リソースを破棄、 <see cref="T:System.Net.Http.HttpMessageHandler" />です。
        ///       </summary>
        // Token: 0x060002EA RID: 746 RVA: 0x0003C67D File Offset: 0x0001C67D
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }
    }


    /// <summary>
    ///         呼び出すアプリケーションを使用する特別なクラス、 <see cref="M:System.Net.Http.HttpMessageInvoker.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)" /> Http ハンドラー チェーン上のメソッドです。
    ///       </summary>
    // Token: 0x02000084 RID: 132
    class HttpMessageInvoker : IDisposable
    {
        /// <summary>
        ///         インスタンスを初期化、 <see cref="T:System.Net.Http.HttpMessageInvoker" /> 、特定のクラス <see cref="T:System.Net.Http.HttpMessageHandler" />します。
        ///       </summary>
        /// <param name="handler">
        ///           HTTP 応答メッセージの処理を行う <see cref="T:System.Net.Http.HttpMessageHandler" />。
        ///         </param>
        // Token: 0x060002EB RID: 747 RVA: 0x0003C68C File Offset: 0x0001C68C
        public HttpMessageInvoker(HttpMessageHandler handler) : this(handler, true)
        {
        }

        /// <summary>
        ///         インスタンスを初期化、 <see cref="T:System.Net.Http.HttpMessageInvoker" /> 、特定のクラス <see cref="T:System.Net.Http.HttpMessageHandler" />します。
        ///       </summary>
        /// <param name="handler">
        ///           HTTP 応答メッセージの処理を行う <see cref="T:System.Net.Http.HttpMessageHandler" />。
        ///         </param>
        /// <param name="disposeHandler">
        ///           内部ハンドラーを Dispose() で破棄する場合は <see langword="true" />。内部ハンドラーを再利用する場合は <see langword="false" />。
        ///         </param>
        // Token: 0x060002EC RID: 748 RVA: 0x0003C698 File Offset: 0x0001C698
        public HttpMessageInvoker(HttpMessageHandler handler, bool disposeHandler)
        {
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Enter(this, handler, ".ctor");
            }
            if (handler == null)
            {
                throw new ArgumentNullException("handler");
            }
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Associate(this, handler, ".ctor");
            }
            this._handler = handler;
            this._disposeHandler = disposeHandler;
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Exit(this, null, ".ctor");
            }
        }

        /// <summary>
        ///         非同期操作として HTTP 要求を送信します。
        ///       </summary>
        /// <param name="request">
        ///           送信する HTTP 要求メッセージ。
        ///         </param>
        /// <param name="cancellationToken">
        ///           操作をキャンセルするキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="request" /> が <see langword="null" />でした。
        ///           </exception>
        // Token: 0x060002ED RID: 749 RVA: 0x0003C700 File Offset: 0x0001C700
        public virtual Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            this.CheckDisposed();
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Enter(this, request, "SendAsync");
            }
            Task<HttpResponseMessage> task = this._handler.SendAsync(request, cancellationToken);
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Exit(this, task, "SendAsync");
            }
            return task;
        }

        /// <summary>
        ///         リリースで使用されるアンマネージ リソースおよびマネージ リソースを破棄、 <see cref="T:System.Net.Http.HttpMessageInvoker" />です。
        ///       </summary>
        // Token: 0x060002EE RID: 750 RVA: 0x0003C756 File Offset: 0x0001C756
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpMessageInvoker" /> が使用しているアンマネージ リソースを解放します。オプションとして、マネージ リソースを破棄することもできます。
        ///       </summary>
        /// <param name="disposing">
        ///           マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。
        ///         </param>
        // Token: 0x060002EF RID: 751 RVA: 0x0003C765 File Offset: 0x0001C765
        protected virtual void Dispose(bool disposing)
        {
            if (disposing && !this._disposed)
            {
                this._disposed = true;
                if (this._disposeHandler)
                {
                    this._handler.Dispose();
                }
            }
        }

        // Token: 0x060002F0 RID: 752 RVA: 0x0003C790 File Offset: 0x0001C790
        private void CheckDisposed()
        {
            if (this._disposed)
            {
                throw new ObjectDisposedException(base.GetType().ToString());
            }
        }

        // Token: 0x04000229 RID: 553
        private volatile bool _disposed;

        // Token: 0x0400022A RID: 554
        private bool _disposeHandler;

        // Token: 0x0400022B RID: 555
        private HttpMessageHandler _handler;
    }


    class HttpMethod : IEquatable<HttpMethod>
    {
        private readonly string _method;
        private int _hashcode;

        private static readonly HttpMethod s_getMethod = new HttpMethod("GET");
        private static readonly HttpMethod s_putMethod = new HttpMethod("PUT");
        private static readonly HttpMethod s_postMethod = new HttpMethod("POST");
        private static readonly HttpMethod s_deleteMethod = new HttpMethod("DELETE");
        private static readonly HttpMethod s_headMethod = new HttpMethod("HEAD");
        private static readonly HttpMethod s_optionsMethod = new HttpMethod("OPTIONS");
        private static readonly HttpMethod s_traceMethod = new HttpMethod("TRACE");
        private static readonly HttpMethod s_patchMethod = new HttpMethod("PATCH");
        private static readonly HttpMethod s_connectMethod = new HttpMethod("CONNECT");

        private static readonly Dictionary<HttpMethod, HttpMethod> s_knownMethods = new Dictionary<HttpMethod, HttpMethod>(9)
        {
            { s_getMethod, s_getMethod },
            { s_putMethod, s_putMethod },
            { s_postMethod, s_postMethod },
            { s_deleteMethod, s_deleteMethod },
            { s_headMethod, s_headMethod },
            { s_optionsMethod, s_optionsMethod },
            { s_traceMethod, s_traceMethod },
            { s_patchMethod, s_patchMethod },
            { s_connectMethod, s_connectMethod },
        };

        public static HttpMethod Get
        {
            get { return s_getMethod; }
        }

        public static HttpMethod Put
        {
            get { return s_putMethod; }
        }

        public static HttpMethod Post
        {
            get { return s_postMethod; }
        }

        public static HttpMethod Delete
        {
            get { return s_deleteMethod; }
        }

        public static HttpMethod Head
        {
            get { return s_headMethod; }
        }

        public static HttpMethod Options
        {
            get { return s_optionsMethod; }
        }

        public static HttpMethod Trace
        {
            get { return s_traceMethod; }
        }

        public static HttpMethod Patch
        {
            get { return s_patchMethod; }
        }

        // Don't expose CONNECT as static property, since it's used by the transport to connect to a proxy.
        // CONNECT is not used by users directly.

        internal static HttpMethod Connect
        {
            get { return s_connectMethod; }
        }

        public string Method
        {
            get { return _method; }
        }

        public HttpMethod(string method)
        {
            if (string.IsNullOrEmpty(method))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, nameof(method));
            }
            if (HttpRuleParser.GetTokenLength(method, 0) != method.Length)
            {
                throw new FormatException(SR.net_http_httpmethod_format_error);
            }

            _method = method;
        }

        #region IEquatable<HttpMethod> Members

        public bool Equals(HttpMethod other)
        {
            if ((object)other == null)
            {
                return false;
            }

            if (object.ReferenceEquals(_method, other._method))
            {
                // Strings are static, so there is a good chance that two equal methods use the same reference
                // (unless they differ in case).
                return true;
            }

            return string.Equals(_method, other._method, StringComparison.OrdinalIgnoreCase);
        }

        #endregion

        public override bool Equals(object obj)
        {
            return Equals(obj as HttpMethod);
        }

        public override int GetHashCode()
        {
            if (_hashcode == 0)
            {
                _hashcode = StringComparer.OrdinalIgnoreCase.GetHashCode(_method);
            }

            return _hashcode;
        }

        public override string ToString()
        {
            return _method;
        }

        public static bool operator ==(HttpMethod left, HttpMethod right)
        {
            return (object)left == null || (object)right == null ?
                ReferenceEquals(left, right) :
                left.Equals(right);
        }

        public static bool operator !=(HttpMethod left, HttpMethod right)
        {
            return !(left == right);
        }

        /// <summary>
        /// Returns a singleton method instance with a capitalized method name for the supplied method
        /// if it's known; otherwise, returns the original.
        /// </summary>
        internal static HttpMethod Normalize(HttpMethod method)
        {
            Debug.Assert(method != null);
            return s_knownMethods.TryGetValue(method, out HttpMethod normalized) ?
                normalized :
                method;
        }

        internal bool MustHaveRequestBody
        {
            get
            {
                // Normalize before calling this
                Debug.Assert(ReferenceEquals(this, Normalize(this)));

                return !ReferenceEquals(this, HttpMethod.Get) && !ReferenceEquals(this, HttpMethod.Head) && !ReferenceEquals(this, HttpMethod.Connect) &&
                       !ReferenceEquals(this, HttpMethod.Options) && !ReferenceEquals(this, HttpMethod.Delete);
            }
        }
    }

    // Token: 0x02000086 RID: 134
    internal enum HttpParseResult
    {
        // Token: 0x04000239 RID: 569
        Parsed,
        // Token: 0x0400023A RID: 570
        NotParsed,
        // Token: 0x0400023B RID: 571
        InvalidFormat
    }


    /// <summary>
    ///         によってスローされた例外の基底クラス、 <see cref="T:System.Net.Http.HttpClient" /> と <see cref="T:System.Net.Http.HttpMessageHandler" /> クラスです。
    ///       </summary>
    // Token: 0x02000087 RID: 135
    class HttpRequestException : Exception
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpRequestException" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        // Token: 0x06000304 RID: 772 RVA: 0x0003CA10 File Offset: 0x0001CA10
        public HttpRequestException() : this(null, null)
        {
        }

        /// <summary>
        ///         新しいインスタンスを初期化、<see cref="T:System.Net.Http.HttpRequestException" />現在例外を説明する特定のメッセージを持つクラス。
        ///       </summary>
        /// <param name="message">
        ///           現在の例外を説明するメッセージ。
        ///         </param>
        // Token: 0x06000305 RID: 773 RVA: 0x0003CA1A File Offset: 0x0001CA1A
        public HttpRequestException(string message) : this(message, null)
        {
        }

        /// <summary>
        ///         新しいインスタンスを初期化、 <see cref="T:System.Net.Http.HttpRequestException" /> 現在の例外と内部例外を説明する特定のメッセージを使用します。
        ///       </summary>
        /// <param name="message">
        ///           現在の例外を説明するメッセージ。
        ///         </param>
        /// <param name="inner">
        ///           内部例外。
        ///         </param>
        // Token: 0x06000306 RID: 774 RVA: 0x0003CA24 File Offset: 0x0001CA24
        public HttpRequestException(string message, Exception inner) : base(message, inner)
        {
            if (inner != null)
            {
                base.HResult = inner.HResult;
            }
        }
    }

    /// <summary>
    ///         HTTP 要求メッセージを表します。
    ///       </summary>
    // Token: 0x02000088 RID: 136
    class HttpRequestMessage : IDisposable
    {
        /// <summary>
        ///         HTTP メッセージ バージョンを取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP メッセージのバージョン。
        ///          既定値は、1.1 です。
        ///       </returns>
        // Token: 0x170000BD RID: 189
        // (get) Token: 0x06000307 RID: 775 RVA: 0x0003CA3D File Offset: 0x0001CA3D
        // (set) Token: 0x06000308 RID: 776 RVA: 0x0003CA45 File Offset: 0x0001CA45
        public Version Version
        {
            get
            {
                return this._version;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("value");
                }
                this.CheckDisposed();
                this._version = value;
            }
        }

        /// <summary>
        ///         HTTP メッセージの内容を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         メッセージの内容
        ///       </returns>
        // Token: 0x170000BE RID: 190
        // (get) Token: 0x06000309 RID: 777 RVA: 0x0003CA68 File Offset: 0x0001CA68
        // (set) Token: 0x0600030A RID: 778 RVA: 0x0003CA70 File Offset: 0x0001CA70
        public HttpContent Content
        {
            get
            {
                return this._content;
            }
            set
            {
                this.CheckDisposed();
                if (NetEventSource.IsEnabled)
                {
                    if (value == null)
                    {
                        NetEventSource.ContentNull(this);
                    }
                    else
                    {
                        NetEventSource.Associate(this, value, "Content");
                    }
                }
                this._content = value;
            }
        }

        /// <summary>
        ///         この HTTP 要求メッセージで使用する HTTP メソッドを取得または設定します。
        ///       </summary>
        /// <returns>
        ///         この要求メッセージで使用する HTTP メソッド。
        ///          既定は GET メソッドです。
        ///       </returns>
        // Token: 0x170000BF RID: 191
        // (get) Token: 0x0600030B RID: 779 RVA: 0x0003CA9D File Offset: 0x0001CA9D
        // (set) Token: 0x0600030C RID: 780 RVA: 0x0003CAA5 File Offset: 0x0001CAA5
        public HttpMethod Method
        {
            get
            {
                return this._method;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("value");
                }
                this.CheckDisposed();
                this._method = value;
            }
        }

        /// <summary>
        ///         HTTP 要求に使用される <see cref="T:System.Uri" /> を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 要求に使用される <see cref="T:System.Uri" />。
        ///       </returns>
        // Token: 0x170000C0 RID: 192
        // (get) Token: 0x0600030D RID: 781 RVA: 0x0003CAC8 File Offset: 0x0001CAC8
        // (set) Token: 0x0600030E RID: 782 RVA: 0x0003CAD0 File Offset: 0x0001CAD0
        public Uri RequestUri
        {
            get
            {
                return this._requestUri;
            }
            set
            {
                if (value != null && value.IsAbsoluteUri && !HttpUtilities.IsHttpUri(value))
                {
                    throw new ArgumentException(SR.net_http_client_http_baseaddress_required, "value");
                }
                this.CheckDisposed();
                this._requestUri = value;
            }
        }

        /// <summary>
        ///         HTTP 要求ヘッダーのコレクションを取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答ヘッダーのコレクション。
        ///       </returns>
        // Token: 0x170000C1 RID: 193
        // (get) Token: 0x0600030F RID: 783 RVA: 0x0003CB08 File Offset: 0x0001CB08
        public HttpRequestHeaders Headers
        {
            get
            {
                if (this._headers == null)
                {
                    this._headers = new HttpRequestHeaders();
                }
                return this._headers;
            }
        }

        // Token: 0x170000C2 RID: 194
        // (get) Token: 0x06000310 RID: 784 RVA: 0x0003CB23 File Offset: 0x0001CB23
        internal bool HasHeaders
        {
            get
            {
                return this._headers != null;
            }
        }

        /// <summary>
        ///         HTTP 要求のプロパティのセットを取得します。
        ///       </summary>
        /// <returns>
        ///         <see cref="T:System.Collections.Generic.IDictionary`2" /> を返します。
        ///       </returns>
        // Token: 0x170000C3 RID: 195
        // (get) Token: 0x06000311 RID: 785 RVA: 0x0003CB2E File Offset: 0x0001CB2E
        public IDictionary<string, object> Properties
        {
            get
            {
                if (this._properties == null)
                {
                    this._properties = new Dictionary<string, object>();
                }
                return this._properties;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpRequestMessage" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        // Token: 0x06000312 RID: 786 RVA: 0x0003CB49 File Offset: 0x0001CB49
        public HttpRequestMessage() : this(HttpMethod.Get, (string)null)
        {
        }

        /// <summary>
        ///         新しいインスタンスを初期化、 <see cref="T:System.Net.Http.HttpRequestMessage" /> した HTTP メソッドと要求 <see cref="T:System.Uri" />します。
        ///       </summary>
        /// <param name="method">
        ///           HTTP メソッド。
        ///         </param>
        /// <param name="requestUri">
        ///           <see cref="T:System.Uri" /> を要求します。
        ///         </param>
        // Token: 0x06000313 RID: 787 RVA: 0x0003CB57 File Offset: 0x0001CB57
        public HttpRequestMessage(HttpMethod method, Uri requestUri)
        {
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Enter(this, method, requestUri, ".ctor");
            }
            this.InitializeValues(method, requestUri);
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Exit(this, null, ".ctor");
            }
        }

        /// <summary>
        ///         新しいインスタンスを初期化、 <see cref="T:System.Net.Http.HttpRequestMessage" /> した HTTP メソッドと要求 <see cref="T:System.Uri" />します。
        ///       </summary>
        /// <param name="method">
        ///           HTTP メソッド。
        ///         </param>
        /// <param name="requestUri">
        ///           要求を表す文字列  <see cref="T:System.Uri" />します。
        ///         </param>
        // Token: 0x06000314 RID: 788 RVA: 0x0003CB90 File Offset: 0x0001CB90
        public HttpRequestMessage(HttpMethod method, string requestUri)
        {
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Enter(this, method, requestUri);
            }
            if (string.IsNullOrEmpty(requestUri))
            {
                this.InitializeValues(method, null);
            }
            else
            {
                this.InitializeValues(method, new Uri(requestUri, UriKind.RelativeOrAbsolute));
            }
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Exit(this, null, ".ctor");
            }
        }

        /// <summary>
        ///         現在のオブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトの文字列形式。
        ///       </returns>
        // Token: 0x06000315 RID: 789 RVA: 0x0003CBE8 File Offset: 0x0001CBE8
        public override string ToString()
        {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.Append("Method: ");
            stringBuilder.Append(this._method);
            stringBuilder.Append(", RequestUri: '");
            stringBuilder.Append((this._requestUri == null) ? "<null>" : this._requestUri.ToString());
            stringBuilder.Append("', Version: ");
            stringBuilder.Append(this._version);
            stringBuilder.Append(", Content: ");
            stringBuilder.Append((this._content == null) ? "<null>" : this._content.GetType().ToString());
            stringBuilder.Append(", Headers:\r\n");
            stringBuilder.Append(HeaderUtilities.DumpHeaders(new HttpHeaders[]
            {
                this._headers,
                (this._content == null) ? null : this._content.Headers
            }));
            return stringBuilder.ToString();
        }

        // Token: 0x06000316 RID: 790 RVA: 0x0003CCD8 File Offset: 0x0001CCD8
        private void InitializeValues(HttpMethod method, Uri requestUri)
        {
            if (((object)method) == null)
            {
                throw new ArgumentNullException("method");
            }
            if (requestUri != null && requestUri.IsAbsoluteUri && !HttpUtilities.IsHttpUri(requestUri))
            {
                throw new ArgumentException(SR.net_http_client_http_baseaddress_required, "requestUri");
            }
            this._method = method;
            this._requestUri = requestUri;
            this._version = HttpUtilities.DefaultRequestVersion;
        }

        // Token: 0x06000317 RID: 791 RVA: 0x0003CD3B File Offset: 0x0001CD3B
        internal bool MarkAsSent()
        {
            return Interlocked.Exchange(ref this._sendStatus, 1) == 0;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpRequestMessage" /> が使用しているアンマネージ リソースを解放します。オプションとして、マネージ リソースを破棄することもできます。
        ///       </summary>
        /// <param name="disposing">
        ///           マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。
        ///         </param>
        // Token: 0x06000318 RID: 792 RVA: 0x0003CD4C File Offset: 0x0001CD4C
        protected virtual void Dispose(bool disposing)
        {
            if (disposing && !this._disposed)
            {
                this._disposed = true;
                if (this._content != null)
                {
                    this._content.Dispose();
                }
            }
        }

        /// <summary>
        ///         リリースで使用されるアンマネージ リソースおよびマネージ リソースを破棄、 <see cref="T:System.Net.Http.HttpRequestMessage" />です。
        ///       </summary>
        // Token: 0x06000319 RID: 793 RVA: 0x0003CD73 File Offset: 0x0001CD73
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        // Token: 0x0600031A RID: 794 RVA: 0x0003CD82 File Offset: 0x0001CD82
        private void CheckDisposed()
        {
            if (this._disposed)
            {
                throw new ObjectDisposedException(base.GetType().ToString());
            }
        }

        // Token: 0x0400023C RID: 572
        private int _sendStatus;

        // Token: 0x0400023D RID: 573
        private HttpMethod _method;

        // Token: 0x0400023E RID: 574
        private Uri _requestUri;

        // Token: 0x0400023F RID: 575
        private HttpRequestHeaders _headers;

        // Token: 0x04000240 RID: 576
        private Version _version;

        // Token: 0x04000241 RID: 577
        private HttpContent _content;

        // Token: 0x04000242 RID: 578
        private bool _disposed;

        // Token: 0x04000243 RID: 579
        private IDictionary<string, object> _properties;
    }


    /// <summary>
    ///         ステータス コードとデータを含む HTTP 応答メッセージを表します。
    ///       </summary>
    // Token: 0x02000089 RID: 137
    class HttpResponseMessage : IDisposable
    {
        /// <summary>
        ///         HTTP メッセージ バージョンを取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP メッセージのバージョン。
        ///          既定値は、1.1 です。
        ///       </returns>
        // Token: 0x170000C4 RID: 196
        // (get) Token: 0x0600031B RID: 795 RVA: 0x0003CD9D File Offset: 0x0001CD9D
        // (set) Token: 0x0600031C RID: 796 RVA: 0x0003CDA5 File Offset: 0x0001CDA5
        public Version Version
        {
            get
            {
                return this._version;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("value");
                }
                this.CheckDisposed();
                this._version = value;
            }
        }

        // Token: 0x0600031D RID: 797 RVA: 0x0003CDC8 File Offset: 0x0001CDC8
        internal void SetVersionWithoutValidation(Version value)
        {
            this._version = value;
        }

        /// <summary>
        ///         HTTP 応答メッセージの内容を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答メッセージの内容。
        ///       </returns>
        // Token: 0x170000C5 RID: 197
        // (get) Token: 0x0600031E RID: 798 RVA: 0x0003CDD1 File Offset: 0x0001CDD1
        // (set) Token: 0x0600031F RID: 799 RVA: 0x0003CDD9 File Offset: 0x0001CDD9
        public HttpContent Content
        {
            get
            {
                return this._content;
            }
            set
            {
                this.CheckDisposed();
                if (NetEventSource.IsEnabled)
                {
                    if (value == null)
                    {
                        NetEventSource.ContentNull(this);
                    }
                    else
                    {
                        NetEventSource.Associate(this, value, "Content");
                    }
                }
                this._content = value;
            }
        }

        /// <summary>
        ///         HTTP 応答のステータス コードを取得または設定します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答のステータス コード。
        ///       </returns>
        // Token: 0x170000C6 RID: 198
        // (get) Token: 0x06000320 RID: 800 RVA: 0x0003CE06 File Offset: 0x0001CE06
        // (set) Token: 0x06000321 RID: 801 RVA: 0x0003CE0E File Offset: 0x0001CE0E
        public HttpStatusCode StatusCode
        {
            get
            {
                return this._statusCode;
            }
            set
            {
                if (value < (HttpStatusCode)0 || value > (HttpStatusCode)999)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                this.CheckDisposed();
                this._statusCode = value;
            }
        }

        // Token: 0x06000322 RID: 802 RVA: 0x0003CE34 File Offset: 0x0001CE34
        internal void SetStatusCodeWithoutValidation(HttpStatusCode value)
        {
            this._statusCode = value;
        }

        /// <summary>
        ///         ステータス コードと共にサーバーが通常送信する理由語句を取得または設定します。
        ///       </summary>
        /// <returns>
        ///         サーバーが送信する理由語句。
        ///       </returns>
        // Token: 0x170000C7 RID: 199
        // (get) Token: 0x06000323 RID: 803 RVA: 0x0003CE3D File Offset: 0x0001CE3D
        // (set) Token: 0x06000324 RID: 804 RVA: 0x0003CE59 File Offset: 0x0001CE59
        public string ReasonPhrase
        {
            get
            {
                if (this._reasonPhrase != null)
                {
                    return this._reasonPhrase;
                }
                return HttpStatusDescription.Get(this.StatusCode);
            }
            set
            {
                if (value != null && this.ContainsNewLineCharacter(value))
                {
                    throw new FormatException(SR.net_http_reasonphrase_format_error);
                }
                this.CheckDisposed();
                this._reasonPhrase = value;
            }
        }

        // Token: 0x06000325 RID: 805 RVA: 0x0003CE7F File Offset: 0x0001CE7F
        internal void SetReasonPhraseWithoutValidation(string value)
        {
            this._reasonPhrase = value;
        }

        /// <summary>
        ///         HTTP 応答ヘッダーのコレクションを取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答ヘッダーのコレクション。
        ///       </returns>
        // Token: 0x170000C8 RID: 200
        // (get) Token: 0x06000326 RID: 806 RVA: 0x0003CE88 File Offset: 0x0001CE88
        public HttpResponseHeaders Headers
        {
            get
            {
                if (this._headers == null)
                {
                    this._headers = new HttpResponseHeaders();
                }
                return this._headers;
            }
        }

        /// <summary>
        ///         この応答メッセージを引き起こした要求メッセージを取得または設定します。
        ///       </summary>
        /// <returns>
        ///         この応答メッセージを引き起こした要求メッセージ。
        ///       </returns>
        // Token: 0x170000C9 RID: 201
        // (get) Token: 0x06000327 RID: 807 RVA: 0x0003CEA3 File Offset: 0x0001CEA3
        // (set) Token: 0x06000328 RID: 808 RVA: 0x0003CEAB File Offset: 0x0001CEAB
        public HttpRequestMessage RequestMessage
        {
            get
            {
                return this._requestMessage;
            }
            set
            {
                this.CheckDisposed();
                if (value != null)
                {
                    NetEventSource.Associate(this, value, "RequestMessage");
                }
                this._requestMessage = value;
            }
        }

        /// <summary>
        ///         HTTP 応答が成功したかどうかを示す値を取得します。
        ///       </summary>
        /// <returns>
        ///         HTTP 応答が成功したかどうかを示す値。
        ///         <see cref="P:System.Net.Http.HttpResponseMessage.StatusCode" /> が 200 から 299 の範囲にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x170000CA RID: 202
        // (get) Token: 0x06000329 RID: 809 RVA: 0x0003CEC9 File Offset: 0x0001CEC9
        public bool IsSuccessStatusCode
        {
            get
            {
                return this._statusCode >= HttpStatusCode.OK && this._statusCode <= (HttpStatusCode)299;
            }
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpResponseMessage" /> クラスの新しいインスタンスを初期化します。
        ///       </summary>
        // Token: 0x0600032A RID: 810 RVA: 0x0003CEEA File Offset: 0x0001CEEA
        public HttpResponseMessage() : this(HttpStatusCode.OK)
        {
        }

        /// <summary>
        ///         新しいインスタンスを初期化、 <see cref="T:System.Net.Http.HttpResponseMessage" /> 、特定のクラス <see cref="P:System.Net.Http.HttpResponseMessage.StatusCode" />します。
        ///       </summary>
        /// <param name="statusCode">
        ///           HTTP 応答のステータス コード。
        ///         </param>
        // Token: 0x0600032B RID: 811 RVA: 0x0003CEF8 File Offset: 0x0001CEF8
        public HttpResponseMessage(HttpStatusCode statusCode)
        {
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Enter(this, statusCode, ".ctor");
            }
            if (statusCode < (HttpStatusCode)0 || statusCode > (HttpStatusCode)999)
            {
                throw new ArgumentOutOfRangeException("statusCode");
            }
            this._statusCode = statusCode;
            this._version = HttpUtilities.DefaultResponseVersion;
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Exit(this, null, ".ctor");
            }
        }

        /// <summary>
        ///         HTTP 応答の <see cref="P:System.Net.Http.HttpResponseMessage.IsSuccessStatusCode" /> プロパティが <see langword="false" /> である場合、例外をスローします。
        ///       </summary>
        /// <returns>
        ///         呼び出しに成功した場合の HTTP 応答メッセージ。
        ///       </returns>
        // Token: 0x0600032C RID: 812 RVA: 0x0003CF60 File Offset: 0x0001CF60
        public HttpResponseMessage EnsureSuccessStatusCode()
        {
            if (!this.IsSuccessStatusCode)
            {
                if (this._content != null)
                {
                    this._content.Dispose();
                }
                throw new HttpRequestException(string.Format(CultureInfo.InvariantCulture, SR.net_http_message_not_success_statuscode, (int)this._statusCode, this.ReasonPhrase));
            }
            return this;
        }

        /// <summary>
        ///         現在のオブジェクトを表す文字列を返します。
        ///       </summary>
        /// <returns>
        ///         現在のオブジェクトの文字列形式。
        ///       </returns>
        // Token: 0x0600032D RID: 813 RVA: 0x0003CFB0 File Offset: 0x0001CFB0
        public override string ToString()
        {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.Append("StatusCode: ");
            stringBuilder.Append((int)this._statusCode);
            stringBuilder.Append(", ReasonPhrase: '");
            stringBuilder.Append(this.ReasonPhrase ?? "<null>");
            stringBuilder.Append("', Version: ");
            stringBuilder.Append(this._version);
            stringBuilder.Append(", Content: ");
            stringBuilder.Append((this._content == null) ? "<null>" : this._content.GetType().ToString());
            stringBuilder.Append(", Headers:\r\n");
            stringBuilder.Append(HeaderUtilities.DumpHeaders(new HttpHeaders[]
            {
                this._headers,
                (this._content == null) ? null : this._content.Headers
            }));
            return stringBuilder.ToString();
        }

        // Token: 0x0600032E RID: 814 RVA: 0x0003D090 File Offset: 0x0001D090
        private bool ContainsNewLineCharacter(string value)
        {
            foreach (char c in value)
            {
                if (c == '\r' || c == '\n')
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.HttpResponseMessage" /> が使用しているアンマネージ リソースを解放します。オプションとして、マネージ リソースを破棄することもできます。
        ///       </summary>
        /// <param name="disposing">
        ///           マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。
        ///         </param>
        // Token: 0x0600032F RID: 815 RVA: 0x0003D0C5 File Offset: 0x0001D0C5
        protected virtual void Dispose(bool disposing)
        {
            if (disposing && !this._disposed)
            {
                this._disposed = true;
                if (this._content != null)
                {
                    this._content.Dispose();
                }
            }
        }

        /// <summary>
        ///         リリースは、アンマネージ リソースを破棄アンマネージ リソースで使用される、 <see cref="T:System.Net.Http.HttpResponseMessage" />です。
        ///       </summary>
        // Token: 0x06000330 RID: 816 RVA: 0x0003D0EC File Offset: 0x0001D0EC
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        // Token: 0x06000331 RID: 817 RVA: 0x0003D0FB File Offset: 0x0001D0FB
        private void CheckDisposed()
        {
            if (this._disposed)
            {
                throw new ObjectDisposedException(base.GetType().ToString());
            }
        }

        // Token: 0x04000244 RID: 580
        private HttpStatusCode _statusCode;

        // Token: 0x04000245 RID: 581
        private HttpResponseHeaders _headers;

        // Token: 0x04000246 RID: 582
        private string _reasonPhrase;

        // Token: 0x04000247 RID: 583
        private HttpRequestMessage _requestMessage;

        // Token: 0x04000248 RID: 584
        private Version _version;

        // Token: 0x04000249 RID: 585
        private HttpContent _content;

        // Token: 0x0400024A RID: 586
        private bool _disposed;
    }


    // Token: 0x0200008A RID: 138
    internal static class HttpRuleParser
    {
        // Token: 0x06000332 RID: 818 RVA: 0x0003D118 File Offset: 0x0001D118
        private static bool[] CreateTokenChars()
        {
            bool[] array = new bool[128];
            for (int i = 33; i < 127; i++)
            {
                array[i] = true;
            }
            array[40] = false;
            array[41] = false;
            array[60] = false;
            array[62] = false;
            array[64] = false;
            array[44] = false;
            array[59] = false;
            array[58] = false;
            array[92] = false;
            array[34] = false;
            array[47] = false;
            array[91] = false;
            array[93] = false;
            array[63] = false;
            array[61] = false;
            array[123] = false;
            array[125] = false;
            return array;
        }

        // Token: 0x06000333 RID: 819 RVA: 0x0003D198 File Offset: 0x0001D198
        internal static bool IsTokenChar(char character)
        {
            return character <= '\u007f' && HttpRuleParser.s_tokenChars[(int)character];
        }

        // Token: 0x06000334 RID: 820 RVA: 0x0003D1A8 File Offset: 0x0001D1A8
        internal static int GetTokenLength(string input, int startIndex)
        {
            if (startIndex >= input.Length)
            {
                return 0;
            }
            for (int i = startIndex; i < input.Length; i++)
            {
                if (!HttpRuleParser.IsTokenChar(input[i]))
                {
                    return i - startIndex;
                }
            }
            return input.Length - startIndex;
        }

        // Token: 0x06000335 RID: 821 RVA: 0x0003D1EC File Offset: 0x0001D1EC
        internal static bool IsToken(string input)
        {
            for (int i = 0; i < input.Length; i++)
            {
                if (!HttpRuleParser.IsTokenChar(input[i]))
                {
                    return false;
                }
            }
            return true;
        }

        // Token: 0x06000336 RID: 822 RVA: 0x0003D21C File Offset: 0x0001D21C
        internal unsafe static bool IsToken(ReadOnlySpan<byte> input)
        {
            for (int i = 0; i < input.Length; i++)
            {
                if (!HttpRuleParser.IsTokenChar((char)(input[i])))
                {
                    return false;
                }
            }
            return true;
        }

        // Token: 0x06000337 RID: 823 RVA: 0x0003D24E File Offset: 0x0001D24E
        internal static string GetTokenString(ReadOnlySpan<byte> input)
        {
            return Encoding.ASCII.GetString(input);
        }

        // Token: 0x06000338 RID: 824 RVA: 0x0003D25C File Offset: 0x0001D25C
        internal static int GetWhitespaceLength(string input, int startIndex)
        {
            if (startIndex >= input.Length)
            {
                return 0;
            }
            for (int i = startIndex; i < input.Length; i++)
            {
                char c = input[i];
                if (c != ' ' && c != '\t')
                {
                    if (c == '\r' && i + 2 < input.Length && input[i + 1] == '\n')
                    {
                        char c2 = input[i + 2];
                        if (c2 == ' ' || c2 == '\t')
                        {
                            i += 3;
                            continue;
                        }
                    }
                    return i - startIndex;
                }
            }
            return input.Length - startIndex;
        }

        // Token: 0x06000339 RID: 825 RVA: 0x0003D2DC File Offset: 0x0001D2DC
        internal static bool ContainsInvalidNewLine(string value)
        {
            return HttpRuleParser.ContainsInvalidNewLine(value, 0);
        }

        // Token: 0x0600033A RID: 826 RVA: 0x0003D2E8 File Offset: 0x0001D2E8
        internal static bool ContainsInvalidNewLine(string value, int startIndex)
        {
            for (int i = startIndex; i < value.Length; i++)
            {
                if (value[i] == '\r')
                {
                    int num = i + 1;
                    if (num < value.Length && value[num] == '\n')
                    {
                        i = num + 1;
                        if (i == value.Length)
                        {
                            return true;
                        }
                        char c = value[i];
                        if (c != ' ' && c != '\t')
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Token: 0x0600033B RID: 827 RVA: 0x0003D350 File Offset: 0x0001D350
        internal static int GetNumberLength(string input, int startIndex, bool allowDecimal)
        {
            int i = startIndex;
            bool flag = !allowDecimal;
            if (input[i] == '.')
            {
                return 0;
            }
            while (i < input.Length)
            {
                char c = input[i];
                if (c >= '0' && c <= '9')
                {
                    i++;
                }
                else
                {
                    if (flag || c != '.')
                    {
                        break;
                    }
                    flag = true;
                    i++;
                }
            }
            return i - startIndex;
        }

        // Token: 0x0600033C RID: 828 RVA: 0x0003D3A4 File Offset: 0x0001D3A4
        internal static int GetHostLength(string input, int startIndex, bool allowToken, out string host)
        {
            host = null;
            if (startIndex >= input.Length)
            {
                return 0;
            }
            int i = startIndex;
            bool flag = true;
            while (i < input.Length)
            {
                char c = input[i];
                if (c == '/')
                {
                    return 0;
                }
                if (c == ' ' || c == '\t' || c == '\r' || c == ',')
                {
                    break;
                }
                flag = (flag && HttpRuleParser.IsTokenChar(c));
                i++;
            }
            int num = i - startIndex;
            if (num == 0)
            {
                return 0;
            }
            string text = input.Substring(startIndex, num);
            if ((!allowToken || !flag) && !HttpRuleParser.IsValidHostName(text))
            {
                return 0;
            }
            host = text;
            return num;
        }

        // Token: 0x0600033D RID: 829 RVA: 0x0003D430 File Offset: 0x0001D430
        internal static HttpParseResult GetCommentLength(string input, int startIndex, out int length)
        {
            int num = 0;
            return HttpRuleParser.GetExpressionLength(input, startIndex, '(', ')', true, ref num, out length);
        }

        // Token: 0x0600033E RID: 830 RVA: 0x0003D450 File Offset: 0x0001D450
        internal static HttpParseResult GetQuotedStringLength(string input, int startIndex, out int length)
        {
            int num = 0;
            return HttpRuleParser.GetExpressionLength(input, startIndex, '"', '"', false, ref num, out length);
        }

        // Token: 0x0600033F RID: 831 RVA: 0x0003D46E File Offset: 0x0001D46E
        internal static HttpParseResult GetQuotedPairLength(string input, int startIndex, out int length)
        {
            length = 0;
            if (input[startIndex] != '\\')
            {
                return HttpParseResult.NotParsed;
            }
            if (startIndex + 2 > input.Length || input[startIndex + 1] > '\u007f')
            {
                return HttpParseResult.InvalidFormat;
            }
            length = 2;
            return HttpParseResult.Parsed;
        }

        // Token: 0x06000340 RID: 832 RVA: 0x0003D4A0 File Offset: 0x0001D4A0
        internal static string DateToString(DateTimeOffset dateTime)
        {
            return dateTime.ToUniversalTime().ToString("r", CultureInfo.InvariantCulture);
        }

        // Token: 0x06000341 RID: 833 RVA: 0x0003D4C6 File Offset: 0x0001D4C6
        internal static bool TryStringToDate(string input, out DateTimeOffset result)
        {
            return DateTimeOffset.TryParseExact(input, HttpRuleParser.s_dateFormats, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.AllowLeadingWhite | DateTimeStyles.AllowTrailingWhite | DateTimeStyles.AllowInnerWhite | DateTimeStyles.AssumeUniversal, out result);
        }

        // Token: 0x06000342 RID: 834 RVA: 0x0003D4E0 File Offset: 0x0001D4E0
        private static HttpParseResult GetExpressionLength(string input, int startIndex, char openChar, char closeChar, bool supportsNesting, ref int nestedCount, out int length)
        {
            length = 0;
            if (input[startIndex] != openChar)
            {
                return HttpParseResult.NotParsed;
            }
            int i = startIndex + 1;
            while (i < input.Length)
            {
                int num = 0;
                if (i + 2 < input.Length && HttpRuleParser.GetQuotedPairLength(input, i, out num) == HttpParseResult.Parsed)
                {
                    i += num;
                }
                else
                {
                    if (supportsNesting && input[i] == openChar)
                    {
                        nestedCount++;
                        try
                        {
                            if (nestedCount > 5)
                            {
                                return HttpParseResult.InvalidFormat;
                            }
                            int num2 = 0;
                            switch (HttpRuleParser.GetExpressionLength(input, i, openChar, closeChar, supportsNesting, ref nestedCount, out num2))
                            {
                                case HttpParseResult.Parsed:
                                    i += num2;
                                    break;
                                case HttpParseResult.InvalidFormat:
                                    return HttpParseResult.InvalidFormat;
                            }
                        }
                        finally
                        {
                            nestedCount--;
                        }
                    }
                    if (input[i] == closeChar)
                    {
                        length = i - startIndex + 1;
                        return HttpParseResult.Parsed;
                    }
                    i++;
                }
            }
            return HttpParseResult.InvalidFormat;
        }

        // Token: 0x06000343 RID: 835 RVA: 0x0003D5BC File Offset: 0x0001D5BC
        private static bool IsValidHostName(string host)
        {
            Uri uri;
            return Uri.TryCreate("http://u@" + host + "/", UriKind.Absolute, out uri);
        }

        // Token: 0x0400024B RID: 587
        private static readonly bool[] s_tokenChars = HttpRuleParser.CreateTokenChars();

        // Token: 0x0400024C RID: 588
        private static readonly string[] s_dateFormats = new string[]
        {
            "ddd, d MMM yyyy H:m:s 'GMT'",
            "ddd, d MMM yyyy H:m:s",
            "d MMM yyyy H:m:s 'GMT'",
            "d MMM yyyy H:m:s",
            "ddd, d MMM yy H:m:s 'GMT'",
            "ddd, d MMM yy H:m:s",
            "d MMM yy H:m:s 'GMT'",
            "d MMM yy H:m:s",
            "dddd, d'-'MMM'-'yy H:m:s 'GMT'",
            "dddd, d'-'MMM'-'yy H:m:s",
            "ddd MMM d H:m:s yyyy",
            "ddd, d MMM yyyy H:m:s zzz",
            "ddd, d MMM yyyy H:m:s",
            "d MMM yyyy H:m:s zzz",
            "d MMM yyyy H:m:s"
        };

        // Token: 0x0400024D RID: 589
        internal static readonly Encoding DefaultHttpEncoding = Encoding.GetEncoding(28591);
    }



    // Token: 0x0200008B RID: 139
    internal static class HttpUtilities
    {
        // Token: 0x170000CB RID: 203
        // (get) Token: 0x06000345 RID: 837 RVA: 0x0003D694 File Offset: 0x0001D694
        internal static Version DefaultRequestVersion
        {
            get
            {
                return HttpVersionInternal.Version20;
            }
        }

        // Token: 0x170000CC RID: 204
        // (get) Token: 0x06000346 RID: 838 RVA: 0x0003D69B File Offset: 0x0001D69B
        internal static Version DefaultResponseVersion
        {
            get
            {
                return HttpVersionInternal.Version11;
            }
        }

        // Token: 0x06000347 RID: 839 RVA: 0x0003D6A2 File Offset: 0x0001D6A2
        internal static bool IsHttpUri(Uri uri)
        {
            return HttpUtilities.IsSupportedScheme(uri.Scheme);
        }

        // Token: 0x06000348 RID: 840 RVA: 0x0003D6AF File Offset: 0x0001D6AF
        internal static bool IsSupportedScheme(string scheme)
        {
            return HttpUtilities.IsSupportedNonSecureScheme(scheme) || HttpUtilities.IsSupportedSecureScheme(scheme);
        }

        // Token: 0x06000349 RID: 841 RVA: 0x0003D6C1 File Offset: 0x0001D6C1
        internal static bool IsSupportedNonSecureScheme(string scheme)
        {
            return string.Equals(scheme, "http", StringComparison.OrdinalIgnoreCase) || HttpUtilities.IsNonSecureWebSocketScheme(scheme);
        }

        // Token: 0x0600034A RID: 842 RVA: 0x0003D6D9 File Offset: 0x0001D6D9
        internal static bool IsSupportedSecureScheme(string scheme)
        {
            return string.Equals(scheme, "https", StringComparison.OrdinalIgnoreCase) || HttpUtilities.IsSecureWebSocketScheme(scheme);
        }

        // Token: 0x0600034B RID: 843 RVA: 0x0003D6F1 File Offset: 0x0001D6F1
        internal static bool IsNonSecureWebSocketScheme(string scheme)
        {
            return string.Equals(scheme, "ws", StringComparison.OrdinalIgnoreCase);
        }

        // Token: 0x0600034C RID: 844 RVA: 0x0003D6FF File Offset: 0x0001D6FF
        internal static bool IsSecureWebSocketScheme(string scheme)
        {
            return string.Equals(scheme, "wss", StringComparison.OrdinalIgnoreCase);
        }

        // Token: 0x0600034D RID: 845 RVA: 0x0003D70D File Offset: 0x0001D70D
        internal static Task _ContinueWithStandard<T>(this Task<T> task, object state, Action<Task<T>, object> continuation)
        {
            return task.ContinueWith(continuation, state, CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);
        }
    }


    /// <summary>
    ///         要求メッセージと応答メッセージの一部の小さな処理のみを行うハンドラーの基本データ型。
    ///       </summary>
    // Token: 0x0200008C RID: 140
    abstract class MessageProcessingHandler : DelegatingHandler
    {
        /// <summary>
        ///         インスタンスを作成、 <see cref="T:System.Net.Http.MessageProcessingHandler" /> クラスです。
        ///       </summary>
        // Token: 0x0600034E RID: 846 RVA: 0x0003D726 File Offset: 0x0001D726
        protected MessageProcessingHandler()
        {
        }

        /// <summary>
        ///         インスタンスを作成、 <see cref="T:System.Net.Http.MessageProcessingHandler" /> を特定の内部ハンドラー クラス。
        ///       </summary>
        /// <param name="innerHandler">
        ///           HTTP 応答メッセージの処理を担当する内部ハンドラーです。
        ///         </param>
        // Token: 0x0600034F RID: 847 RVA: 0x0003D72E File Offset: 0x0001D72E
        protected MessageProcessingHandler(HttpMessageHandler innerHandler) : base(innerHandler)
        {
        }

        /// <summary>
        ///         サーバーに送信される各要求の処理を実行します。
        ///       </summary>
        /// <param name="request">
        ///           処理する HTTP 要求メッセージ。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         処理された HTTP 要求メッセージ。
        ///       </returns>
        // Token: 0x06000350 RID: 848
        protected abstract HttpRequestMessage ProcessRequest(HttpRequestMessage request, CancellationToken cancellationToken);

        /// <summary>
        ///         サーバーからの各応答に対して処理を実行します。
        ///       </summary>
        /// <param name="response">
        ///           処理する HTTP 応答メッセージ。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         処理された HTTP 応答メッセージ。
        ///       </returns>
        // Token: 0x06000351 RID: 849
        protected abstract HttpResponseMessage ProcessResponse(HttpResponseMessage response, CancellationToken cancellationToken);

        /// <summary>
        ///         非同期操作としてサーバーに送信するように HTTP 要求を内部ハンドラーに送信します。
        ///       </summary>
        /// <param name="request">
        ///           サーバーに送信する HTTP 要求メッセージ。
        ///         </param>
        /// <param name="cancellationToken">
        ///           キャンセル通知を受け取るために他のオブジェクトまたはスレッドで使用できるキャンセル トークン。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="request" /> が <see langword="null" />でした。
        ///           </exception>
        // Token: 0x06000352 RID: 850 RVA: 0x0003D738 File Offset: 0x0001D738
        protected internal sealed override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request", SR.net_http_handler_norequest);
            }
            MessageProcessingHandler.SendState sendState = new MessageProcessingHandler.SendState(this, cancellationToken);
            try
            {
                HttpRequestMessage request2 = this.ProcessRequest(request, cancellationToken);
                Task<HttpResponseMessage> task2 = base.SendAsync(request2, cancellationToken);
                task2._ContinueWithStandard(sendState, delegate (Task<HttpResponseMessage> task, object state)
                {
                    MessageProcessingHandler.SendState sendState2 = (MessageProcessingHandler.SendState)state;
                    MessageProcessingHandler handler = sendState2._handler;
                    CancellationToken token = sendState2._token;
                    if (task.IsFaulted)
                    {
                        sendState2.TrySetException(task.Exception.GetBaseException());
                        return;
                    }
                    if (task.IsCanceled)
                    {
                        sendState2.TrySetCanceled();
                        return;
                    }
                    if (task.Result == null)
                    {
                        sendState2.TrySetException(new InvalidOperationException(SR.net_http_handler_noresponse));
                        return;
                    }
                    try
                    {
                        HttpResponseMessage result = handler.ProcessResponse(task.Result, token);
                        sendState2.TrySetResult(result);
                    }
                    catch (OperationCanceledException e2)
                    {
                        MessageProcessingHandler.HandleCanceledOperations(token, sendState2, e2);
                    }
                    catch (Exception exception2)
                    {
                        sendState2.TrySetException(exception2);
                    }
                });
            }
            catch (OperationCanceledException e)
            {
                MessageProcessingHandler.HandleCanceledOperations(cancellationToken, sendState, e);
            }
            catch (Exception exception)
            {
                sendState.TrySetException(exception);
            }
            return sendState.Task;
        }

        // Token: 0x06000353 RID: 851 RVA: 0x0003D7D8 File Offset: 0x0001D7D8
        private static void HandleCanceledOperations(CancellationToken cancellationToken, TaskCompletionSource<HttpResponseMessage> tcs, OperationCanceledException e)
        {
            if (cancellationToken.IsCancellationRequested && e.CancellationToken == cancellationToken)
            {
                tcs.TrySetCanceled();
                return;
            }
            tcs.TrySetException(e);
        }

        // Token: 0x0200008D RID: 141
        private sealed class SendState : TaskCompletionSource<HttpResponseMessage>
        {
            // Token: 0x06000354 RID: 852 RVA: 0x0003D801 File Offset: 0x0001D801
            public SendState(MessageProcessingHandler handler, CancellationToken token)
            {
                this._handler = handler;
                this._token = token;
            }

            // Token: 0x0400024E RID: 590
            internal readonly MessageProcessingHandler _handler;

            // Token: 0x0400024F RID: 591
            internal readonly CancellationToken _token;
        }
    }


    /// <summary>
    ///         コレクションを提供 <see cref="T:System.Net.Http.HttpContent" /> マルチパートを使用してシリアル化されるオブジェクト/* コンテンツの種類に指定します。
    ///       </summary>
    // Token: 0x0200008F RID: 143
    class MultipartContent : HttpContent, IEnumerable<HttpContent>, IEnumerable
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.MultipartContent" /> クラスの新しいインスタンスを作成します。
        ///       </summary>
        // Token: 0x06000358 RID: 856 RVA: 0x0003D8DC File Offset: 0x0001D8DC
        public MultipartContent() : this("mixed", MultipartContent.GetDefaultBoundary())
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.MultipartContent" /> クラスの新しいインスタンスを作成します。
        ///       </summary>
        /// <param name="subtype">
        ///           マルチパート コンテンツのサブタイプ。
        ///         </param>
        /// <exception cref="T:System.ArgumentException">
        ///             <paramref name="subtype" /> が <see langword="null" /> または空白文字だけが含まれています。
        ///           </exception>
        // Token: 0x06000359 RID: 857 RVA: 0x0003D8EE File Offset: 0x0001D8EE
        public MultipartContent(string subtype) : this(subtype, MultipartContent.GetDefaultBoundary())
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.MultipartContent" /> クラスの新しいインスタンスを作成します。
        ///       </summary>
        /// <param name="subtype">
        ///           マルチパート コンテンツのサブタイプ。
        ///         </param>
        /// <param name="boundary">
        ///           マルチパート コンテンツの境界文字列。
        ///         </param>
        /// <exception cref="T:System.ArgumentException">
        ///             <paramref name="subtype" /> が <see langword="null" /> または空の文字列でした。
        ///
        ///             <paramref name="boundary" /> が <see langword="null" /> であったか、または空白文字だけを含んでいます。
        ///
        ///             または
        ///
        ///             <paramref name="boundary" /> が空白文字で終わっています。
        ///           </exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///             <paramref name="boundary" /> の長さが 70 を超えていました。
        ///           </exception>
        // Token: 0x0600035A RID: 858 RVA: 0x0003D8FC File Offset: 0x0001D8FC
        public MultipartContent(string subtype, string boundary)
        {
            if (string.IsNullOrWhiteSpace(subtype))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, "subtype");
            }
            MultipartContent.ValidateBoundary(boundary);
            this._boundary = boundary;
            string text = boundary;
            if (!text.StartsWith("\"", StringComparison.Ordinal))
            {
                text = "\"" + text + "\"";
            }
            MediaTypeHeaderValue mediaTypeHeaderValue = new MediaTypeHeaderValue("multipart/" + subtype);
            mediaTypeHeaderValue.Parameters.Add(new NameValueHeaderValue("boundary", text));
            base.Headers.ContentType = mediaTypeHeaderValue;
            this._nestedContent = new List<HttpContent>();
        }

        // Token: 0x0600035B RID: 859 RVA: 0x0003D994 File Offset: 0x0001D994
        private static void ValidateBoundary(string boundary)
        {
            if (string.IsNullOrWhiteSpace(boundary))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, "boundary");
            }
            if (boundary.Length > 70)
            {
                throw new ArgumentOutOfRangeException("boundary", boundary, string.Format(CultureInfo.InvariantCulture, SR.net_http_content_field_too_long, 70));
            }
            if (boundary.EndsWith(" ", StringComparison.Ordinal))
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, boundary), "boundary");
            }
            foreach (char c in boundary)
            {
                if (('0' > c || c > '9') && ('a' > c || c > 'z') && ('A' > c || c > 'Z') && "'()+_,-./:=? ".IndexOf(c) < 0)
                {
                    throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, SR.net_http_headers_invalid_value, boundary), "boundary");
                }
            }
        }

        // Token: 0x0600035C RID: 860 RVA: 0x0003DA70 File Offset: 0x0001DA70
        private static string GetDefaultBoundary()
        {
            return Guid.NewGuid().ToString();
        }

        /// <summary>
        ///         コレクションをマルチパートの HTTP コンテンツを追加 <see cref="T:System.Net.Http.HttpContent" /> マルチパートを使用してシリアル化されるオブジェクト/* コンテンツの種類に指定します。
        ///       </summary>
        /// <param name="content">
        ///           コレクションに追加する HTTP コンテンツ。
        ///         </param>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="content" /> が <see langword="null" />でした。
        ///           </exception>
        // Token: 0x0600035D RID: 861 RVA: 0x0003DA90 File Offset: 0x0001DA90
        public virtual void Add(HttpContent content)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            this._nestedContent.Add(content);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.MultipartContent" /> が使用しているアンマネージ リソースを解放します。オプションとして、マネージ リソースを破棄することもできます。
        ///       </summary>
        /// <param name="disposing">
        ///           マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。
        ///         </param>
        // Token: 0x0600035E RID: 862 RVA: 0x0003DAAC File Offset: 0x0001DAAC
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                foreach (HttpContent httpContent in this._nestedContent)
                {
                    httpContent.Dispose();
                }
                this._nestedContent.Clear();
            }
            base.Dispose(disposing);
        }

        /// <summary>
        ///         マルチパート/* コンテンツ タイプの仕様を使用してシリアル化される <see cref="T:System.Net.Http.HttpContent" /> オブジェクトのコレクションを反復処理する列挙子を返します。
        ///       </summary>
        /// <returns>
        ///         コレクションを反復処理するために使用できるオブジェクト。
        ///       </returns>
        // Token: 0x0600035F RID: 863 RVA: 0x0003DB14 File Offset: 0x0001DB14
        public IEnumerator<HttpContent> GetEnumerator()
        {
            return this._nestedContent.GetEnumerator();
        }

        /// <summary>
        ///         <see cref="M:System.Net.Http.MultipartContent.GetEnumerator" /> メソッドの明示的な実装。
        ///       </summary>
        /// <returns>
        ///         コレクションを反復処理するために使用できるオブジェクト。
        ///       </returns>
        // Token: 0x06000360 RID: 864 RVA: 0x0003DB14 File Offset: 0x0001DB14
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this._nestedContent.GetEnumerator();
        }

        /// <summary>
        ///         非同期操作としてマルチパートの HTTP コンテンツをストリームにシリアル化します。
        ///       </summary>
        /// <param name="stream">
        ///           対象のストリーム。
        ///         </param>
        /// <param name="context">
        ///           トランスポート (チャネル バインディング トークンなど) について説明します。
        ///            このパラメーターは <see langword="null" /> でもかまいません。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x06000361 RID: 865 RVA: 0x0003DB28 File Offset: 0x0001DB28
        protected override async Task SerializeToStreamAsync(Stream stream, TransportContext context)
        {
            try
            {
                await MultipartContent.EncodeStringToStreamAsync(stream, "--" + this._boundary + "\r\n").ConfigureAwait(false);
                StringBuilder output = new StringBuilder();
                for (int contentIndex = 0; contentIndex < this._nestedContent.Count; contentIndex++)
                {
                    HttpContent content = this._nestedContent[contentIndex];
                    await MultipartContent.EncodeStringToStreamAsync(stream, this.SerializeHeadersToString(output, contentIndex, content)).ConfigureAwait(false);
                    await content.CopyToAsync(stream).ConfigureAwait(false);
                    content = null;
                }
                await MultipartContent.EncodeStringToStreamAsync(stream, "\r\n--" + this._boundary + "--\r\n").ConfigureAwait(false);
                output = null;
            }
            catch (Exception message)
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(this, message, "SerializeToStreamAsync");
                }
                throw;
            }
        }

        // Token: 0x06000362 RID: 866 RVA: 0x0003DB78 File Offset: 0x0001DB78
        protected override async Task<Stream> CreateContentReadStreamAsync()
        {
            Stream result;
            try
            {
                Stream[] streams = new Stream[2 + this._nestedContent.Count * 2];
                StringBuilder scratch = new StringBuilder();
                int streamIndex = 0;
                Stream[] array = streams;
                int num = streamIndex;
                streamIndex = num + 1;
                array[num] = MultipartContent.EncodeStringToNewStream("--" + this._boundary + "\r\n");
                for (int contentIndex = 0; contentIndex < this._nestedContent.Count; contentIndex = num + 1)
                {
                    HttpContent httpContent = this._nestedContent[contentIndex];
                    Stream[] array2 = streams;
                    num = streamIndex;
                    streamIndex = num + 1;
                    array2[num] = MultipartContent.EncodeStringToNewStream(this.SerializeHeadersToString(scratch, contentIndex, httpContent));
                    Stream stream = await httpContent.ReadAsStreamAsync().ConfigureAwait(false);
                    Stream stream2 = stream ?? new MemoryStream();
                    if (!stream2.CanSeek)
                    {
                        return await base.CreateContentReadStreamAsync().ConfigureAwait(false);
                    }
                    Stream[] array3 = streams;
                    num = streamIndex;
                    streamIndex = num + 1;
                    array3[num] = stream2;
                    num = contentIndex;
                }
                streams[streamIndex] = MultipartContent.EncodeStringToNewStream("\r\n--" + this._boundary + "--\r\n");
                result = new MultipartContent.ContentReadStream(streams);
            }
            catch (Exception message)
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(this, message, "CreateContentReadStreamAsync");
                }
                throw;
            }
            return result;
        }

        // Token: 0x06000363 RID: 867 RVA: 0x0003DBC0 File Offset: 0x0001DBC0
        private string SerializeHeadersToString(StringBuilder scratch, int contentIndex, HttpContent content)
        {
            scratch.Clear();
            if (contentIndex != 0)
            {
                scratch.Append("\r\n--");
                scratch.Append(this._boundary);
                scratch.Append("\r\n");
            }
            foreach (KeyValuePair<string, IEnumerable<string>> keyValuePair in content.Headers)
            {
                scratch.Append(keyValuePair.Key);
                scratch.Append(": ");
                string value = string.Empty;
                foreach (string value2 in keyValuePair.Value)
                {
                    scratch.Append(value);
                    scratch.Append(value2);
                    value = ", ";
                }
                scratch.Append("\r\n");
            }
            scratch.Append("\r\n");
            return scratch.ToString();
        }

        // Token: 0x06000364 RID: 868 RVA: 0x0003DCC4 File Offset: 0x0001DCC4
        private static ValueTask EncodeStringToStreamAsync(Stream stream, string input)
        {
            byte[] bytes = HttpRuleParser.DefaultHttpEncoding.GetBytes(input);
            return stream.WriteAsync(new ReadOnlyMemory<byte>(bytes), default(CancellationToken));
        }

        // Token: 0x06000365 RID: 869 RVA: 0x0003DCF2 File Offset: 0x0001DCF2
        private static Stream EncodeStringToNewStream(string input)
        {
            return new MemoryStream(HttpRuleParser.DefaultHttpEncoding.GetBytes(input), false);
        }

        /// <summary>
        ///         HTTP マルチパート コンテンツが有効なバイト長であるかどうかを決定します。
        ///       </summary>
        /// <param name="length">
        ///           HTTP コンテンツの長さ (バイト単位)。
        ///         </param>
        /// <returns>
        ///         <paramref name="length" /> が有効な長さの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000366 RID: 870 RVA: 0x0003DD08 File Offset: 0x0001DD08
        protected internal override bool TryComputeLength(out long length)
        {
            int encodedLength = MultipartContent.GetEncodedLength(this._boundary);
            long num = 0L;
            long num2 = (long)(MultipartContent.s_crlfLength + MultipartContent.s_dashDashLength + encodedLength + MultipartContent.s_crlfLength);
            num += (long)(MultipartContent.s_dashDashLength + encodedLength + MultipartContent.s_crlfLength);
            bool flag = true;
            foreach (HttpContent httpContent in this._nestedContent)
            {
                if (flag)
                {
                    flag = false;
                }
                else
                {
                    num += num2;
                }
                foreach (KeyValuePair<string, IEnumerable<string>> keyValuePair in httpContent.Headers)
                {
                    num += (long)(MultipartContent.GetEncodedLength(keyValuePair.Key) + MultipartContent.s_colonSpaceLength);
                    int num3 = 0;
                    foreach (string input in keyValuePair.Value)
                    {
                        num += (long)MultipartContent.GetEncodedLength(input);
                        num3++;
                    }
                    if (num3 > 1)
                    {
                        num += (long)((num3 - 1) * MultipartContent.s_commaSpaceLength);
                    }
                    num += (long)MultipartContent.s_crlfLength;
                }
                num += (long)MultipartContent.s_crlfLength;
                long num4 = 0L;
                if (!httpContent.TryComputeLength(out num4))
                {
                    length = 0L;
                    return false;
                }
                num += num4;
            }
            num += (long)(MultipartContent.s_crlfLength + MultipartContent.s_dashDashLength + encodedLength + MultipartContent.s_dashDashLength + MultipartContent.s_crlfLength);
            length = num;
            return true;
        }

        // Token: 0x06000367 RID: 871 RVA: 0x0003DEAC File Offset: 0x0001DEAC
        private static int GetEncodedLength(string input)
        {
            return HttpRuleParser.DefaultHttpEncoding.GetByteCount(input);
        }

        // Token: 0x04000252 RID: 594
        private static readonly int s_crlfLength = MultipartContent.GetEncodedLength("\r\n");

        // Token: 0x04000253 RID: 595
        private static readonly int s_dashDashLength = MultipartContent.GetEncodedLength("--");

        // Token: 0x04000254 RID: 596
        private static readonly int s_colonSpaceLength = MultipartContent.GetEncodedLength(": ");

        // Token: 0x04000255 RID: 597
        private static readonly int s_commaSpaceLength = MultipartContent.GetEncodedLength(", ");

        // Token: 0x04000256 RID: 598
        private readonly List<HttpContent> _nestedContent;

        // Token: 0x04000257 RID: 599
        private readonly string _boundary;

        // Token: 0x02000090 RID: 144
        private sealed class ContentReadStream : Stream
        {
            // Token: 0x0600036A RID: 874 RVA: 0x0003DF00 File Offset: 0x0001DF00
            internal ContentReadStream(Stream[] streams)
            {
                this._streams = streams;
                foreach (Stream stream in streams)
                {
                    this._length += stream.Length;
                }
            }

            // Token: 0x0600036B RID: 875 RVA: 0x0003DF44 File Offset: 0x0001DF44
            protected override void Dispose(bool disposing)
            {
                if (disposing)
                {
                    foreach (Stream stream in this._streams)
                    {
                        stream.Dispose();
                    }
                }
            }

            // Token: 0x170000CD RID: 205
            // (get) Token: 0x0600036C RID: 876 RVA: 0x0003607C File Offset: 0x0001607C
            public override bool CanRead
            {
                get
                {
                    return true;
                }
            }

            // Token: 0x170000CE RID: 206
            // (get) Token: 0x0600036D RID: 877 RVA: 0x0003607C File Offset: 0x0001607C
            public override bool CanSeek
            {
                get
                {
                    return true;
                }
            }

            // Token: 0x170000CF RID: 207
            // (get) Token: 0x0600036E RID: 878 RVA: 0x000356C2 File Offset: 0x000156C2
            public override bool CanWrite
            {
                get
                {
                    return false;
                }
            }

            // Token: 0x0600036F RID: 879 RVA: 0x0003DF74 File Offset: 0x0001DF74
            public override int Read(byte[] buffer, int offset, int count)
            {
                MultipartContent.ContentReadStream.ValidateReadArgs(buffer, offset, count);
                if (count == 0)
                {
                    return 0;
                }
                int num;
                for (; ; )
                {
                    if (this._current != null)
                    {
                        num = this._current.Read(buffer, offset, count);
                        if (num != 0)
                        {
                            break;
                        }
                        this._current = null;
                    }
                    if (this._next >= this._streams.Length)
                    {
                        return 0;
                    }
                    Stream[] streams = this._streams;
                    int next = this._next;
                    this._next = next + 1;
                    this._current = streams[next];
                }
                this._position += (long)num;
                return num;
            }

            // Token: 0x06000370 RID: 880 RVA: 0x0003DFF4 File Offset: 0x0001DFF4
            public override int Read(Span<byte> buffer)
            {
                if (buffer.Length == 0)
                {
                    return 0;
                }
                int num;
                for (; ; )
                {
                    if (this._current != null)
                    {
                        num = this._current.Read(buffer);
                        if (num != 0)
                        {
                            break;
                        }
                        this._current = null;
                    }
                    if (this._next >= this._streams.Length)
                    {
                        return 0;
                    }
                    Stream[] streams = this._streams;
                    int next = this._next;
                    this._next = next + 1;
                    this._current = streams[next];
                }
                this._position += (long)num;
                return num;
            }

            // Token: 0x06000371 RID: 881 RVA: 0x0003E070 File Offset: 0x0001E070
            public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
            {
                MultipartContent.ContentReadStream.ValidateReadArgs(buffer, offset, count);
                return this.ReadAsyncPrivate(new Memory<byte>(buffer, offset, count), cancellationToken).AsTask();
            }

            // Token: 0x06000372 RID: 882 RVA: 0x0003E09D File Offset: 0x0001E09D
            public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken))
            {
                return this.ReadAsyncPrivate(buffer, cancellationToken);
            }

            // Token: 0x06000373 RID: 883 RVA: 0x0003E0A7 File Offset: 0x0001E0A7
            public override IAsyncResult BeginRead(byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState)
            {
                return TaskToApm.Begin(this.ReadAsync(array, offset, count, CancellationToken.None), asyncCallback, asyncState);
            }

            // Token: 0x06000374 RID: 884 RVA: 0x000362A9 File Offset: 0x000162A9
            public override int EndRead(IAsyncResult asyncResult)
            {
                return TaskToApm.End<int>(asyncResult);
            }

            // Token: 0x06000375 RID: 885 RVA: 0x0003E0C0 File Offset: 0x0001E0C0
            public async ValueTask<int> ReadAsyncPrivate(Memory<byte> buffer, CancellationToken cancellationToken)
            {
                int result;
                if (buffer.Length == 0)
                {
                    result = 0;
                }
                else
                {
                    int num2;
                    for (; ; )
                    {
                        if (this._current != null)
                        {
                            int num = await this._current.ReadAsync(buffer, cancellationToken).ConfigureAwait(false);
                            num2 = num;
                            if (num2 != 0)
                            {
                                break;
                            }
                            this._current = null;
                        }
                        if (this._next >= this._streams.Length)
                        {
                            goto Block_4;
                        }
                        Stream[] streams = this._streams;
                        int next = this._next;
                        this._next = next + 1;
                        this._current = streams[next];
                    }
                    this._position += (long)num2;
                    return num2;
                    Block_4:
                    result = 0;
                }
                return result;
            }

            // Token: 0x170000D0 RID: 208
            // (get) Token: 0x06000376 RID: 886 RVA: 0x0003E115 File Offset: 0x0001E115
            // (set) Token: 0x06000377 RID: 887 RVA: 0x0003E120 File Offset: 0x0001E120
            public override long Position
            {
                get
                {
                    return this._position;
                }
                set
                {
                    if (value < 0L)
                    {
                        throw new ArgumentOutOfRangeException("value");
                    }
                    long num = 0L;
                    for (int i = 0; i < this._streams.Length; i++)
                    {
                        Stream stream = this._streams[i];
                        long length = stream.Length;
                        if (value < num + length)
                        {
                            this._current = stream;
                            i++;
                            this._next = i;
                            stream.Position = value - num;
                            while (i < this._streams.Length)
                            {
                                this._streams[i].Position = 0L;
                                i++;
                            }
                            this._position = value;
                            return;
                        }
                        num += length;
                    }
                    this._current = null;
                    this._next = this._streams.Length;
                    this._position = value;
                }
            }

            // Token: 0x06000378 RID: 888 RVA: 0x0003E1CC File Offset: 0x0001E1CC
            public override long Seek(long offset, SeekOrigin origin)
            {
                switch (origin)
                {
                    case SeekOrigin.Begin:
                        this.Position = offset;
                        break;
                    case SeekOrigin.Current:
                        this.Position += offset;
                        break;
                    case SeekOrigin.End:
                        this.Position = this._length + offset;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException("origin");
                }
                return this.Position;
            }

            // Token: 0x170000D1 RID: 209
            // (get) Token: 0x06000379 RID: 889 RVA: 0x0003E227 File Offset: 0x0001E227
            public override long Length
            {
                get
                {
                    return this._length;
                }
            }

            // Token: 0x0600037A RID: 890 RVA: 0x0003E230 File Offset: 0x0001E230
            private static void ValidateReadArgs(byte[] buffer, int offset, int count)
            {
                if (buffer == null)
                {
                    throw new ArgumentNullException("buffer");
                }
                if (offset < 0)
                {
                    throw new ArgumentOutOfRangeException("offset");
                }
                if (count < 0)
                {
                    throw new ArgumentOutOfRangeException("count");
                }
                if (offset > buffer.Length - count)
                {
                    throw new ArgumentException(SR.net_http_buffer_insufficient_length, "buffer");
                }
            }

            // Token: 0x0600037B RID: 891 RVA: 0x00034ED8 File Offset: 0x00014ED8
            public override void Flush()
            {
            }

            // Token: 0x0600037C RID: 892 RVA: 0x00036351 File Offset: 0x00016351
            public override void SetLength(long value)
            {
                throw new NotSupportedException();
            }

            // Token: 0x0600037D RID: 893 RVA: 0x00036351 File Offset: 0x00016351
            public override void Write(byte[] buffer, int offset, int count)
            {
                throw new NotSupportedException();
            }

            // Token: 0x0600037E RID: 894 RVA: 0x00036351 File Offset: 0x00016351
            public override void Write(ReadOnlySpan<byte> buffer)
            {
                throw new NotSupportedException();
            }

            // Token: 0x0600037F RID: 895 RVA: 0x00036351 File Offset: 0x00016351
            public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
            {
                throw new NotSupportedException();
            }

            // Token: 0x06000380 RID: 896 RVA: 0x00036351 File Offset: 0x00016351
            public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken))
            {
                throw new NotSupportedException();
            }

            // Token: 0x04000258 RID: 600
            private readonly Stream[] _streams;

            // Token: 0x04000259 RID: 601
            private readonly long _length;

            // Token: 0x0400025A RID: 602
            private int _next;

            // Token: 0x0400025B RID: 603
            private Stream _current;

            // Token: 0x0400025C RID: 604
            private long _position;
        }
    }


    /// <summary>
    ///         MIME の種類 multipart/form-data を使用してエンコードされたコンテンツのコンテナーを提供します。
    ///       </summary>
    // Token: 0x02000094 RID: 148
    class MultipartFormDataContent : MultipartContent
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.MultipartFormDataContent" /> クラスの新しいインスタンスを作成します。
        ///       </summary>
        // Token: 0x06000387 RID: 903 RVA: 0x0003E9DA File Offset: 0x0001E9DA
        public MultipartFormDataContent() : base("form-data")
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.MultipartFormDataContent" /> クラスの新しいインスタンスを作成します。
        ///       </summary>
        /// <param name="boundary">
        ///           マルチパートのフォームのデータ コンテンツの境界文字列。
        ///         </param>
        /// <exception cref="T:System.ArgumentException">
        ///             <paramref name="boundary" /> は <see langword="null" /> であったか、空白文字だけを格納します。
        ///
        ///             または
        ///
        ///             <paramref name="boundary" /> が空白文字で終わっています。
        ///           </exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///             <paramref name="boundary" /> の長さが 70 を超えていました。
        ///           </exception>
        // Token: 0x06000388 RID: 904 RVA: 0x0003E9E7 File Offset: 0x0001E9E7
        public MultipartFormDataContent(string boundary) : base("form-data", boundary)
        {
        }

        /// <summary>
        ///         HTTP コンテンツのコレクションを追加 <see cref="T:System.Net.Http.HttpContent" /> マルチパート/フォーム データの MIME の種類をシリアル化されるオブジェクト。
        ///       </summary>
        /// <param name="content">
        ///           コレクションに追加する HTTP コンテンツ。
        ///         </param>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="content" /> が <see langword="null" />でした。
        ///           </exception>
        // Token: 0x06000389 RID: 905 RVA: 0x0003E9F5 File Offset: 0x0001E9F5
        public override void Add(HttpContent content)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            if (content.Headers.ContentDisposition == null)
            {
                content.Headers.ContentDisposition = new ContentDispositionHeaderValue("form-data");
            }
            base.Add(content);
        }

        /// <summary>
        ///         HTTP コンテンツのコレクションを追加 <see cref="T:System.Net.Http.HttpContent" /> マルチパート/フォーム データの MIME の種類をシリアル化されるオブジェクト。
        ///       </summary>
        /// <param name="content">
        ///           コレクションに追加する HTTP コンテンツ。
        ///         </param>
        /// <param name="name">
        ///           HTTP コンテンツを追加する名前。
        ///         </param>
        /// <exception cref="T:System.ArgumentException">
        ///             <paramref name="name" /> が <see langword="null" /> または空白文字だけが含まれています。
        ///           </exception>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="content" /> が <see langword="null" />でした。
        ///           </exception>
        // Token: 0x0600038A RID: 906 RVA: 0x0003EA2E File Offset: 0x0001EA2E
        public void Add(HttpContent content, string name)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            if (string.IsNullOrWhiteSpace(name))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, "name");
            }
            this.AddInternal(content, name, null);
        }

        /// <summary>
        ///         HTTP コンテンツのコレクションを追加 <see cref="T:System.Net.Http.HttpContent" /> マルチパート/フォーム データの MIME の種類をシリアル化されるオブジェクト。
        ///       </summary>
        /// <param name="content">
        ///           コレクションに追加する HTTP コンテンツ。
        ///         </param>
        /// <param name="name">
        ///           HTTP コンテンツを追加する名前。
        ///         </param>
        /// <param name="fileName">
        ///           HTTP コンテンツをコレクションに追加するファイルの名前。
        ///         </param>
        /// <exception cref="T:System.ArgumentException">
        ///             <paramref name="name" /> が <see langword="null" /> または空白文字だけが含まれています。
        ///
        ///             または
        ///
        ///             <paramref name="fileName" /> が <see langword="null" /> または空白文字だけが含まれています。
        ///           </exception>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="content" /> が <see langword="null" />でした。
        ///           </exception>
        // Token: 0x0600038B RID: 907 RVA: 0x0003EA60 File Offset: 0x0001EA60
        public void Add(HttpContent content, string name, string fileName)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            if (string.IsNullOrWhiteSpace(name))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, "name");
            }
            if (string.IsNullOrWhiteSpace(fileName))
            {
                throw new ArgumentException(SR.net_http_argument_empty_string, "fileName");
            }
            this.AddInternal(content, name, fileName);
        }

        // Token: 0x0600038C RID: 908 RVA: 0x0003EAB4 File Offset: 0x0001EAB4
        private void AddInternal(HttpContent content, string name, string fileName)
        {
            if (content.Headers.ContentDisposition == null)
            {
                ContentDispositionHeaderValue contentDispositionHeaderValue = new ContentDispositionHeaderValue("form-data");
                contentDispositionHeaderValue.Name = name;
                contentDispositionHeaderValue.FileName = fileName;
                contentDispositionHeaderValue.FileNameStar = fileName;
                content.Headers.ContentDisposition = contentDispositionHeaderValue;
            }
            base.Add(content);
        }
    }

    // Token: 0x02000115 RID: 277
    internal sealed class NoWriteNoSeekStreamContent : HttpContent
    {
        // Token: 0x060006B3 RID: 1715 RVA: 0x00051B9A File Offset: 0x00031B9A
        internal NoWriteNoSeekStreamContent(Stream content)
        {
            this._content = content;
        }

        // Token: 0x060006B4 RID: 1716 RVA: 0x00043E9D File Offset: 0x00023E9D
        protected override Task SerializeToStreamAsync(Stream stream, TransportContext context)
        {
            return this.SerializeToStreamAsync(stream, context, CancellationToken.None);
        }

        // Token: 0x060006B5 RID: 1717 RVA: 0x00051BAC File Offset: 0x00031BAC
        internal override Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken)
        {
            if (this._contentConsumed)
            {
                throw new InvalidOperationException(SR.net_http_content_stream_already_read);
            }
            this._contentConsumed = true;
            Task task = this._content.CopyToAsync(stream, 8192, cancellationToken);
            if (task.IsCompleted)
            {
                try
                {
                    this._content.Dispose();
                    return task;
                }
                catch
                {
                    return task;
                }
            }
            task = task.ContinueWith(delegate (Task t, object s)
            {
                try
                {
                    ((Stream)s).Dispose();
                }
                catch
                {
                }
                t.GetAwaiter().GetResult();
            }, this._content, CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);
            return task;
        }

        // Token: 0x060006B6 RID: 1718 RVA: 0x00043F01 File Offset: 0x00023F01
        protected internal override bool TryComputeLength(out long length)
        {
            length = 0L;
            return false;
        }

        // Token: 0x060006B7 RID: 1719 RVA: 0x00051C4C File Offset: 0x00031C4C
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                this._content.Dispose();
            }
            base.Dispose(disposing);
        }

        // Token: 0x060006B8 RID: 1720 RVA: 0x00051C63 File Offset: 0x00031C63
        protected override Task<Stream> CreateContentReadStreamAsync()
        {
            return Task.FromResult<Stream>(this._content);
        }

        // Token: 0x060006B9 RID: 1721 RVA: 0x00051C70 File Offset: 0x00031C70
        internal override Stream TryCreateContentReadStream()
        {
            return this._content;
        }

        // Token: 0x04000501 RID: 1281
        private readonly Stream _content;

        // Token: 0x04000502 RID: 1282
        private bool _contentConsumed;
    }

    // Token: 0x02000095 RID: 149
    sealed class ReadOnlyMemoryContent : HttpContent
    {
        // Token: 0x0600038D RID: 909 RVA: 0x0003EB04 File Offset: 0x0001EB04
        public ReadOnlyMemoryContent(ReadOnlyMemory<byte> content)
        {
            this._content = content;
            ArraySegment<byte> arraySegment;
            if (MemoryMarshal.TryGetArray<byte>(content, out arraySegment))
            {
                base.SetBuffer(arraySegment.Array, arraySegment.Offset, arraySegment.Count);
            }
        }

        // Token: 0x0600038E RID: 910 RVA: 0x0003EB44 File Offset: 0x0001EB44
        protected override Task SerializeToStreamAsync(Stream stream, TransportContext context)
        {
            return stream.WriteAsync(this._content, default(CancellationToken)).AsTask();
        }

        // Token: 0x0600038F RID: 911 RVA: 0x0003EB70 File Offset: 0x0001EB70
        internal override Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken)
        {
            return stream.WriteAsync(this._content, cancellationToken).AsTask();
        }

        // Token: 0x06000390 RID: 912 RVA: 0x0003EB92 File Offset: 0x0001EB92
        protected internal override bool TryComputeLength(out long length)
        {
            length = (long)this._content.Length;
            return true;
        }

        // Token: 0x06000391 RID: 913 RVA: 0x0003EBA3 File Offset: 0x0001EBA3
        protected override Task<Stream> CreateContentReadStreamAsync()
        {
            return Task.FromResult<Stream>(new ReadOnlyMemoryStream(this._content));
        }

        // Token: 0x06000392 RID: 914 RVA: 0x0003EBB5 File Offset: 0x0001EBB5
        internal override Stream TryCreateContentReadStream()
        {
            return new ReadOnlyMemoryStream(this._content);
        }

        // Token: 0x04000274 RID: 628
        private readonly ReadOnlyMemory<byte> _content;
    }

    // Token: 0x020000FA RID: 250
    internal sealed class RedirectHandler : HttpMessageHandler
    {
        // Token: 0x060005B2 RID: 1458 RVA: 0x0004C0C4 File Offset: 0x0002C0C4
        public RedirectHandler(int maxAutomaticRedirections, HttpMessageHandler initialInnerHandler, HttpMessageHandler redirectInnerHandler)
        {
            this._maxAutomaticRedirections = maxAutomaticRedirections;
            this._initialInnerHandler = initialInnerHandler;
            this._redirectInnerHandler = redirectInnerHandler;
        }

        // Token: 0x060005B3 RID: 1459 RVA: 0x0004C0E4 File Offset: 0x0002C0E4
        protected internal override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Enter(this, request, cancellationToken, "SendAsync");
            }
            HttpResponseMessage httpResponseMessage = await this._initialInnerHandler.SendAsync(request, cancellationToken).ConfigureAwait(false);
            HttpResponseMessage httpResponseMessage2 = httpResponseMessage;
            uint redirectCount = 0u;
            Uri uriForRedirect;
            while ((uriForRedirect = this.GetUriForRedirect(request.RequestUri, httpResponseMessage2)) != null)
            {
                redirectCount += 1u;
                if ((ulong)redirectCount > (ulong)((long)this._maxAutomaticRedirections))
                {
                    if (NetEventSource.IsEnabled)
                    {
                        NetEventSource.Error(this, FormattableStringFactory.Create("Exceeded max number of redirects. Redirect from {0} to {1} blocked.", new object[]
                        {
                            request.RequestUri,
                            uriForRedirect
                        }), "SendAsync");
                        break;
                    }
                    break;
                }
                else
                {
                    httpResponseMessage2.Dispose();
                    request.Headers.Authorization = null;
                    request.RequestUri = uriForRedirect;
                    if (RedirectHandler.RequestRequiresForceGet(httpResponseMessage2.StatusCode, request.Method))
                    {
                        request.Method = HttpMethod.Get;
                        request.Content = null;
                        request.Headers.TransferEncodingChunked = new bool?(false);
                    }
                    httpResponseMessage2 = await this._redirectInnerHandler.SendAsync(request, cancellationToken).ConfigureAwait(false);
                }
            }
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Exit(this, null, "SendAsync");
            }
            return httpResponseMessage2;
        }

        // Token: 0x060005B4 RID: 1460 RVA: 0x0004C13C File Offset: 0x0002C13C
        private Uri GetUriForRedirect(Uri requestUri, HttpResponseMessage response)
        {
            HttpStatusCode statusCode = response.StatusCode;
            if (statusCode - HttpStatusCode.MultipleChoices > 3 && statusCode - HttpStatusCode.TemporaryRedirect > 1)
            {
                return null;
            }
            Uri uri = response.Headers.Location;
            if (uri == null)
            {
                return null;
            }
            if (!uri.IsAbsoluteUri)
            {
                uri = new Uri(requestUri, uri);
            }
            string fragment = requestUri.Fragment;
            if (!string.IsNullOrEmpty(fragment))
            {
                string fragment2 = uri.Fragment;
                if (string.IsNullOrEmpty(fragment2))
                {
                    uri = new UriBuilder(uri)
                    {
                        Fragment = fragment
                    }.Uri;
                }
            }
            if (HttpUtilities.IsSupportedSecureScheme(requestUri.Scheme) && !HttpUtilities.IsSupportedSecureScheme(uri.Scheme))
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(this, FormattableStringFactory.Create("Insecure https to http redirect from '{0}' to '{1}' blocked.", new object[]
                    {
                        requestUri,
                        uri
                    }), "GetUriForRedirect");
                }
                return null;
            }
            return uri;
        }

        // Token: 0x060005B5 RID: 1461 RVA: 0x0004C205 File Offset: 0x0002C205
        private static bool RequestRequiresForceGet(HttpStatusCode statusCode, HttpMethod requestMethod)
        {
            return statusCode - HttpStatusCode.MultipleChoices <= 3 && requestMethod == HttpMethod.Post;
        }

        // Token: 0x060005B6 RID: 1462 RVA: 0x0004C21E File Offset: 0x0002C21E
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                this._initialInnerHandler.Dispose();
                this._redirectInnerHandler.Dispose();
            }
            base.Dispose(disposing);
        }

        // Token: 0x04000471 RID: 1137
        private readonly HttpMessageHandler _initialInnerHandler;

        // Token: 0x04000472 RID: 1138
        private readonly HttpMessageHandler _redirectInnerHandler;

        // Token: 0x04000473 RID: 1139
        private readonly int _maxAutomaticRedirections;
    }



    // Token: 0x020000F9 RID: 249
    sealed class SocketsHttpHandler : HttpMessageHandler
    {
        readonly TcpIpSystem TcpIpSystem;

        public SocketsHttpHandler(TcpIpSystem tcpIpSystem)
        {
            TcpIpSystem = tcpIpSystem;

            this._settings = new HttpConnectionSettings();
            this._settings._tcpIpSystem = this.TcpIpSystem;
        }

        // Token: 0x06000584 RID: 1412 RVA: 0x0004B9B9 File Offset: 0x0002B9B9
        private void CheckDisposed()
        {
            if (this._disposed)
            {
                throw new ObjectDisposedException("SocketsHttpHandler");
            }
        }

        // Token: 0x06000585 RID: 1413 RVA: 0x0004B9CE File Offset: 0x0002B9CE
        private void CheckDisposedOrStarted()
        {
            this.CheckDisposed();
            if (this._handler != null)
            {
                throw new InvalidOperationException(SR.net_http_operation_started);
            }
        }

        // Token: 0x17000105 RID: 261
        // (get) Token: 0x06000586 RID: 1414 RVA: 0x0004B9E9 File Offset: 0x0002B9E9
        // (set) Token: 0x06000587 RID: 1415 RVA: 0x0004B9F6 File Offset: 0x0002B9F6
        public bool UseCookies
        {
            get
            {
                return this._settings._useCookies;
            }
            set
            {
                this.CheckDisposedOrStarted();
                this._settings._useCookies = value;
            }
        }

        // Token: 0x17000106 RID: 262
        // (get) Token: 0x06000588 RID: 1416 RVA: 0x0004BA0C File Offset: 0x0002BA0C
        // (set) Token: 0x06000589 RID: 1417 RVA: 0x0004BA3B File Offset: 0x0002BA3B
        public CookieContainer CookieContainer
        {
            get
            {
                CookieContainer result;
                if ((result = this._settings._cookieContainer) == null)
                {
                    result = (this._settings._cookieContainer = new CookieContainer());
                }
                return result;
            }
            set
            {
                this.CheckDisposedOrStarted();
                this._settings._cookieContainer = value;
            }
        }

        // Token: 0x17000107 RID: 263
        // (get) Token: 0x0600058A RID: 1418 RVA: 0x0004BA4F File Offset: 0x0002BA4F
        // (set) Token: 0x0600058B RID: 1419 RVA: 0x0004BA5C File Offset: 0x0002BA5C
        public DecompressionMethods AutomaticDecompression
        {
            get
            {
                return this._settings._automaticDecompression;
            }
            set
            {
                this.CheckDisposedOrStarted();
                this._settings._automaticDecompression = value;
            }
        }

        // Token: 0x17000108 RID: 264
        // (get) Token: 0x0600058C RID: 1420 RVA: 0x0004BA70 File Offset: 0x0002BA70
        // (set) Token: 0x0600058D RID: 1421 RVA: 0x0004BA7D File Offset: 0x0002BA7D
        public bool UseProxy
        {
            get
            {
                return this._settings._useProxy;
            }
            set
            {
                this.CheckDisposedOrStarted();
                this._settings._useProxy = value;
            }
        }

        // Token: 0x17000109 RID: 265
        // (get) Token: 0x0600058E RID: 1422 RVA: 0x0004BA91 File Offset: 0x0002BA91
        // (set) Token: 0x0600058F RID: 1423 RVA: 0x0004BA9E File Offset: 0x0002BA9E
        public IWebProxy Proxy
        {
            get
            {
                return this._settings._proxy;
            }
            set
            {
                this.CheckDisposedOrStarted();
                this._settings._proxy = value;
            }
        }

        // Token: 0x1700010A RID: 266
        // (get) Token: 0x06000590 RID: 1424 RVA: 0x0004BAB2 File Offset: 0x0002BAB2
        // (set) Token: 0x06000591 RID: 1425 RVA: 0x0004BABF File Offset: 0x0002BABF
        public ICredentials DefaultProxyCredentials
        {
            get
            {
                return this._settings._defaultProxyCredentials;
            }
            set
            {
                this.CheckDisposedOrStarted();
                this._settings._defaultProxyCredentials = value;
            }
        }

        // Token: 0x1700010B RID: 267
        // (get) Token: 0x06000592 RID: 1426 RVA: 0x0004BAD3 File Offset: 0x0002BAD3
        // (set) Token: 0x06000593 RID: 1427 RVA: 0x0004BAE0 File Offset: 0x0002BAE0
        public bool PreAuthenticate
        {
            get
            {
                return this._settings._preAuthenticate;
            }
            set
            {
                this.CheckDisposedOrStarted();
                this._settings._preAuthenticate = value;
            }
        }

        // Token: 0x1700010C RID: 268
        // (get) Token: 0x06000594 RID: 1428 RVA: 0x0004BAF4 File Offset: 0x0002BAF4
        // (set) Token: 0x06000595 RID: 1429 RVA: 0x0004BB01 File Offset: 0x0002BB01
        public ICredentials Credentials
        {
            get
            {
                return this._settings._credentials;
            }
            set
            {
                this.CheckDisposedOrStarted();
                this._settings._credentials = value;
            }
        }

        // Token: 0x1700010D RID: 269
        // (get) Token: 0x06000596 RID: 1430 RVA: 0x0004BB15 File Offset: 0x0002BB15
        // (set) Token: 0x06000597 RID: 1431 RVA: 0x0004BB22 File Offset: 0x0002BB22
        public bool AllowAutoRedirect
        {
            get
            {
                return this._settings._allowAutoRedirect;
            }
            set
            {
                this.CheckDisposedOrStarted();
                this._settings._allowAutoRedirect = value;
            }
        }

        // Token: 0x1700010E RID: 270
        // (get) Token: 0x06000598 RID: 1432 RVA: 0x0004BB36 File Offset: 0x0002BB36
        // (set) Token: 0x06000599 RID: 1433 RVA: 0x0004BB43 File Offset: 0x0002BB43
        public int MaxAutomaticRedirections
        {
            get
            {
                return this._settings._maxAutomaticRedirections;
            }
            set
            {
                if (value < 1)
                {
                    throw new ArgumentOutOfRangeException("value", value, SR.Format(SR.net_http_value_must_be_greater_than, 0));
                }
                this.CheckDisposedOrStarted();
                this._settings._maxAutomaticRedirections = value;
            }
        }

        // Token: 0x1700010F RID: 271
        // (get) Token: 0x0600059A RID: 1434 RVA: 0x0004BB7C File Offset: 0x0002BB7C
        // (set) Token: 0x0600059B RID: 1435 RVA: 0x0004BB89 File Offset: 0x0002BB89
        public int MaxConnectionsPerServer
        {
            get
            {
                return this._settings._maxConnectionsPerServer;
            }
            set
            {
                if (value < 1)
                {
                    throw new ArgumentOutOfRangeException("value", value, SR.Format(SR.net_http_value_must_be_greater_than, 0));
                }
                this.CheckDisposedOrStarted();
                this._settings._maxConnectionsPerServer = value;
            }
        }

        // Token: 0x17000110 RID: 272
        // (get) Token: 0x0600059C RID: 1436 RVA: 0x0004BBC2 File Offset: 0x0002BBC2
        // (set) Token: 0x0600059D RID: 1437 RVA: 0x0004BBCF File Offset: 0x0002BBCF
        public int MaxResponseDrainSize
        {
            get
            {
                return this._settings._maxResponseDrainSize;
            }
            set
            {
                if (value < 0)
                {
                    throw new ArgumentOutOfRangeException("value", value, SR.ArgumentOutOfRange_NeedNonNegativeNum);
                }
                this.CheckDisposedOrStarted();
                this._settings._maxResponseDrainSize = value;
            }
        }

        // Token: 0x17000111 RID: 273
        // (get) Token: 0x0600059E RID: 1438 RVA: 0x0004BBFD File Offset: 0x0002BBFD
        // (set) Token: 0x0600059F RID: 1439 RVA: 0x0004BC0C File Offset: 0x0002BC0C
        public TimeSpan ResponseDrainTimeout
        {
            get
            {
                return this._settings._maxResponseDrainTime;
            }
            set
            {
                if ((value < TimeSpan.Zero && value != Timeout.InfiniteTimeSpan) || value.TotalMilliseconds > 2147483647.0)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                this.CheckDisposedOrStarted();
                this._settings._maxResponseDrainTime = value;
            }
        }

        // Token: 0x17000112 RID: 274
        // (get) Token: 0x060005A0 RID: 1440 RVA: 0x0004BC62 File Offset: 0x0002BC62
        // (set) Token: 0x060005A1 RID: 1441 RVA: 0x0004BC6F File Offset: 0x0002BC6F
        public int MaxResponseHeadersLength
        {
            get
            {
                return this._settings._maxResponseHeadersLength;
            }
            set
            {
                if (value <= 0)
                {
                    throw new ArgumentOutOfRangeException("value", value, SR.Format(SR.net_http_value_must_be_greater_than, 0));
                }
                this.CheckDisposedOrStarted();
                this._settings._maxResponseHeadersLength = value;
            }
        }

        // Token: 0x17000113 RID: 275
        // (get) Token: 0x060005A2 RID: 1442 RVA: 0x0004BCA8 File Offset: 0x0002BCA8
        // (set) Token: 0x060005A3 RID: 1443 RVA: 0x0004BCD7 File Offset: 0x0002BCD7
        public SslClientAuthenticationOptions SslOptions
        {
            get
            {
                SslClientAuthenticationOptions result;
                if ((result = this._settings._sslOptions) == null)
                {
                    result = (this._settings._sslOptions = new SslClientAuthenticationOptions());
                }
                return result;
            }
            set
            {
                this.CheckDisposedOrStarted();
                this._settings._sslOptions = value;
            }
        }

        // Token: 0x17000114 RID: 276
        // (get) Token: 0x060005A4 RID: 1444 RVA: 0x0004BCEB File Offset: 0x0002BCEB
        // (set) Token: 0x060005A5 RID: 1445 RVA: 0x0004BCF8 File Offset: 0x0002BCF8
        public TimeSpan PooledConnectionLifetime
        {
            get
            {
                return this._settings._pooledConnectionLifetime;
            }
            set
            {
                if (value < TimeSpan.Zero && value != Timeout.InfiniteTimeSpan)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                this.CheckDisposedOrStarted();
                this._settings._pooledConnectionLifetime = value;
            }
        }

        // Token: 0x17000115 RID: 277
        // (get) Token: 0x060005A6 RID: 1446 RVA: 0x0004BD31 File Offset: 0x0002BD31
        // (set) Token: 0x060005A7 RID: 1447 RVA: 0x0004BD3E File Offset: 0x0002BD3E
        public TimeSpan PooledConnectionIdleTimeout
        {
            get
            {
                return this._settings._pooledConnectionIdleTimeout;
            }
            set
            {
                if (value < TimeSpan.Zero && value != Timeout.InfiniteTimeSpan)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                this.CheckDisposedOrStarted();
                this._settings._pooledConnectionIdleTimeout = value;
            }
        }

        // Token: 0x17000116 RID: 278
        // (get) Token: 0x060005A8 RID: 1448 RVA: 0x0004BD77 File Offset: 0x0002BD77
        // (set) Token: 0x060005A9 RID: 1449 RVA: 0x0004BD84 File Offset: 0x0002BD84
        public TimeSpan ConnectTimeout
        {
            get
            {
                return this._settings._connectTimeout;
            }
            set
            {
                if ((value <= TimeSpan.Zero && value != Timeout.InfiniteTimeSpan) || value.TotalMilliseconds > 2147483647.0)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                this.CheckDisposedOrStarted();
                this._settings._connectTimeout = value;
            }
        }

        // Token: 0x17000117 RID: 279
        // (get) Token: 0x060005AA RID: 1450 RVA: 0x0004BDDA File Offset: 0x0002BDDA
        // (set) Token: 0x060005AB RID: 1451 RVA: 0x0004BDE8 File Offset: 0x0002BDE8
        public TimeSpan Expect100ContinueTimeout
        {
            get
            {
                return this._settings._expect100ContinueTimeout;
            }
            set
            {
                if ((value < TimeSpan.Zero && value != Timeout.InfiniteTimeSpan) || value.TotalMilliseconds > 2147483647.0)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                this.CheckDisposedOrStarted();
                this._settings._expect100ContinueTimeout = value;
            }
        }

        // Token: 0x17000118 RID: 280
        // (get) Token: 0x060005AC RID: 1452 RVA: 0x0004BE40 File Offset: 0x0002BE40
        public IDictionary<string, object> Properties
        {
            get
            {
                IDictionary<string, object> result;
                if ((result = this._settings._properties) == null)
                {
                    result = (this._settings._properties = new Dictionary<string, object>());
                }
                return result;
            }
        }

        // Token: 0x060005AD RID: 1453 RVA: 0x0004BE6F File Offset: 0x0002BE6F
        protected override void Dispose(bool disposing)
        {
            if (disposing && !this._disposed)
            {
                this._disposed = true;
                HttpMessageHandler handler = this._handler;
                if (handler != null)
                {
                    handler.Dispose();
                }
            }
            base.Dispose(disposing);
        }

        // Token: 0x060005AE RID: 1454 RVA: 0x0004BE9C File Offset: 0x0002BE9C
        private HttpMessageHandler SetupHandlerChain()
        {
            HttpConnectionSettings httpConnectionSettings = this._settings.Clone();
            HttpConnectionPoolManager poolManager = new HttpConnectionPoolManager(httpConnectionSettings);
            HttpMessageHandler httpMessageHandler;
            if (httpConnectionSettings._credentials == null)
            {
                httpMessageHandler = new HttpConnectionHandler(poolManager);
            }
            else
            {
                httpMessageHandler = new HttpAuthenticatedConnectionHandler(poolManager);
            }
            if (httpConnectionSettings._allowAutoRedirect)
            {
                HttpMessageHandler redirectInnerHandler = (httpConnectionSettings._credentials == null || httpConnectionSettings._credentials is CredentialCache) ? httpMessageHandler : new HttpConnectionHandler(poolManager);
                httpMessageHandler = new RedirectHandler(httpConnectionSettings._maxAutomaticRedirections, httpMessageHandler, redirectInnerHandler);
            }
            if (httpConnectionSettings._automaticDecompression != DecompressionMethods.None)
            {
                httpMessageHandler = new DecompressionHandler(httpConnectionSettings._automaticDecompression, httpMessageHandler);
            }
            if (Interlocked.CompareExchange<HttpMessageHandler>(ref this._handler, httpMessageHandler, null) != null)
            {
                httpMessageHandler.Dispose();
            }
            return this._handler;
        }

        // Token: 0x060005AF RID: 1455 RVA: 0x0004BF3C File Offset: 0x0002BF3C
        protected internal override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            this.CheckDisposed();
            HttpMessageHandler httpMessageHandler = this._handler ?? this.SetupHandlerChain();
            Exception ex = this.ValidateAndNormalizeRequest(request);
            if (ex != null)
            {
                return Task.FromException<HttpResponseMessage>(ex);
            }
            return httpMessageHandler.SendAsync(request, cancellationToken);
        }

        // Token: 0x060005B0 RID: 1456 RVA: 0x0004BF7C File Offset: 0x0002BF7C
        private Exception ValidateAndNormalizeRequest(HttpRequestMessage request)
        {
            if (request.Version.Major == 0)
            {
                return new NotSupportedException(SR.net_http_unsupported_version);
            }
            if (request.HasHeaders && request.Headers.TransferEncodingChunked.GetValueOrDefault())
            {
                if (request.Content == null)
                {
                    return new HttpRequestException(SR.net_http_client_execution_error, new InvalidOperationException(SR.net_http_chunked_not_allowed_with_empty_content));
                }
                request.Content.Headers.ContentLength = null;
            }
            else if (request.Content != null && request.Content.Headers.ContentLength == null)
            {
                request.Headers.TransferEncodingChunked = new bool?(true);
            }
            if (request.Version.Minor == 0 && request.Version.Major == 1 && request.HasHeaders)
            {
                if (request.Headers.TransferEncodingChunked == true)
                {
                    return new NotSupportedException(SR.net_http_unsupported_chunking);
                }
                if (request.Headers.ExpectContinue == true)
                {
                    request.Headers.ExpectContinue = new bool?(false);
                }
            }
            return null;
        }

        // Token: 0x0400046E RID: 1134
        private readonly HttpConnectionSettings _settings;

        // Token: 0x0400046F RID: 1135
        private HttpMessageHandler _handler;

        // Token: 0x04000470 RID: 1136
        private bool _disposed;
    }

    /// <summary>
    ///         ストリームに基づく HTTP コンテンツを提供します。
    ///       </summary>
    // Token: 0x02000096 RID: 150
    class StreamContent : HttpContent
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.StreamContent" /> クラスの新しいインスタンスを作成します。
        ///       </summary>
        /// <param name="content">
        ///           <see cref="T:System.Net.Http.StreamContent" /> の初期化に使用されるコンテンツ。
        ///         </param>
        // Token: 0x06000393 RID: 915 RVA: 0x0003EBC2 File Offset: 0x0001EBC2
        public StreamContent(Stream content)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            this.InitializeContent(content, 0);
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.StreamContent" /> クラスの新しいインスタンスを作成します。
        ///       </summary>
        /// <param name="content">
        ///           <see cref="T:System.Net.Http.StreamContent" /> の初期化に使用されるコンテンツ。
        ///         </param>
        /// <param name="bufferSize">
        ///           <see cref="T:System.Net.Http.StreamContent" /> のバッファーのサイズ (バイト単位)。
        ///         </param>
        /// <exception cref="T:System.ArgumentNullException">
        ///             <paramref name="content" /> が <see langword="null" />でした。
        ///           </exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///             <paramref name="bufferSize" /> が 0 以下でした。
        ///           </exception>
        // Token: 0x06000394 RID: 916 RVA: 0x0003EBE0 File Offset: 0x0001EBE0
        public StreamContent(Stream content, int bufferSize)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            if (bufferSize <= 0)
            {
                throw new ArgumentOutOfRangeException("bufferSize");
            }
            this.InitializeContent(content, bufferSize);
        }

        // Token: 0x06000395 RID: 917 RVA: 0x0003EC0D File Offset: 0x0001EC0D
        private void InitializeContent(Stream content, int bufferSize)
        {
            this._content = content;
            this._bufferSize = bufferSize;
            if (content.CanSeek)
            {
                this._start = content.Position;
            }
            if (NetEventSource.IsEnabled)
            {
                NetEventSource.Associate(this, content, "InitializeContent");
            }
        }

        /// <summary>
        ///         非同期操作として HTTP コンテンツをストリームにシリアル化します。
        ///       </summary>
        /// <param name="stream">
        ///           対象のストリーム。
        ///         </param>
        /// <param name="context">
        ///           トランスポート (チャネル バインディング トークンなど) について説明します。
        ///            このパラメーターは <see langword="null" /> でもかまいません。
        ///         </param>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x06000396 RID: 918 RVA: 0x0003EC44 File Offset: 0x0001EC44
        protected override Task SerializeToStreamAsync(Stream stream, TransportContext context)
        {
            this.PrepareContent();
            return StreamToStreamCopy.CopyAsync(this._content, stream, this._bufferSize, !this._content.CanSeek, default(CancellationToken));
        }

        /// <summary>
        ///         ストリーム コンテンツが有効なバイト長であるかどうかを判断します。
        ///       </summary>
        /// <param name="length">
        ///           ストリーム コンテンツの長さ (バイト単位)。
        ///         </param>
        /// <returns>
        ///         <paramref name="length" /> が有効な長さの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。
        ///       </returns>
        // Token: 0x06000397 RID: 919 RVA: 0x0003EC80 File Offset: 0x0001EC80
        protected internal override bool TryComputeLength(out long length)
        {
            if (this._content.CanSeek)
            {
                length = this._content.Length - this._start;
                return true;
            }
            length = 0L;
            return false;
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.StreamContent" /> が使用しているアンマネージ リソースを解放します。オプションとして、マネージ リソースを破棄することもできます。
        ///       </summary>
        /// <param name="disposing">
        ///           マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。
        ///         </param>
        // Token: 0x06000398 RID: 920 RVA: 0x0003ECAA File Offset: 0x0001ECAA
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                this._content.Dispose();
            }
            base.Dispose(disposing);
        }

        /// <summary>
        ///         非同期操作として HTTP ストリーム コンテンツをメモリ ストリームに書き込みます。
        ///       </summary>
        /// <returns>
        ///         非同期操作を表すタスク オブジェクト。
        ///       </returns>
        // Token: 0x06000399 RID: 921 RVA: 0x0003ECC1 File Offset: 0x0001ECC1
        protected override Task<Stream> CreateContentReadStreamAsync()
        {
            return Task.FromResult<Stream>(new StreamContent.ReadOnlyStream(this._content));
        }

        // Token: 0x0600039A RID: 922 RVA: 0x0003ECD3 File Offset: 0x0001ECD3
        internal override Stream TryCreateContentReadStream()
        {
            if (!(base.GetType() == typeof(StreamContent)))
            {
                return null;
            }
            return new StreamContent.ReadOnlyStream(this._content);
        }

        // Token: 0x0600039B RID: 923 RVA: 0x0003ECF9 File Offset: 0x0001ECF9
        private void PrepareContent()
        {
            if (this._contentConsumed)
            {
                if (!this._content.CanSeek)
                {
                    throw new InvalidOperationException(SR.net_http_content_stream_already_read);
                }
                this._content.Position = this._start;
            }
            this._contentConsumed = true;
        }

        // Token: 0x04000275 RID: 629
        private Stream _content;

        // Token: 0x04000276 RID: 630
        private int _bufferSize;

        // Token: 0x04000277 RID: 631
        private bool _contentConsumed;

        // Token: 0x04000278 RID: 632
        private long _start;

        // Token: 0x02000097 RID: 151
        private sealed class ReadOnlyStream : DelegatingStream
        {
            // Token: 0x170000D2 RID: 210
            // (get) Token: 0x0600039C RID: 924 RVA: 0x000356C2 File Offset: 0x000156C2
            public override bool CanWrite
            {
                get
                {
                    return false;
                }
            }

            // Token: 0x170000D3 RID: 211
            // (get) Token: 0x0600039D RID: 925 RVA: 0x0003ED35 File Offset: 0x0001ED35
            // (set) Token: 0x0600039E RID: 926 RVA: 0x0003ED35 File Offset: 0x0001ED35
            public override int WriteTimeout
            {
                get
                {
                    throw new NotSupportedException(SR.net_http_content_readonly_stream);
                }
                set
                {
                    throw new NotSupportedException(SR.net_http_content_readonly_stream);
                }
            }

            // Token: 0x0600039F RID: 927 RVA: 0x0003ED41 File Offset: 0x0001ED41
            public ReadOnlyStream(Stream innerStream) : base(innerStream)
            {
            }

            // Token: 0x060003A0 RID: 928 RVA: 0x0003ED35 File Offset: 0x0001ED35
            public override void Flush()
            {
                throw new NotSupportedException(SR.net_http_content_readonly_stream);
            }

            // Token: 0x060003A1 RID: 929 RVA: 0x0003ED35 File Offset: 0x0001ED35
            public override Task FlushAsync(CancellationToken cancellationToken)
            {
                throw new NotSupportedException(SR.net_http_content_readonly_stream);
            }

            // Token: 0x060003A2 RID: 930 RVA: 0x0003ED35 File Offset: 0x0001ED35
            public override void SetLength(long value)
            {
                throw new NotSupportedException(SR.net_http_content_readonly_stream);
            }

            // Token: 0x060003A3 RID: 931 RVA: 0x0003ED35 File Offset: 0x0001ED35
            public override void Write(byte[] buffer, int offset, int count)
            {
                throw new NotSupportedException(SR.net_http_content_readonly_stream);
            }

            // Token: 0x060003A4 RID: 932 RVA: 0x0003ED35 File Offset: 0x0001ED35
            public override void Write(ReadOnlySpan<byte> buffer)
            {
                throw new NotSupportedException(SR.net_http_content_readonly_stream);
            }

            // Token: 0x060003A5 RID: 933 RVA: 0x0003ED35 File Offset: 0x0001ED35
            public override void WriteByte(byte value)
            {
                throw new NotSupportedException(SR.net_http_content_readonly_stream);
            }

            // Token: 0x060003A6 RID: 934 RVA: 0x0003ED35 File Offset: 0x0001ED35
            public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
            {
                throw new NotSupportedException(SR.net_http_content_readonly_stream);
            }

            // Token: 0x060003A7 RID: 935 RVA: 0x0003ED35 File Offset: 0x0001ED35
            public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken))
            {
                throw new NotSupportedException(SR.net_http_content_readonly_stream);
            }
        }
    }



    // Token: 0x02000098 RID: 152
    internal static class StreamToStreamCopy
    {
        // Token: 0x060003A8 RID: 936 RVA: 0x0003ED4C File Offset: 0x0001ED4C
        public static Task CopyAsync(Stream source, Stream destination, int bufferSize, bool disposeSource, CancellationToken cancellationToken = default(CancellationToken))
        {
            Task result;
            try
            {
                Task task = (bufferSize == 0) ? source.CopyToAsync(destination, cancellationToken) : source.CopyToAsync(destination, bufferSize, cancellationToken);
                result = (disposeSource ? StreamToStreamCopy.DisposeSourceWhenCompleteAsync(task, source) : task);
            }
            catch (Exception exception)
            {
                result = Task.FromException(exception);
            }
            return result;
        }

        // Token: 0x060003A9 RID: 937 RVA: 0x0003EDA0 File Offset: 0x0001EDA0
        private static Task DisposeSourceWhenCompleteAsync(Task task, Stream source)
        {
            TaskStatus status = task.Status;
            if (status == TaskStatus.RanToCompletion)
            {
                StreamToStreamCopy.DisposeSource(source);
                return Task.CompletedTask;
            }
            if (status - TaskStatus.Canceled > 1)
            {
                return task.ContinueWith(delegate (Task completed, object innerSource)
                {
                    completed.GetAwaiter().GetResult();
                    StreamToStreamCopy.DisposeSource((Stream)innerSource);
                }, source, CancellationToken.None, TaskContinuationOptions.DenyChildAttach | TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);
            }
            return task;
        }

        // Token: 0x060003AA RID: 938 RVA: 0x0003EE04 File Offset: 0x0001EE04
        private static void DisposeSource(Stream source)
        {
            try
            {
                source.Dispose();
            }
            catch (Exception message)
            {
                if (NetEventSource.IsEnabled)
                {
                    NetEventSource.Error(null, message, "DisposeSource");
                }
            }
        }
    }

    // Token: 0x020000A4 RID: 164
    internal static class StringBuilderExtensions
    {
        // Token: 0x060003FD RID: 1021 RVA: 0x00040BF4 File Offset: 0x00020BF4
        public static void _AppendKeyValue(this StringBuilder sb, string key, string value, bool includeQuotes = true, bool includeComma = true)
        {
            sb.Append(key);
            sb.Append('=');
            if (includeQuotes)
            {
                sb.Append('"');
            }
            sb.Append(value);
            if (includeQuotes)
            {
                sb.Append('"');
            }
            if (includeComma)
            {
                sb.Append(',');
                sb.Append(' ');
            }
        }
    }

    /// <summary>
    ///         文字列に基く HTTP コンテンツを提供します。
    ///       </summary>
    // Token: 0x0200009A RID: 154
    class StringContent : ByteArrayContent
    {
        /// <summary>
        ///         <see cref="T:System.Net.Http.StringContent" /> クラスの新しいインスタンスを作成します。
        ///       </summary>
        /// <param name="content">
        ///           <see cref="T:System.Net.Http.StringContent" /> の初期化に使用されるコンテンツ。
        ///         </param>
        // Token: 0x060003AE RID: 942 RVA: 0x0003EE72 File Offset: 0x0001EE72
        public StringContent(string content) : this(content, null, null)
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.StringContent" /> クラスの新しいインスタンスを作成します。
        ///       </summary>
        /// <param name="content">
        ///           <see cref="T:System.Net.Http.StringContent" /> の初期化に使用されるコンテンツ。
        ///         </param>
        /// <param name="encoding">
        ///           コンテンツを使用するエンコーディング。
        ///         </param>
        // Token: 0x060003AF RID: 943 RVA: 0x0003EE7D File Offset: 0x0001EE7D
        public StringContent(string content, Encoding encoding) : this(content, encoding, null)
        {
        }

        /// <summary>
        ///         <see cref="T:System.Net.Http.StringContent" /> クラスの新しいインスタンスを作成します。
        ///       </summary>
        /// <param name="content">
        ///           <see cref="T:System.Net.Http.StringContent" /> の初期化に使用されるコンテンツ。
        ///         </param>
        /// <param name="encoding">
        ///           コンテンツを使用するエンコーディング。
        ///         </param>
        /// <param name="mediaType">
        ///           メディアの種類のコンテンツを使用します。
        ///         </param>
        // Token: 0x060003B0 RID: 944 RVA: 0x0003EE88 File Offset: 0x0001EE88
        public StringContent(string content, Encoding encoding, string mediaType) : base(StringContent.GetContentByteArray(content, encoding))
        {
            MediaTypeHeaderValue mediaTypeHeaderValue = new MediaTypeHeaderValue((mediaType == null) ? "text/plain" : mediaType);
            mediaTypeHeaderValue.CharSet = ((encoding == null) ? HttpContent.DefaultStringEncoding.WebName : encoding.WebName);
            base.Headers.ContentType = mediaTypeHeaderValue;
        }

        // Token: 0x060003B1 RID: 945 RVA: 0x0003EEDA File Offset: 0x0001EEDA
        private static byte[] GetContentByteArray(string content, Encoding encoding)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            if (encoding == null)
            {
                encoding = HttpContent.DefaultStringEncoding;
            }
            return encoding.GetBytes(content);
        }

        // Token: 0x060003B2 RID: 946 RVA: 0x0003EEFB File Offset: 0x0001EEFB
        internal override Stream TryCreateContentReadStream()
        {
            if (!(base.GetType() == typeof(StringContent)))
            {
                return null;
            }
            return base.CreateMemoryStreamForByteArray();
        }
    }

    // Token: 0x020000FC RID: 252
    internal static class SystemProxyInfo
    {
        // Token: 0x060005B9 RID: 1465 RVA: 0x0004C4F0 File Offset: 0x0002C4F0
        public static IWebProxy ConstructSystemProxy()
        {
            IWebProxy result;
            if (!HttpEnvironmentProxy.TryCreate(out result))
            {
                return null;
            }
            return result;
        }
    }

    // Token: 0x02000117 RID: 279
    internal static class TLSCertificateExtensions
    {
        // Token: 0x060006BD RID: 1725 RVA: 0x00051CC0 File Offset: 0x00031CC0
        private static bool IsClientCertificate(X509Certificate2 cert)
        {
            bool flag = false;
            bool flag2 = false;
            bool flag3 = true;
            bool flag4 = true;
            foreach (X509Extension x509Extension in cert.Extensions)
            {
                if (!flag)
                {
                    X509EnhancedKeyUsageExtension x509EnhancedKeyUsageExtension = x509Extension as X509EnhancedKeyUsageExtension;
                    if (x509EnhancedKeyUsageExtension != null)
                    {
                        flag = true;
                        flag3 = false;
                        foreach (Oid oid in x509EnhancedKeyUsageExtension.EnhancedKeyUsages)
                        {
                            if (string.Equals("1.3.6.1.5.5.7.3.2", oid.Value))
                            {
                                flag3 = true;
                                break;
                            }
                        }
                    }
                }
                if (!flag2)
                {
                    X509KeyUsageExtension x509KeyUsageExtension = x509Extension as X509KeyUsageExtension;
                    if (x509KeyUsageExtension != null)
                    {
                        flag2 = true;
                        flag4 = ((x509KeyUsageExtension.KeyUsages & X509KeyUsageFlags.DigitalSignature) > X509KeyUsageFlags.None);
                    }
                }
                if (flag2 && flag)
                {
                    break;
                }
            }
            return flag3 && flag4;
        }

        // Token: 0x060006BE RID: 1726 RVA: 0x00051D74 File Offset: 0x00031D74
        internal static X509Chain BuildNewChain(X509Certificate2 certificate, bool includeClientApplicationPolicy)
        {
            X509Chain x509Chain = new X509Chain();
            x509Chain.ChainPolicy.VerificationFlags = X509VerificationFlags.AllFlags;
            x509Chain.ChainPolicy.RevocationFlag = X509RevocationFlag.ExcludeRoot;
            x509Chain.ChainPolicy.RevocationMode = X509RevocationMode.NoCheck;
            if (includeClientApplicationPolicy)
            {
                x509Chain.ChainPolicy.ApplicationPolicy.Add(TLSCertificateExtensions.s_clientCertOidInst);
            }
            if (x509Chain.Build(certificate))
            {
                return x509Chain;
            }
            x509Chain.Dispose();
            return null;
        }

        // Token: 0x060006BF RID: 1727 RVA: 0x00051DDC File Offset: 0x00031DDC
        internal static bool _TryFindClientCertificate(this X509Certificate2Collection certificates, ISet<string> allowedIssuers, out X509Certificate2 clientCertificate, out X509Chain clientCertChain)
        {
            clientCertificate = null;
            clientCertChain = null;
            if (certificates == null)
            {
                return false;
            }
            DateTime now = DateTime.Now;
            foreach (X509Certificate2 x509Certificate in certificates)
            {
                if (x509Certificate.HasPrivateKey && now >= x509Certificate.NotBefore && now <= x509Certificate.NotAfter && TLSCertificateExtensions.IsClientCertificate(x509Certificate))
                {
                    if (allowedIssuers.Count == 0)
                    {
                        clientCertificate = x509Certificate;
                        clientCertChain = null;
                        return true;
                    }
                    X509Chain x509Chain = TLSCertificateExtensions.BuildNewChain(x509Certificate, true);
                    if (x509Chain != null)
                    {
                        bool flag = true;
                        foreach (X509ChainStatus x509ChainStatus in x509Chain.ChainStatus)
                        {
                            if ((x509ChainStatus.Status & X509ChainStatusFlags.PartialChain) == X509ChainStatusFlags.PartialChain)
                            {
                                flag = false;
                                break;
                            }
                        }
                        if (x509Chain.ChainElements.Count > 0 && flag)
                        {
                            X509Certificate2 certificate = x509Chain.ChainElements[x509Chain.ChainElements.Count - 1].Certificate;
                            if (allowedIssuers.Contains(certificate.SubjectName.Name))
                            {
                                clientCertificate = x509Certificate;
                                clientCertChain = x509Chain;
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Token: 0x04000505 RID: 1285
        private static Oid s_clientCertOidInst = new Oid("1.3.6.1.5.5.7.3.2");
    }

    // Token: 0x02000063 RID: 99
    internal static class SslClientAuthenticationOptionsExtensions
    {
        // Token: 0x060001D6 RID: 470 RVA: 0x00038C48 File Offset: 0x00018C48
        public static SslClientAuthenticationOptions _ShallowClone(this SslClientAuthenticationOptions options)
        {
            return new SslClientAuthenticationOptions
            {
                AllowRenegotiation = options.AllowRenegotiation,
                ApplicationProtocols = options.ApplicationProtocols,
                CertificateRevocationCheckMode = options.CertificateRevocationCheckMode,
                ClientCertificates = options.ClientCertificates,
                EnabledSslProtocols = options.EnabledSslProtocols,
                EncryptionPolicy = options.EncryptionPolicy,
                LocalCertificateSelectionCallback = options.LocalCertificateSelectionCallback,
                RemoteCertificateValidationCallback = options.RemoteCertificateValidationCallback,
                TargetHost = options.TargetHost
            };
        }
    }

    static class NetEventSource
    {
        public static bool IsEnabled => false;

        public static void Error(params object[] args) { }
        public static void Associate(params object[] args) { }
        public static void Enter(params object[] args) { }
        public static void Exit(params object[] args) { }
        public static void ContentNull(params object[] args) { }
        public static void Info(params object[] args) { }
        public static void UriBaseAddress(params object[] args) { }
        public static void ClientSendCompleted(params object[] args) { }

        public static class Log
        {
            public static void HeadersInvalidValue(params object[] args) { }
            public static void HandlerMessage(params object[] args) { }
       }
    }
}


